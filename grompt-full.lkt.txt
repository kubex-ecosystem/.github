# LookAtni Code - Gerado automaticamente
# Data: 2025-09-09T03:32:47.186Z
# Fonte: ./parking
# Total de arquivos: 46

/// App.tsx ///
// import React from 'react'
import { BotMessageSquare, Moon, Sun } from 'lucide-react';
import { createContext, useContext, useEffect, useState } from 'react';
import PromptCrafter from './components/PromptCrafter';

type Theme = 'light' | 'dark';
type Language = 'en' | 'es' | 'zh';

const translations: Record<Language, Record<string, string>> = {
  en: {
    'promptCrafter': 'Prompt Crafter',
    'toggleTheme': 'Switch to {theme} mode',
    'poweredBy': 'Kubex Principles: Radical Simplicity, No Cages.',
    'motto': 'CODE FAST. OWN EVERYTHING.',
  },
  es: {
    'promptCrafter': 'Creador de Prompts',
    'toggleTheme': 'Cambiar a modo {theme}',
    'poweredBy': 'Principios de Kubex: Simplicidad Radical, Sin Jaulas.',
    'motto': 'CODIFICA R√ÅPIDO. S√â DUE√ëO DE TODO.',
  },
  zh: {
    'promptCrafter': 'ÊèêÁ§∫ËØçÊûÑÂª∫Âô®',
    'toggleTheme': 'ÂàáÊç¢Âà∞{theme}Ê®°Âºè',
    'poweredBy': 'Kubex ÂéüÂàôÔºöÊûÅËá¥ÁÆÄÁ∫¶ÔºåÊó†ÊãòÊó†Êùü„ÄÇ',
    'motto': 'Âø´ÈÄüÁºñÁ†Å„ÄÇÊã•Êúâ‰∏ÄÂàá„ÄÇ',
  }
};

interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
  t: (key: string, params?: Record<string, string>) => string;
}

export const LanguageContext = createContext<LanguageContextType>({
  language: 'en',
  setLanguage: () => { },
  t: (key) => key,
});

const LanguageSelector: React.FC = () => {
  const { language, setLanguage } = useContext(LanguageContext);

  const languages: { code: Language; flag: React.ReactNode }[] = [
    { code: 'en', flag: <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 48"><path fill="#6a7bff" d="M0 0h72v48H0z" /><path fill="#fff" d="M0 0h72v24H0z" /><path fill="#ff4b55" d="M0 0h72v12H0z" /><path fill="#fff" d="M0 0h36v24H0z" /><path fill="#1e2a3d" d="M0 0h24v24H0z" /><path fill="#fff" d="m13 13-1-3-1 3h2zm-3-1 3 1v-2l-3 1zm1 3-1 1h2l-1-1zm-1 3 1-3 1 3h-2zM8 9l1 3 1-3H8zm3 1-3 1v-2l3 1zm-1 3 1 1H9l1-1zm1 3-1-3-1 3h2zm5-10-1 3-1-3h2zm-3-1 3 1v-2l-3 1zm1 3-1 1h2l-1-1zm-1 3 1-3 1 3h-2zM8 2l1 3 1-3H8zm3 1-3 1V1l3 1zm-1 3 1 1H9l1-1zm1 3-1-3-1 3h2z" /></svg> },
    { code: 'es', flag: <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 48"><path fill="#ff4b55" d="M0 0h72v48H0z" /><path fill="#ffd500" d="M0 12h72v24H0z" /><path fill="#ff4b55" d="M30 18h2v12h-2zm-2 0h-2v12h2zm-2 1h-1v10h1v-4h2v-2h-2v-4z" /><path fill="#ffd500" d="M30 18h-2v12h2v-5h-1v-2h1v-5z" /><path fill="#ff4b55" d="M31 23h-6v1h6v-1z" /></svg> },
    { code: 'zh', flag: <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 48"><path fill="#ff4b55" d="M0 0h72v48H0z" /><path fill="#ffd500" d="m18 9 2.2 6.8h7.1L21 20l2.2 6.8L18 22.1l-5.3 4.7L15 20l-6.2-4.2h7.1zm12.5 1.5 1 .8-.5 1.3-1.2-.3.1-1.4zm-1 16 .3-1.3-1.2.3.9 1zm6.5-13.5.8-1-1.3.6.5.4zm-4 14-1.3-.5.5-1.3.8 1zm3.5-1.5-.7 1.1.9.8.3-1.4-.5-.5z" /></svg> },
  ];

  return (
    <div className="flex items-center gap-1 bg-slate-200/50 dark:bg-[#10151b] p-1 rounded-full">
      {languages.map(lang => (
        <button
          key={lang.code}
          onClick={() => setLanguage(lang.code)}
          className={`w-8 h-8 rounded-full flex items-center justify-center transition-all duration-300 overflow-hidden ${language === lang.code ? 'ring-2 ring-sky-500 dark:ring-[#00f0ff] scale-110' : 'hover:opacity-80'}`}
          aria-label={`Switch to ${lang.code}`}
        >
          <div className="w-full h-full">{lang.flag}</div>
        </button>
      ))}
    </div>
  );
};

const App: React.FC = () => {
  const [theme, setTheme] = useState<Theme>('dark');
  const [language, setLanguage] = useState<Language>('en');

  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as Theme | null;
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
    setTheme(initialTheme);

    const savedLang = localStorage.getItem('language') as Language | null;
    const browserLang = navigator.language.split('-')[0] as Language;
    const initialLang = savedLang || (['en', 'es', 'zh'].includes(browserLang) ? browserLang : 'en');
    setLanguage(initialLang);
  }, []);

  useEffect(() => {
    const root = window.document.documentElement;
    const body = window.document.body;
    root.classList.remove('light', 'dark');
    root.classList.add(theme);
    body.classList.remove('light-theme', 'dark-theme');
    body.classList.add(`${theme}-theme`);
    localStorage.setItem('theme', theme);
  }, [theme]);

  useEffect(() => {
    localStorage.setItem('language', language);
  }, [language]);

  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  const t = (key: string, params?: Record<string, string>): string => {
    let translation = translations[language][key] || translations.en[key] || key;
    if (params) {
      Object.keys(params).forEach(paramKey => {
        translation = translation.replace(`{${paramKey}}`, params[paramKey]);
      });
    }
    return translation;
  };

  return (
    <LanguageContext.Provider value={{ language, setLanguage, t }}>
      <div className="min-h-screen text-slate-800 dark:text-[#e0f7fa] font-plex-mono p-4 sm:p-6 lg:p-8">
        <div className="max-w-7xl mx-auto">
          <header className="mb-8 flex items-center justify-between">
            <div className="flex items-center gap-4">
              <div className="w-12 h-12 bg-white/50 dark:bg-[#10151b] border-2 border-sky-500 dark:border-[#00f0ff] rounded-full flex items-center justify-center shadow-lg dark:neon-border-cyan">
                <BotMessageSquare size={24} className="text-sky-500 dark:text-[#00f0ff] dark:neon-glow-cyan" />
              </div>
              <div>
                <h1 className="text-3xl font-bold font-orbitron text-sky-500 light-shadow-sky dark:text-[#00f0ff] dark:neon-glow-cyan tracking-widest uppercase">
                  KUBEX
                </h1>
                <h2 className="text-lg text-slate-500 dark:text-[#90a4ae] font-medium font-plex-mono">
                  {t('promptCrafter')}
                </h2>
              </div>
            </div>
            <div className="flex items-center gap-3">
              <LanguageSelector />
              <button
                onClick={toggleTheme}
                className="p-2 rounded-full bg-slate-200/50 dark:bg-[#10151b] text-slate-600 dark:text-[#90a4ae] hover:text-sky-500 dark:hover:text-[#00f0ff] transition-colors duration-200"
                aria-label={t('toggleTheme', { theme: theme === 'light' ? 'dark' : 'light' })}
              >
                {theme === 'light' ? <Moon size={24} /> : <Sun size={24} />}
              </button>
            </div>
          </header>
          <main>
            <PromptCrafter />
          </main>
          <footer className="text-center mt-12 text-slate-500 dark:text-[#90a4ae] text-xs">
            <p>{t('poweredBy')}</p>
            <p className="mt-1 font-orbitron tracking-wider">{t('motto')}</p>
          </footer>
        </div>
      </div>
    </LanguageContext.Provider>
  );
};

export default App;

/// CHANGELOG.md ///
# Changelog

All notable changes to Grompt will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [2.0.0] - 2025-09-08

### üéâ Major Release - Welcome to Kubex.world

This is the official public launch of Grompt v2.0 on the new Kubex.world domain!

### ‚ú® Added

#### Core Features

- **Demo Mode**: App now works perfectly without API key using intelligent simulated responses
- **User API Key Input**: Users can securely add their own Gemini API key via UI
- **Multi-language Support**: Complete translations for EN, ES, PT-BR, ZH
- **Privacy-First Analytics**: Simple, GDPR-compliant tracking system
- **PWA Support**: Enhanced Progressive Web App capabilities

#### Infrastructure & Deployment

- **Production Domain**: Official deployment to kubex.world
- **CDN Independence**: Removed dependency on aistudiocdn.com, using esm.sh
- **Enhanced SEO**: Comprehensive meta tags, Open Graph, Twitter Cards
- **Security Headers**: Added security.txt and proper security configuration
- **Sitemap & Robots**: SEO optimization for search engines

#### Developer Experience

- **Environment Variables**: Extensive env var support for multiple AI providers
- **Better Error Handling**: Graceful fallbacks and user-friendly error messages
- **Code Documentation**: Comprehensive documentation and inline comments
- **Build Optimization**: Improved Vite configuration for production

#### UI/UX Improvements

- **Version Badge**: v2.0 indicator in header
- **Kubex Branding**: Integration with Kubex ecosystem identity
- **Enhanced Footer**: Links to ecosystem, GitHub, security, humans.txt
- **Loading States**: Better feedback during API calls
- **Responsive Design**: Improved mobile experience

### üîÑ Changed

#### Breaking Changes

- **API Key Handling**: Changed from required to optional with demo fallback
- **Build Configuration**: Updated Vite config for production deployment
- **CDN Sources**: Migrated from aistudiocdn to standard ESM CDN

#### Improvements

- **Performance**: Better bundle splitting and chunk optimization
- **Security**: Enhanced API key validation and storage
- **Accessibility**: Improved ARIA labels and keyboard navigation
- **Error Messages**: More helpful and actionable error descriptions

### üêõ Fixed

- **White Screen Issue**: Resolved deployment issues when API key is missing
- **CDN Dependencies**: Removed reliance on non-standard CDN providers
- **Mobile Compatibility**: Fixed responsive design issues
- **Theme Persistence**: Improved dark/light mode persistence

### üèóÔ∏è Technical Details

#### Stack Updates

- React 19.1.1
- Vite 6.2.0
- TypeScript 5.8.2
- Tailwind CSS (latest)
- Google Gemini AI integration

#### Deployment

- Vercel hosting on kubex.world
- Environment variable configuration
- Static asset optimization
- Progressive Web App manifest

#### Security

- Client-side API key storage only
- No server-side API key requirements
- HTTPS-only deployment
- Content Security Policy headers

### üéØ Kubex Principles Applied

This release fully embodies the three core Kubex principles:

1. **Radical Simplicity**:
   - One-click deployment without configuration
   - Demo mode works immediately
   - Clear, jargon-free interface

2. **Modularity**:
   - Pluggable AI providers
   - Component-based architecture
   - Configurable through environment variables

3. **No Cages**:
   - No vendor lock-in (works with any Gemini-compatible API)
   - Open source codebase
   - Standard web technologies only
   - User controls their own API keys

### üöÄ What's Next

#### Planned for v2.1

- [ ] Additional AI provider support (OpenAI, Anthropic, Ollama)
- [ ] Advanced prompt templates
- [ ] Export functionality (PDF, Markdown)
- [ ] Collaborative features

#### Long-term Roadmap

- [ ] Plugin system for custom prompt types
- [ ] Integration with popular development tools
- [ ] Advanced analytics and usage insights
- [ ] Enterprise deployment options

---

## [1.0.8] - 2025-09-07

### Added

- Initial stable release
- Basic prompt generation with Gemini AI
- Theme switching (dark/light)
- Local storage for prompts and settings

### Fixed

- Various bug fixes and stability improvements

---

**Legend:**

- üéâ Major release
- ‚ú® New features
- üîÑ Changes
- üêõ Bug fixes
- üèóÔ∏è Technical details
- üéØ Philosophy & principles
- üöÄ Future plans

/// README.md ///
# Grompt: AI Prompt Crafter

![Grompt Logo](https://github.com/kubex-ecosystem/grompt/raw/main/docs/assets/logo.png)

Grompt is an intelligent AI prompt crafting tool built with Kubex principles: Radical Simplicity, Modularity, and No Cages. Transform your raw ideas into professional, structured prompts for AI models.

## ‚ú® Features

- üß† **Smart Prompt Engineering**: Transform raw ideas into structured, professional prompts
- üéØ **Multiple Purposes**: Code generation, creative writing, data analysis, technical documentation, and more
- üåô **Dark/Light Theme**: Beautiful UI that adapts to your preference
- üåç **Multi-language**: Support for English, Spanish, Chinese, and Portuguese
- üíæ **Local Storage**: Save your prompts and ideas locally
- üîó **Shareable Links**: Share your prompts via URL
- üîë **Flexible API Key**: Works in demo mode or with your own Gemini API key
- üì± **Responsive Design**: Works perfectly on desktop and mobile

## üöÄ Quick Start

### Option 1: Demo Mode (No API Key Required)

1. Clone the repository
2. Install dependencies: `npm install`
3. Start the development server: `npm run dev`
4. Open <http://localhost:5173>

The app will work in **demo mode** with simulated AI responses, perfect for testing and demonstrating the interface.

### Option 2: With Gemini API Key

1. Get a free API key from [Google AI Studio](https://ai.google.dev/)
2. Either:
   - **Environment Variable**: Create `.env.local` and add `GEMINI_API_KEY=your_key_here`
   - **User Input**: Enter your API key directly in the app interface (stored locally)
3. Run the app as above

## üîß Configuration

### Environment Variables

```bash
# Optional - app works in demo mode without this
GEMINI_API_KEY=your_gemini_api_key_here
```

### User API Key

If no environment variable is set, users can input their own API key directly in the interface. The key is:

- Stored only in localStorage (never sent to external servers)
- Validated for format (starts with "AIza", proper length)
- Used dynamically for API calls
- Can be cleared at any time

## üèóÔ∏è Build and Deploy

```bash
# Build for production
npm run build

# Preview production build
npm run preview

# Build static files
npm run build:static
```

The app is designed to be deployed anywhere - Vercel, Netlify, GitHub Pages, or any static hosting service.

## üéØ Kubex Principles

- **Radical Simplicity**: One command = one result. Direct, pragmatic, anti-jargon.
- **Modularity**: Well-structured, reusable components and outputs.
- **No Cages**: Platform-agnostic, open formats, no vendor lock-in.

## üõ†Ô∏è Technology Stack

- **React 19** with TypeScript
- **Vite** for blazing fast development
- **Tailwind CSS** for styling
- **Google Gemini AI** for prompt generation
- **Lucide React** for icons
- **No vendor-specific CDNs** - uses standard ESM.sh

## üìÑ License

MIT License - see [LICENSE](LICENSE) file for details.

## ü§ù Contributing

Contributions are welcome! Please read our [contributing guidelines](docs/CONTRIBUTING.md) first.

---

Built with ‚ù§Ô∏è following Kubex principles: **CODE FAST. OWN EVERYTHING.**

/// components/PromptCrafter.tsx ///
import { AlertTriangle, BrainCircuit, Clipboard, ClipboardCheck, Code, Eye, History, Lightbulb, Loader, Plus, Share2, Trash2, Wand2, X, XCircle } from 'lucide-react';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { LanguageContext } from '../App';
import { generateStructuredPrompt } from '../services/geminiService';
import { HistoryItem, Idea } from '../types';

// --- IndexedDB Helpers for Autosave ---
const DB_NAME = 'PromptCrafterDB';
const STORE_NAME = 'drafts';
const DB_VERSION = 1;

interface Draft {
  ideas: Idea[];
  purpose: string;
}

const openDB = (): Promise<IDBDatabase> => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = () => reject(new Error("Error opening IndexedDB. Your browser might be in private mode."));
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME);
      }
    };
  });
};

const getDraft = async <T,>(key: IDBValidKey): Promise<T | undefined> => {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.get(key);
    request.onerror = () => reject(new Error("Error getting draft from IndexedDB"));
    request.onsuccess = () => resolve(request.result as T | undefined);
  });
};

const setDraft = async <T,>(key: IDBValidKey, value: T): Promise<void> => {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORE_NAME, 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.put(value, key);
    request.onerror = () => reject(new Error("Error setting draft in IndexedDB"));
    request.onsuccess = () => resolve();
  });
};


interface Example {
  purpose: string;
  ideas: string[];
}

const examples: Example[] = [
  {
    purpose: "Code Generation",
    ideas: [
      "Create a React hook for fetching data from an API.",
      "It should handle loading, error, and data states.",
      "Use the native `fetch` API.",
      "The hook should be written in TypeScript and be well-documented.",
    ],
  },
  {
    purpose: "Creative Writing",
    ideas: [
      "Write a short story opening.",
      "The setting is a neon-lit cyberpunk city in 2077.",
      "The main character is a grizzled detective who is part-cyborg.",
      "It's perpetually raining and the streets are reflective.",
    ],
  },
  {
    purpose: "Data Analysis",
    ideas: [
      "Analyze a dataset of customer sales from the last quarter.",
      "The dataset includes columns: 'Date', 'CustomerID', 'ProductCategory', 'Revenue', 'UnitsSold'.",
      "Identify the top 3 product categories by total revenue.",
      "Calculate the average revenue per customer.",
      "Look for any weekly sales trends or seasonality.",
    ],
  },
  {
    purpose: "Marketing Copy",
    ideas: [
      "Draft an email campaign for a new productivity app.",
      "The target audience is busy professionals and university students.",
      "Highlight features like AI-powered task scheduling, calendar sync, and focus mode.",
      "The tone should be encouraging, professional, and slightly urgent.",
    ],
  },
  {
    purpose: "Technical Documentation",
    ideas: [
      "Write the 'Getting Started' section for a new JavaScript library.",
      "The library is called 'ChronoWarp' and it simplifies date manipulation.",
      "Include a simple installation guide using npm.",
      "Provide a clear, concise code example for its primary use case."
    ]
  }
];

const purposeKeys: Record<string, string> = {
  "Code Generation": "purposeCodeGeneration",
  "Creative Writing": "purposeCreativeWriting",
  "Data Analysis": "purposeDataAnalysis",
  "Technical Documentation": "purposeTechnicalDocumentation",
  "Marketing Copy": "purposeMarketingCopy",
  "General Summarization": "purposeGeneralSummarization",
};

const i18n: Record<string, Record<string, string>> = {
  en: {
    "inputIdeasTitle": "1. INPUT IDEAS",
    "loadExample": "Load Example",
    "ideaPlaceholder": "Enter a raw idea, concept, or requirement...",
    "addIdea": "Add Idea",
    "removeIdea": "Remove idea: {idea}",
    "purposeLabel": "Purpose",
    "purposeCodeGeneration": "Code Generation",
    "purposeCreativeWriting": "Creative Writing",
    "purposeDataAnalysis": "Data Analysis",
    "purposeTechnicalDocumentation": "Technical Documentation",
    "purposeMarketingCopy": "Marketing Copy",
    "purposeGeneralSummarization": "General Summarization",
    "customPurposePlaceholder": "Or type a custom purpose...",
    "generatedPromptTitle": "2. GENERATED PROMPT",
    "generatingMessage": "Generating with Gemini...",
    "generationFailedTitle": "Generation Failed",
    "close": "Close",
    "toggleView": "Toggle view mode",
    "copyLink": "Copy shareable link",
    "copyPrompt": "Copy prompt text",
    "promptPlaceholder": "Your professional prompt will appear here.",
    "generateButton": "GENERATE PROMPT",
    "generatingButton": "GENERATING...",
    "historyTitle": "3. PROMPT HISTORY",
    "clearAll": "Clear All",
    "historyPlaceholder": "Your generated prompts will be saved here.",
    "loadPrompt": "Load this prompt",
    "deletePrompt": "Delete this prompt",
    "errorAddIdea": "Please add at least one idea before generating.",
    "errorSpecifyPurpose": "Please specify a purpose for the prompt before generating.",
    "tokens": "tokens",
    "input": "Input",
    "output": "Output",
    "total": "Total",
  },
  es: {
    "inputIdeasTitle": "1. INGRESAR IDEAS",
    "loadExample": "Cargar Ejemplo",
    "ideaPlaceholder": "Introduce una idea, concepto o requisito...",
    "addIdea": "A√±adir Idea",
    "removeIdea": "Quitar idea: {idea}",
    "purposeLabel": "Prop√≥sito",
    "purposeCodeGeneration": "Generaci√≥n de C√≥digo",
    "purposeCreativeWriting": "Escritura Creativa",
    "purposeDataAnalysis": "An√°lisis de Datos",
    "purposeTechnicalDocumentation": "Documentaci√≥n T√©cnica",
    "purposeMarketingCopy": "Copy de Marketing",
    "purposeGeneralSummarization": "Resumen General",
    "customPurposePlaceholder": "O escribe un prop√≥sito personalizado...",
    "generatedPromptTitle": "2. PROMPT GENERADO",
    "generatingMessage": "Generando con Gemini...",
    "generationFailedTitle": "Fall√≥ la Generaci√≥n",
    "close": "Cerrar",
    "toggleView": "Cambiar vista",
    "copyLink": "Copiar enlace para compartir",
    "copyPrompt": "Copiar texto del prompt",
    "promptPlaceholder": "Tu prompt profesional aparecer√° aqu√≠.",
    "generateButton": "GENERAR PROMPT",
    "generatingButton": "GENERANDO...",
    "historyTitle": "3. HISTORIAL DE PROMPTS",
    "clearAll": "Limpiar Todo",
    "historyPlaceholder": "Tus prompts generados se guardar√°n aqu√≠.",
    "loadPrompt": "Cargar este prompt",
    "deletePrompt": "Eliminar este prompt",
    "errorAddIdea": "Por favor, a√±ade al menos una idea antes de generar.",
    "errorSpecifyPurpose": "Por favor, especifica un prop√≥sito para el prompt antes de generar.",
    "tokens": "tokens",
    "input": "Entrada",
    "output": "Salida",
    "total": "Total",
  },
  zh: {
    "inputIdeasTitle": "1. ËæìÂÖ•ÊÉ≥Ê≥ï",
    "loadExample": "Âä†ËΩΩÁ§∫‰æã",
    "ideaPlaceholder": "ËæìÂÖ•‰∏Ä‰∏™ÂéüÂßãÊÉ≥Ê≥ï„ÄÅÊ¶ÇÂøµÊàñË¶ÅÊ±Ç...",
    "addIdea": "Ê∑ªÂä†ÊÉ≥Ê≥ï",
    "removeIdea": "Âà†Èô§ÊÉ≥Ê≥ï: {idea}",
    "purposeLabel": "ÁõÆÁöÑ",
    "purposeCodeGeneration": "‰ª£Á†ÅÁîüÊàê",
    "purposeCreativeWriting": "ÂàõÊÑèÂÜô‰Ωú",
    "purposeDataAnalysis": "Êï∞ÊçÆÂàÜÊûê",
    "purposeTechnicalDocumentation": "ÊäÄÊúØÊñáÊ°£",
    "purposeMarketingCopy": "Ëê•ÈîÄÊñáÊ°à",
    "purposeGeneralSummarization": "ÈÄöÁî®ÊÄªÁªì",
    "customPurposePlaceholder": "ÊàñËæìÂÖ•Ëá™ÂÆö‰πâÁõÆÁöÑ...",
    "generatedPromptTitle": "2. ÁîüÊàêÁöÑÊèêÁ§∫",
    "generatingMessage": "Ê≠£Âú®ÈÄöËøá Gemini ÁîüÊàê...",
    "generationFailedTitle": "ÁîüÊàêÂ§±Ë¥•",
    "close": "ÂÖ≥Èó≠",
    "toggleView": "ÂàáÊç¢ËßÜÂõæ",
    "copyLink": "Â§çÂà∂ÂàÜ‰∫´ÈìæÊé•",
    "copyPrompt": "Â§çÂà∂ÊèêÁ§∫ÊñáÊú¨",
    "promptPlaceholder": "ÊÇ®ÁöÑ‰∏ì‰∏öÊèêÁ§∫Â∞ÜÂá∫Áé∞Âú®ËøôÈáå„ÄÇ",
    "generateButton": "ÁîüÊàêÊèêÁ§∫",
    "generatingButton": "Ê≠£Âú®ÁîüÊàê...",
    "historyTitle": "3. ÊèêÁ§∫ÂéÜÂè≤",
    "clearAll": "ÂÖ®ÈÉ®Ê∏ÖÈô§",
    "historyPlaceholder": "ÊÇ®ÁîüÊàêÁöÑÊèêÁ§∫Â∞Ü‰øùÂ≠òÂú®ËøôÈáå„ÄÇ",
    "loadPrompt": "Âä†ËΩΩÊ≠§ÊèêÁ§∫",
    "deletePrompt": "Âà†Èô§Ê≠§ÊèêÁ§∫",
    "errorAddIdea": "ÁîüÊàêÂâçËØ∑Ëá≥Â∞ëÊ∑ªÂä†‰∏Ä‰∏™ÊÉ≥Ê≥ï„ÄÇ",
    "errorSpecifyPurpose": "ÁîüÊàêÂâçËØ∑‰∏∫ÊèêÁ§∫ÊåáÂÆö‰∏Ä‰∏™ÁõÆÁöÑ„ÄÇ",
    "tokens": "‰∏™ token",
    "input": "ËæìÂÖ•",
    "output": "ËæìÂá∫",
    "total": "ÊÄªËÆ°",
  },
};

const useTranslations = () => {
  const { language } = useContext(LanguageContext);
  const t = (key: string, params?: Record<string, string>): string => {
    let translation = i18n[language][key] || i18n['en'][key] || key;
    if (params) {
      Object.keys(params).forEach(paramKey => {
        translation = translation.replace(`{${paramKey}}`, params[paramKey]);
      });
    }
    return translation;
  };
  return { t, language };
};


const formatRelativeTime = (timestamp: number, locale: string): string => {
  try {
    const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
    const seconds = Math.floor((Date.now() - timestamp) / 1000);

    if (seconds < 60) return rtf.format(Math.floor(-seconds), 'second');
    if (seconds < 3600) return rtf.format(-Math.floor(seconds / 60), 'minute');
    if (seconds < 86400) return rtf.format(-Math.floor(seconds / 3600), 'hour');
    if (seconds < 2592000) return rtf.format(-Math.floor(seconds / 86400), 'day');
    if (seconds < 31536000) return rtf.format(-Math.floor(seconds / 2592000), 'month');
    return rtf.format(-Math.floor(seconds / 31536000), 'year');
  } catch (e) {
    console.error("Error formatting relative time", e);
    return new Date(timestamp).toLocaleDateString();
  }
};

// --- Sub-components (Memoized) ---

interface IdeaInputProps {
  currentIdea: string;
  setCurrentIdea: (value: string) => void;
  onAddIdea: () => void;
}
const IdeaInput: React.FC<IdeaInputProps> = React.memo(({ currentIdea, setCurrentIdea, onAddIdea }) => {
  const { t } = useTranslations();
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      onAddIdea();
    }
  };

  return (
    <div className="flex gap-2">
      <input
        type="text"
        value={currentIdea}
        onChange={(e) => setCurrentIdea(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder={t('ideaPlaceholder')}
        className="flex-grow bg-white dark:bg-[#10151b] border-2 border-slate-300 dark:border-[#7c4dff]/50 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:focus:ring-[#7c4dff] focus:border-indigo-500 dark:focus:border-[#7c4dff] transition-all duration-300 placeholder:text-slate-400 dark:placeholder:text-[#90a4ae]/50 text-slate-800 dark:text-white"
      />
      <button
        onClick={onAddIdea}
        disabled={!currentIdea.trim()}
        className="bg-indigo-500 dark:bg-[#7c4dff] text-white p-3 rounded-md flex items-center justify-center hover:bg-indigo-600 dark:hover:bg-[#8e24aa] disabled:bg-slate-400 dark:disabled:bg-gray-600 disabled:cursor-not-allowed transition-all duration-300 shadow-lg shadow-indigo-500/30 dark:shadow-[0_0_10px_rgba(124,77,255,0.5)] hover:shadow-xl hover:shadow-indigo-500/40 dark:hover:shadow-[0_0_15px_rgba(142,36,170,0.7)]"
        aria-label={t('addIdea')}
      >
        <Plus size={24} />
      </button>
    </div>
  );
});

interface IdeasListProps {
  ideas: Idea[];
  onRemoveIdea: (id: string) => void;
}
const IdeasList: React.FC<IdeasListProps> = React.memo(({ ideas, onRemoveIdea }) => {
  const { t } = useTranslations();
  return (
    <div className="space-y-3 mt-4 pr-2 max-h-60 overflow-y-auto">
      {ideas.map((idea, index) => (
        <div key={idea.id} className="bg-slate-100/50 dark:bg-[#10151b]/50 p-3 rounded-md flex justify-between items-center border border-transparent hover:border-sky-400/50 dark:hover:border-[#00f0ff]/30 transition-colors duration-300 animate-fade-in" style={{ animationDelay: `${index * 50}ms` }}>
          <span className="text-slate-700 dark:text-[#e0f7fa]">{idea.text}</span>
          <button
            onClick={() => onRemoveIdea(idea.id)}
            className="text-red-500 dark:text-red-400 hover:text-red-600 dark:hover:text-red-300 p-1 rounded-full hover:bg-red-500/10 dark:hover:bg-red-500/20 transition-all duration-200"
            aria-label={t('removeIdea', { idea: idea.text })}
          >
            <Trash2 size={16} />
          </button>
        </div>
      ))}
    </div>
  );
});

interface PurposeSelectorProps {
  purpose: string;
  setPurpose: (value: string) => void;
}
const PurposeSelector: React.FC<PurposeSelectorProps> = React.memo(({ purpose, setPurpose }) => {
  const { t } = useTranslations();
  const purposes = Object.keys(purposeKeys);

  return (
    <div className="mt-6">
      <label htmlFor="purpose-input" className="block text-lg font-medium text-sky-500 dark:text-[#00f0ff] mb-3 light-shadow-sky dark:neon-glow-cyan">{t('purposeLabel')}</label>
      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 mb-4">
        {purposes.map(p => (
          <button
            key={p}
            onClick={() => setPurpose(p)}
            className={`p-2 rounded-md text-sm font-medium border-2 transition-all duration-200 ${purpose === p
                ? 'bg-emerald-500/20 dark:bg-[#00e676]/20 border-emerald-500 dark:border-[#00e676] text-emerald-700 dark:text-white scale-105'
                : 'bg-slate-100 dark:bg-[#10151b]/50 border-transparent hover:border-emerald-500/50 dark:hover:border-[#00e676]/50 text-slate-600 dark:text-slate-300'
              }`}
          >
            {t(purposeKeys[p])}
          </button>
        ))}
      </div>
      <input
        id="purpose-input"
        type="text"
        value={purpose}
        onChange={(e) => setPurpose(e.target.value)}
        list="purposes-list"
        placeholder={t('customPurposePlaceholder')}
        className="w-full bg-white dark:bg-[#10151b] border-2 border-emerald-500/50 dark:border-[#00e676]/30 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-emerald-500 dark:focus:ring-[#00e676] focus:border-emerald-500 dark:focus:border-[#00e676] transition-all duration-300 placeholder:text-slate-400 dark:placeholder:text-[#90a4ae]/50 text-emerald-600 dark:text-[#00e676] font-semibold"
      />
      <datalist id="purposes-list">
        {purposes.map(p => <option key={p} value={p} />)}
      </datalist>
    </div>
  );
});

interface PromptHistoryProps {
  history: HistoryItem[];
  onLoad: (item: HistoryItem) => void;
  onDelete: (id: string) => void;
  onClear: () => void;
}
const PromptHistoryDisplay: React.FC<PromptHistoryProps> = React.memo(({ history, onLoad, onDelete, onClear }) => {
  const { t, language } = useTranslations();
  return (
    <div className="lg:col-span-2 bg-white/60 dark:bg-[#10151b]/30 p-6 rounded-lg border-2 border-slate-200 dark:border-sky-500/30 backdrop-blur-sm shadow-2xl shadow-slate-500/10">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-2xl font-bold font-orbitron text-sky-600 dark:text-sky-400 tracking-wider">{t('historyTitle')}</h3>
        {history.length > 0 && (
          <button
            onClick={onClear}
            className="flex items-center gap-2 px-3 py-1 text-sm bg-red-500/10 dark:bg-red-500/20 text-red-600 dark:text-red-300 rounded-full hover:bg-red-500/20 dark:hover:bg-red-500/30 transition-colors duration-200"
            aria-label={t('clearAll')}
          >
            <XCircle size={16} />
            <span>{t('clearAll')}</span>
          </button>
        )}
      </div>
      <div className="max-h-96 overflow-y-auto pr-2 space-y-3">
        {history.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-40 text-slate-400 dark:text-[#90a4ae]/50">
            <History size={48} className="mb-4" />
            <p className="font-semibold text-center">{t('historyPlaceholder')}</p>
          </div>
        ) : (
          history.map(item => (
            <div key={item.id} className="bg-slate-100/50 dark:bg-[#10151b]/50 p-3 rounded-md flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3 border border-transparent hover:border-sky-400/50 dark:hover:border-sky-500/50 transition-colors duration-300">
              <div className="flex-grow overflow-hidden">
                <div className="flex items-center gap-2 mb-1 flex-wrap">
                  <span className="px-2 py-0.5 text-xs font-bold text-white dark:text-black rounded-full bg-sky-500 dark:bg-sky-400 flex-shrink-0">{item.purpose}</span>
                  <span className="text-xs text-slate-500 dark:text-[#90a4ae] truncate">{formatRelativeTime(item.timestamp, language)}</span>
                </div>
                <p className="text-sm text-slate-700 dark:text-[#e0f7fa] line-clamp-2">
                  {item.prompt}
                </p>
              </div>
              <div className="flex items-center gap-2 self-end sm:self-center flex-shrink-0">
                <button
                  onClick={() => onLoad(item)}
                  className="p-2 rounded-md bg-indigo-500/10 dark:bg-indigo-400/20 text-indigo-600 dark:text-indigo-300 hover:bg-indigo-500/20 dark:hover:bg-indigo-400/30 transition-colors duration-200"
                  aria-label={t('loadPrompt')}
                >
                  <Eye size={18} />
                </button>
                <button
                  onClick={() => onDelete(item.id)}
                  className="p-2 rounded-md bg-red-500/10 dark:bg-red-400/20 text-red-600 dark:text-red-300 hover:bg-red-500/20 dark:hover:bg-red-400/30 transition-colors duration-200"
                  aria-label={t('deletePrompt')}
                >
                  <Trash2 size={18} />
                </button>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
});

// --- Main Component ---

const PromptCrafter: React.FC = () => {
  const { t } = useTranslations();
  const [ideas, setIdeas] = useState<Idea[]>([]);
  const [currentIdea, setCurrentIdea] = useState('');
  const [purpose, setPurpose] = useState('Code Generation');
  const [isLoading, setIsLoading] = useState(false);
  const [generatedPrompt, setGeneratedPrompt] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isCopied, setIsCopied] = useState(false);
  const [isLinkCopied, setIsLinkCopied] = useState(false);
  const [promptHistory, setPromptHistory] = useState<HistoryItem[]>([]);
  const [viewMode, setViewMode] = useState<'preview' | 'raw'>('preview');
  const [tokenUsage, setTokenUsage] = useState<{ input: number; output: number; } | null>(null);
  const isInitialLoad = useRef(true);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Load history from localStorage
  useEffect(() => {
    try {
      const storedHistory = localStorage.getItem('promptHistory');
      if (storedHistory) {
        setPromptHistory(JSON.parse(storedHistory));
      }
    } catch (error) {
      console.error("Failed to load history from localStorage", error);
      setPromptHistory([]);
    }
  }, []);

  // Save history to localStorage
  useEffect(() => {
    if (promptHistory.length === 0 && localStorage.getItem('promptHistory') === null) {
      return;
    }
    try {
      localStorage.setItem('promptHistory', JSON.stringify(promptHistory));
    } catch (error) {
      console.error("Failed to save history to localStorage", error);
    }
  }, [promptHistory]);

  // Load shared prompt from URL hash on initial load
  useEffect(() => {
    const loadSharedPrompt = () => {
      try {
        const hash = window.location.hash;
        if (hash.startsWith('#prompt=')) {
          const encodedData = hash.substring('#prompt='.length);
          const decodedJson = atob(encodedData);
          const data = JSON.parse(decodedJson) as { ideas: Idea[], purpose: string, prompt: string };

          if (data.ideas && data.purpose && data.prompt) {
            setIdeas(data.ideas);
            setPurpose(data.purpose);
            setGeneratedPrompt(data.prompt);
            setTokenUsage(null); // Tokens are not shared in link
            setError(null);
            window.history.replaceState(null, document.title, window.location.pathname + window.location.search);
          }
        }
      } catch (e) {
        console.error("Failed to parse shared prompt from URL", e);
        setError("The shared link appears to be invalid or corrupted.");
        window.history.replaceState(null, document.title, window.location.pathname + window.location.search);
      }
    };
    loadSharedPrompt();
  }, []);

  // Autosave: Load draft from IndexedDB on mount
  useEffect(() => {
    const loadDraft = async () => {
      try {
        const savedDraft = await getDraft<Draft>('currentDraft');
        if (savedDraft) {
          setIdeas(savedDraft.ideas);
          setPurpose(savedDraft.purpose);
        }
      } catch (e) {
        console.error("Failed to load draft from IndexedDB", e);
      } finally {
        isInitialLoad.current = false;
      }
    };
    loadDraft();
  }, []);

  // Autosave: Save draft to IndexedDB on changes
  useEffect(() => {
    if (isInitialLoad.current) {
      return;
    }
    const handler = setTimeout(() => {
      try {
        setDraft('currentDraft', { ideas, purpose });
      } catch (e) {
        console.error("Failed to save draft to IndexedDB", e);
      }
    }, 500);
    return () => clearTimeout(handler);
  }, [ideas, purpose]);

  // Auto-resize textarea
  useEffect(() => {
    if (viewMode === 'raw' && textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      const scrollHeight = textareaRef.current.scrollHeight;
      textareaRef.current.style.height = `${scrollHeight}px`;
    }
  }, [generatedPrompt, viewMode]);


  const handleAddIdea = useCallback(() => {
    if (currentIdea.trim() !== '') {
      setIdeas(prev => [...prev, { id: Date.now().toString(), text: currentIdea.trim() }]);
      setCurrentIdea('');
    }
  }, [currentIdea]);

  const handleRemoveIdea = useCallback((id: string) => {
    setIdeas(prev => prev.filter(idea => idea.id !== id));
  }, []);

  const handleGenerate = async () => {
    if (ideas.length === 0) {
      setError(t('errorAddIdea'));
      return;
    }
    if (!purpose.trim()) {
      setError(t('errorSpecifyPurpose'));
      return;
    }
    setError(null);
    setIsLoading(true);
    setGeneratedPrompt('');
    setTokenUsage(null);
    try {
      const result = await generateStructuredPrompt(ideas, purpose);
      setGeneratedPrompt(result.prompt);
      const inputTokens = result.usageMetadata?.promptTokenCount ?? 0;
      const outputTokens = result.usageMetadata?.candidatesTokenCount ?? 0;
      setTokenUsage({ input: inputTokens, output: outputTokens });

      const newItem: HistoryItem = {
        id: Date.now().toString(),
        prompt: result.prompt,
        purpose,
        ideas: [...ideas],
        timestamp: Date.now(),
        inputTokens,
        outputTokens,
      };
      setPromptHistory(prev => [newItem, ...prev].slice(0, 20));
    } catch (err: any) {
      setError(err.message || 'An unknown error occurred.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleCopy = () => {
    if (generatedPrompt) {
      navigator.clipboard.writeText(generatedPrompt);
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), 2000);
    }
  };

  const handleShare = () => {
    if (!generatedPrompt) return;
    try {
      const dataToShare = {
        ideas,
        purpose,
        prompt: generatedPrompt,
      };
      const jsonString = JSON.stringify(dataToShare);
      const encodedData = btoa(jsonString);
      const shareUrl = `${window.location.origin}${window.location.pathname}#prompt=${encodedData}`;

      navigator.clipboard.writeText(shareUrl);
      setIsLinkCopied(true);
      setTimeout(() => setIsLinkCopied(false), 2500);

    } catch (e) {
      console.error("Failed to create share link", e);
      setError("An unexpected error occurred while creating the shareable link.");
    }
  };

  const handleLoadExample = useCallback(() => {
    setError(null);
    setGeneratedPrompt('');
    setTokenUsage(null);
    const randomIndex = Math.floor(Math.random() * examples.length);
    const example = examples[randomIndex];
    setPurpose(example.purpose);
    const exampleIdeas: Idea[] = example.ideas.map((text, index) => ({
      id: `example-${Date.now()}-${index}`,
      text,
    }));
    setIdeas(exampleIdeas);
  }, []);

  const handleLoadFromHistory = useCallback((item: HistoryItem) => {
    setIdeas(item.ideas);
    setPurpose(item.purpose);
    setGeneratedPrompt(item.prompt);
    setTokenUsage(item.inputTokens && item.outputTokens ? { input: item.inputTokens, output: item.outputTokens } : null);
    setError(null);
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }, []);

  const handleDeleteFromHistory = useCallback((id: string) => {
    setPromptHistory(prev => prev.filter(item => item.id !== id));
  }, []);

  const handleClearHistory = useCallback(() => {
    setPromptHistory([]);
    localStorage.removeItem('promptHistory');
  }, []);

  return (
    <div className="grid lg:grid-cols-2 gap-8">
      {/* Input Section */}
      <div className="bg-white/60 dark:bg-[#10151b]/30 p-6 rounded-lg border-2 border-slate-200 dark:border-[#7c4dff]/30 backdrop-blur-sm shadow-2xl shadow-slate-500/10">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-2xl font-bold font-orbitron text-indigo-600 dark:text-[#7c4dff] tracking-wider">{t('inputIdeasTitle')}</h3>
          <button
            onClick={handleLoadExample}
            className="flex items-center gap-2 px-3 py-1 text-sm bg-slate-200/50 dark:bg-[#10151b] text-indigo-600 dark:text-[#7c4dff] rounded-full hover:bg-slate-300/50 dark:hover:bg-slate-800 transition-colors duration-200"
            aria-label={t('loadExample')}
          >
            <Lightbulb size={16} />
            <span>{t('loadExample')}</span>
          </button>
        </div>
        <IdeaInput currentIdea={currentIdea} setCurrentIdea={setCurrentIdea} onAddIdea={handleAddIdea} />
        <IdeasList ideas={ideas} onRemoveIdea={handleRemoveIdea} />
        <PurposeSelector purpose={purpose} setPurpose={setPurpose} />
      </div>

      {/* Output Section */}
      <div className="flex flex-col">
        <div className="bg-white/60 dark:bg-[#10151b]/30 p-6 rounded-lg border-2 border-slate-200 dark:border-[#00e676]/30 backdrop-blur-sm flex-grow flex flex-col shadow-2xl shadow-slate-500/10">
          <h3 className="text-2xl font-bold font-orbitron text-emerald-600 dark:text-[#00e676] tracking-wider mb-4 light-shadow-emerald dark:neon-glow-green">{t('generatedPromptTitle')}</h3>
          <div className="flex-grow bg-slate-100 dark:bg-[#0a0f14] rounded-md min-h-[300px] flex flex-col border border-slate-200 dark:border-transparent">
            <div className="relative flex-grow p-4 overflow-y-auto">
              {isLoading && (
                <div className="absolute inset-0 flex flex-col items-center justify-center bg-slate-100/80 dark:bg-[#0a0f14]/80 backdrop-blur-sm z-20">
                  <Loader className="animate-spin text-sky-500 dark:text-[#00f0ff]" size={48} />
                  <p className="mt-4 text-sky-500 dark:text-[#00f0ff] font-semibold">{t('generatingMessage')}</p>
                </div>
              )}
              {error && (
                <div className="absolute inset-0 flex flex-col items-center justify-center bg-slate-100/80 dark:bg-[#0a0f14]/80 backdrop-blur-sm p-4 z-20">
                  <div className="bg-red-100 dark:bg-red-900/50 border border-red-300 dark:border-red-500 text-red-700 dark:text-red-300 p-4 rounded-lg flex flex-col items-center gap-2 text-center shadow-lg">
                    <AlertTriangle size={32} />
                    <h4 className="font-bold">{t('generationFailedTitle')}</h4>
                    <p className="text-sm">{error}</p>
                    <button onClick={() => setError(null)} className="mt-2 bg-red-500/20 dark:bg-red-500/50 hover:bg-red-500/30 dark:hover:bg-red-500/80 text-red-800 dark:text-white px-3 py-1 text-sm rounded-md flex items-center gap-1">
                      <X size={14} /> {t('close')}
                    </button>
                  </div>
                </div>
              )}
              {generatedPrompt && !isLoading && !error && (
                <>
                  <div className="absolute top-2 right-2 flex gap-2 z-10">
                    <button onClick={() => setViewMode(viewMode === 'raw' ? 'preview' : 'raw')} className="bg-white dark:bg-[#10151b] p-2 rounded-md text-sky-500 dark:text-[#00f0ff] hover:bg-sky-100 dark:hover:bg-[#00f0ff] hover:text-sky-600 dark:hover:text-black transition-all duration-200" aria-label={t('toggleView')}>
                      {viewMode === 'raw' ? <Eye size={20} /> : <Code size={20} />}
                    </button>
                    <button onClick={handleShare} className="bg-white dark:bg-[#10151b] p-2 rounded-md text-sky-500 dark:text-[#00f0ff] hover:bg-sky-100 dark:hover:bg-[#00f0ff] hover:text-sky-600 dark:hover:text-black transition-all duration-200" aria-label={t('copyLink')}>
                      {isLinkCopied ? <ClipboardCheck size={20} /> : <Share2 size={20} />}
                    </button>
                    <button onClick={handleCopy} className="bg-white dark:bg-[#10151b] p-2 rounded-md text-sky-500 dark:text-[#00f0ff] hover:bg-sky-100 dark:hover:bg-[#00f0ff] hover:text-sky-600 dark:hover:text-black transition-all duration-200" aria-label={t('copyPrompt')}>
                      {isCopied ? <ClipboardCheck size={20} /> : <Clipboard size={20} />}
                    </button>
                  </div>
                  {viewMode === 'preview' ? (
                    <div className="prose prose-sm max-w-none text-slate-800 dark:text-[#e0f7fa] dark:prose-invert prose-headings:font-orbitron prose-code:font-plex-mono prose-code:bg-slate-200 dark:prose-code:bg-[#10151b] prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded-md prose-pre:bg-slate-200 dark:prose-pre:bg-[#10151b]">
                      <ReactMarkdown remarkPlugins={[remarkGfm]}>{generatedPrompt}</ReactMarkdown>
                    </div>
                  ) : (
                    <textarea
                      title={`(t('${generatedPrompt}'))`}
                      ref={textareaRef}
                      readOnly
                      value={generatedPrompt}
                      className="w-full h-auto bg-transparent resize-none border-none focus:ring-0 p-0 m-0 font-plex-mono text-sm leading-relaxed text-slate-800 dark:text-[#e0f7fa] overflow-hidden"
                      rows={1}
                    />
                  )}
                </>
              )}
              {!generatedPrompt && !isLoading && !error && (
                <div className="flex flex-col items-center justify-center h-full text-slate-400 dark:text-[#90a4ae]/50">
                  <Wand2 size={48} className="mb-4" />
                  <p className="font-semibold text-center">{t('promptPlaceholder')}</p>
                </div>
              )}
            </div>
            {tokenUsage && (
              <div className="flex-shrink-0 bg-slate-200/50 dark:bg-[#10151b]/50 p-2 border-t border-slate-200 dark:border-slate-700/50">
                <div className="flex items-center justify-center gap-4 text-xs text-slate-600 dark:text-slate-400 font-semibold">
                  <BrainCircuit size={16} className="text-sky-500 dark:text-sky-400" />
                  <span>{t('input')}: <span className="font-bold text-sky-600 dark:text-sky-300">{tokenUsage.input}</span> {t('tokens')}</span>
                  <span className="text-slate-300 dark:text-slate-600">|</span>
                  <span>{t('output')}: <span className="font-bold text-emerald-600 dark:text-emerald-300">{tokenUsage.output}</span> {t('tokens')}</span>
                  <span className="text-slate-300 dark:text-slate-600">|</span>
                  <span>{t('total')}: <span className="font-bold text-indigo-600 dark:text-indigo-300">{tokenUsage.input + tokenUsage.output}</span> {t('tokens')}</span>
                </div>
              </div>
            )}
          </div>
          <button
            onClick={handleGenerate}
            disabled={isLoading || ideas.length === 0 || !purpose.trim()}
            className="w-full mt-6 bg-gradient-to-r from-emerald-500 to-sky-500 dark:from-[#00e676] dark:to-[#00f0ff] text-white dark:text-black font-bold font-orbitron text-lg p-4 rounded-lg flex items-center justify-center gap-3 hover:scale-105 disabled:scale-100 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300 shadow-lg shadow-sky-500/40 dark:shadow-[0_0_15px_rgba(0,230,118,0.5)] hover:shadow-xl hover:shadow-sky-500/50 dark:hover:shadow-[0_0_25px_rgba(0,240,255,0.7)]"
          >
            {isLoading ? <Loader className="animate-spin" size={28} /> : <Wand2 size={28} />}
            {isLoading ? t('generatingButton') : t('generateButton')}
          </button>
        </div>
      </div>

      {/* Prompt History Section */}
      <PromptHistoryDisplay
        history={promptHistory}
        onLoad={handleLoadFromHistory}
        onDelete={handleDeleteFromHistory}
        onClear={handleClearHistory}
      />
    </div>
  );
};

export default PromptCrafter;

/// docs/ASSETS_CHECKLIST.md ///
# Assets Checklist for Kubex.world

This document lists all the assets needed for the complete Grompt v2.0 deployment.

## Required Icons & Images

### ‚úÖ Already Referenced (Need to Create/Update)

```
/assets/
‚îú‚îÄ‚îÄ favicon.ico                     # Browser favicon
‚îú‚îÄ‚îÄ apple-touch-icon.png           # iOS home screen icon (180x180)
‚îú‚îÄ‚îÄ safari-pinned-tab.svg          # Safari pinned tab icon
‚îú‚îÄ‚îÄ kubex_og.png                   # Open Graph/Social media image
‚îî‚îÄ‚îÄ icons/
    ‚îú‚îÄ‚îÄ favicon.svg                # SVG favicon
    ‚îú‚îÄ‚îÄ android-chrome-192x192.png # Android Chrome icon
    ‚îî‚îÄ‚îÄ android-chrome-512x512.png # Android Chrome icon
```

## Icon Specifications

### Favicon Package

- **favicon.ico**: 16x16, 32x32, 48x48 (multi-size ICO)
- **favicon.svg**: Vector favicon (dark/light mode compatible)

### Mobile Icons

- **apple-touch-icon.png**: 180x180 PNG for iOS
- **android-chrome-192x192.png**: 192x192 PNG for Android
- **android-chrome-512x512.png**: 512x512 PNG for Android

### Safari

- **safari-pinned-tab.svg**: Monochrome SVG, color: #00f0ff

### Social Media

- **kubex_og.png**: 1200x630 PNG for Open Graph/Twitter Cards

## Design Guidelines

### Colors

- **Primary**: #00f0ff (Kubex cyan)
- **Secondary**: #00e676 (Kubex green)
- **Dark Background**: #0a0f14
- **Light Background**: #f9fafb

### Style

- **Minimalist**: Clean, geometric design
- **Hexagonal Theme**: Following Kubex hexagon logo pattern
- **High Contrast**: Works on both light and dark backgrounds
- **Scalable**: Vector-based when possible

## Logo Concept

Based on the Kubex logo (hexagon with circuit-like patterns), the Grompt icon should:

1. **Maintain Kubex Identity**: Use the hexagonal shape
2. **Add Prompt Context**: Include elements suggesting text/AI (maybe stylized "G" or chat bubble)
3. **Circuit Aesthetics**: Keep the tech/circuit theme
4. **Glow Effects**: Neon glow for dark mode

## Current Status

### ‚ùå Missing Files

These files are referenced but don't exist yet:

- [ ] `/assets/favicon.ico`
- [ ] `/assets/apple-touch-icon.png`
- [ ] `/assets/safari-pinned-tab.svg`
- [ ] `/assets/kubex_og.png`
- [ ] `/assets/icons/favicon.svg`
- [ ] `/assets/icons/android-chrome-192x192.png`
- [ ] `/assets/icons/android-chrome-512x512.png`

### üìù Creation Tools Suggested

- **Vector Design**: Figma, Adobe Illustrator, or Inkscape
- **PNG Export**: Export from vector at proper resolutions
- **ICO Creation**: Use online ICO generator or ImageMagick
- **Optimization**: TinyPNG for file size optimization

### üé® Design Priority

1. **Create base SVG logo first** (favicon.svg)
2. **Export PNG versions** at required sizes
3. **Generate ICO file** from PNG versions
4. **Create social media banner** (kubex_og.png)

### üöÄ Quick Win

For immediate deployment, you could:

1. Use a simple geometric "G" in a hexagon
2. Apply Kubex color scheme (#00f0ff)
3. Export at all required sizes
4. Test on different devices/browsers

## SEO Impact

Having proper icons improves:

- **User Trust**: Professional appearance
- **Brand Recognition**: Consistent visual identity
- **Mobile Experience**: Proper home screen icons
- **Social Sharing**: Rich previews with custom images

---

**Note**: These assets are crucial for the professional launch at kubex.world. The current deployment will work but may show default browser icons until these are created.

/// docs/DEPLOYMENT.md ///
# Deployment Guide for Grompt v2.0

## Quick Deployment Checklist

### ‚úÖ Ready for Production

- [x] Build passes without errors
- [x] Demo mode works without API key
- [x] User API key input functional
- [x] Multi-language support
- [x] SEO optimization complete
- [x] PWA manifest configured
- [x] Security headers configured

### üöÄ Vercel Deployment

1. **Environment Variables** (Optional - app works without these):

   ```bash
   GEMINI_API_KEY=your_server_side_key_optional
   ```

2. **Build Command**:

   ```bash
   npm run build
   ```

3. **Output Directory**:

   ```
   dist
   ```

4. **Framework Preset**:

   ```
   Vite
   ```

### üåê Domain Configuration

- **Primary**: `kubex.world/grompt` or subdomain
- **Redirects**: Consider `grompt.kubex.world` ‚Üí `kubex.world/grompt`
- **HTTPS**: Ensure SSL/TLS certificate
- **CDN**: Vercel handles this automatically

### üìä Post-Deployment Verification

1. **Functionality Check**:
   - [ ] App loads without errors
   - [ ] Demo mode generates prompts
   - [ ] User can input API key
   - [ ] Theme switching works
   - [ ] Language switching works
   - [ ] Mobile responsive
   - [ ] PWA installable

2. **SEO Check**:
   - [ ] Meta tags appear correctly
   - [ ] Open Graph preview works
   - [ ] Twitter Card preview works
   - [ ] Sitemap accessible at `/sitemap.xml`
   - [ ] Robots.txt accessible at `/robots.txt`

3. **Performance Check**:
   - [ ] Lighthouse score > 90
   - [ ] First Contentful Paint < 2s
   - [ ] Largest Contentful Paint < 4s
   - [ ] Bundle size reasonable

### üîß Optional Optimizations

#### Analytics Integration

```typescript
// Replace console.log in analytics.ts with:
fetch('https://your-analytics-endpoint.com/track', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data)
});
```

#### API Key Management

For advanced deployments, consider:

- Server-side API key rotation
- Usage analytics
- Rate limiting per user

#### Error Monitoring

Consider integrating:

- Sentry for error tracking
- LogRocket for session replay
- Hotjar for user behavior

### üéØ Launch Strategy

#### Soft Launch

1. Deploy to staging subdomain first
2. Test with small user group
3. Monitor error rates and performance
4. Gather initial feedback

#### Public Launch

1. Deploy to production domain
2. Update DNS if needed
3. Submit to search engines
4. Share on social media
5. Update GitHub repository

### üìà Success Metrics

#### Technical KPIs

- **Uptime**: > 99.9%
- **Load Time**: < 3s average
- **Error Rate**: < 0.1%
- **Bundle Size**: < 2MB total

#### User Experience KPIs

- **Demo Mode Usage**: Track demo vs API usage
- **Language Preferences**: Monitor popular languages
- **Feature Usage**: Track most used prompt types
- **Session Duration**: Engagement metrics

### üõ°Ô∏è Security Considerations

#### Headers Configuration

```
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' https://esm.sh; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
Referrer-Policy: strict-origin-when-cross-origin
```

#### API Key Security

- Never log API keys server-side
- Validate API key format before storage
- Clear API keys on logout/session end
- Warn users about key security

### üêõ Common Issues & Solutions

#### White Screen

- **Cause**: Missing CDN resources
- **Solution**: Check importmap URLs in index.html

#### API Key Not Working

- **Cause**: Invalid key format or expired key
- **Solution**: Validate key format, provide error messages

#### PWA Not Installing

- **Cause**: Missing manifest properties
- **Solution**: Verify manifest.json structure

#### SEO Issues

- **Cause**: Missing meta tags
- **Solution**: Check index.html meta tags

### üîÑ Rollback Plan

If deployment issues occur:

1. **Immediate**: Revert to previous Vercel deployment
2. **DNS**: Update DNS to point to backup domain
3. **Communication**: Update status page/social media
4. **Investigation**: Check error logs and metrics

---

## Ready for Launch! üöÄ

The Grompt v2.0 codebase is production-ready and follows all Kubex principles:

- ‚úÖ **Radical Simplicity**: Works immediately without configuration
- ‚úÖ **Modularity**: Clean, reusable components
- ‚úÖ **No Cages**: No vendor lock-in, open standards

**Deploy with confidence to kubex.world!**

/// docs/ENVIRONMENT_VARIABLES.md ///
# Environment Variables Documentation

Grompt v2.0 supports multiple environment variables for flexible configuration across different deployment scenarios.

## Core Application Settings

| Variable | Default | Description |
|----------|---------|-------------|
| `PORT` | `3000` | Server port for development |
| `NODE_ENV` | `development` | Application environment |
| `DEBUG` | `false` | Enable debug logging |
| `TEST_MODE` | `false` | Enable test mode features |
| `LOG_LEVEL` | `info` | Logging level (error, warn, info, debug) |

## AI Model Providers

### Google Gemini (Primary)

| Variable | Description |
|----------|-------------|
| `GEMINI_API_KEY` | Google Gemini API key for prompt generation |
| `GRT_API_KEY` | Alternative Gemini API key variable |

### OpenAI

| Variable | Description |
|----------|-------------|
| `OPENAI_API_KEY` | OpenAI GPT API key |
| `CHATGPT_API_KEY` | Alternative OpenAI API key variable |

### Other AI Providers

| Variable | Description |
|----------|-------------|
| `ANTHROPIC_API_KEY` | Anthropic Claude API key |
| `DEEPSEEK_API_KEY` | DeepSeek AI API key |
| `OLLAMA_API_KEY` | Ollama local AI API key |
| `OLLAMA_API_URL` | Ollama server URL |

## Security & Rate Limiting

| Variable | Default | Description |
|----------|---------|-------------|
| `SECURITY_ENABLED` | `true` | Enable security features |
| `RATE_LIMIT` | `100` | Rate limit per window |
| `RATE_LIMIT_WINDOW` | `1m` | Rate limit window duration |
| `MAX_RETRIES` | `3` | Maximum API retry attempts |
| `RETRY_DELAY_MS` | `1000` | Delay between retries |

## Future Database Support (Planned)

### PostgreSQL

| Variable | Description |
|----------|-------------|
| `POSTGRES_HOST` | PostgreSQL server host |
| `POSTGRES_PORT` | PostgreSQL server port |
| `POSTGRES_USER` | Database username |
| `POSTGRES_PASSWORD` | Database password |
| `POSTGRES_DB` | Database name |
| `POSTGRES_SSL` | Enable SSL connection |
| `POSTGRES_MAX_CLIENTS` | Maximum connection pool size |

### Redis

| Variable | Description |
|----------|-------------|
| `REDIS_HOST` | Redis server host |
| `REDIS_PORT` | Redis server port |
| `REDIS_PASSWORD` | Redis authentication password |
| `REDIS_SENTINEL_ENABLED` | Enable Redis Sentinel |
| `REDIS_SENTINEL_HOST` | Sentinel server host |
| `REDIS_SENTINEL_PORT` | Sentinel server port |
| `REDIS_SENTINEL_MASTER_NAME` | Sentinel master name |

### MongoDB

| Variable | Description |
|----------|-------------|
| `MONGODB_URI` | Complete MongoDB connection string |
| `MONGODB_DB` | MongoDB database name |
| `MONGODB_USER` | MongoDB username |
| `MONGODB_PASSWORD` | MongoDB password |
| `MONGODB_AUTH_SOURCE` | Authentication database |
| `MONGODB_SSL` | Enable SSL connection |
| `MONGODB_REPLICA_SET` | Replica set name |
| `MONGODB_MAX_POOL_SIZE` | Maximum connection pool size |
| `MONGODB_MIN_POOL_SIZE` | Minimum connection pool size |
| `MONGODB_CONNECT_TIMEOUT_MS` | Connection timeout |

### RabbitMQ

| Variable | Description |
|----------|-------------|
| `RABBITMQ_HOST` | RabbitMQ server host |
| `RABBITMQ_PORT` | RabbitMQ server port |
| `RABBITMQ_USER` | RabbitMQ username |
| `RABBITMQ_PASSWORD` | RabbitMQ password |
| `RABBITMQ_VHOST` | Virtual host |
| `RABBITMQ_QUEUE_NAME` | Default queue name |
| `RABBITMQ_QUEUE_DURABLE` | Queue durability |
| `RABBITMQ_QUEUE_AUTO_DELETE` | Auto-delete queue |

## Usage Examples

### Development

```bash
# Minimal setup for development
GEMINI_API_KEY=your_key_here
DEBUG=true
LOG_LEVEL=debug
```

### Production

```bash
# Production setup with rate limiting
GEMINI_API_KEY=your_production_key
NODE_ENV=production
SECURITY_ENABLED=true
RATE_LIMIT=50
RATE_LIMIT_WINDOW=1m
LOG_LEVEL=warn
```

### Multi-Provider Setup

```bash
# Support multiple AI providers
GEMINI_API_KEY=gemini_key
OPENAI_API_KEY=openai_key
ANTHROPIC_API_KEY=claude_key
OLLAMA_API_URL=http://localhost:11434
```

## Security Notes

‚ö†Ô∏è **Never commit API keys to version control**

- Use `.env.local` for local development
- Use secure environment variable management in production
- API keys are only used server-side, never exposed to frontend
- User-provided API keys are stored only in localStorage (client-side)

## Kubex Principles Applied

- **Radical Simplicity**: One variable = one function
- **Modularity**: Variables grouped by logical domains
- **No Cages**: Support for multiple providers, no vendor lock-in

/// index.css ///
/*
 * Global styles
 */

/// index.html ///
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta charset="UTF-8" />

    <!-- Enhanced SEO & Branding for Kubex.world -->
    <title>Grompt: AI Prompt Crafter | Kubex ‚Äî Code Fast. Own Everything.</title>
    <meta name="description"
      content="Grompt: Transform raw ideas into professional AI prompts. Part of Kubex Ecosystem ‚Äî modular, open-source, AI-powered tools for Devs, Ops & Builders. No lock-in. No excuses." />
    <meta name="keywords"
      content="AI prompts, prompt engineering, Kubex, open source, no lock-in, modular tools, AI development" />
    <meta name="author" content="Kubex Ecosystem" />

    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Grompt: AI Prompt Crafter | Kubex ‚Äî Code Fast. Own Everything." />
    <meta property="og:description"
      content="Transform raw ideas into professional AI prompts. Democratizing modular, accessible and powerful tech. From old laptops to enterprise clusters." />
    <meta property="og:url" content="https://kubex.world/grompt" />
    <meta property="og:image" content="https://kubex.world/assets/kubex_og.png" />
    <meta property="og:site_name" content="Kubex Ecosystem" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Grompt: AI Prompt Crafter | Kubex Ecosystem" />
    <meta name="twitter:description"
      content="AI-powered prompt engineering tool. Open-source ecosystem. No lock-in. No excuses." />
    <meta name="twitter:image" content="https://kubex.world/assets/kubex_og.png" />

    <!-- Favicons & App Icons -->
    <link rel="icon" href="/assets/favicon.ico" />
    <link rel="icon" type="image/svg+xml" href="/assets/icons/favicon.svg" />
    <link rel="apple-touch-icon" href="/assets/apple-touch-icon.png" />
    <link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#00f0ff" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Viewport & PWA -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#0a0f14" id="theme-color-meta">
    <script>
      // Configure Tailwind CSS to use class-based dark mode
      tailwind = {
        config: {
          darkMode: 'class',
        }
      }

      // Detect browsers that don't support theme-color
      function isThemeColorSupported() {
        const userAgent = navigator.userAgent.toLowerCase();
        const isFirefox = userAgent.includes('firefox');
        const isOpera = userAgent.includes('opera') || userAgent.includes('opr');
        return !(isFirefox || isOpera);
      }

      // Update theme color meta tag based on theme
      function updateThemeColor(theme) {
        const metaThemeColor = document.getElementById('theme-color-meta');
        if (metaThemeColor) {
          metaThemeColor.setAttribute('content', theme === 'dark' ? '#0a0f14' : '#f9fafb');
        }

        // Apply visual fallback for unsupported browsers
        if (!isThemeColorSupported()) {
          const fallbackStyle = document.getElementById('theme-color-fallback') || document.createElement('style');
          if (!fallbackStyle.id) {
            fallbackStyle.id = 'theme-color-fallback';
            document.head.appendChild(fallbackStyle);
          }

          const color = theme === 'dark' ? '#0a0f14' : '#f9fafb';
          fallbackStyle.textContent = `
            /* Theme color fallback for unsupported browsers */
            html { border-top: 4px solid ${color}; }
            body::before {
              content: '';
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 4px;
              background: ${color};
              z-index: 9999;
              pointer-events: none;
            }
          `;
        }
      }

      // Initialize theme color on page load
      document.addEventListener('DOMContentLoaded', function () {
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
        updateThemeColor(initialTheme);

        // Listen for theme changes
        const observer = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              const isDark = document.documentElement.classList.contains('dark');
              updateThemeColor(isDark ? 'dark' : 'light');
            }
          });
        });

        observer.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ['class']
        });
      });
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet">
    <style>
      body {
        font-family: 'IBM Plex Mono', monospace;
        transition: background-color 0.3s ease-in-out;
      }

      body.dark-theme {
        background-color: #0a0f14;
        background-image:
          radial-gradient(circle at 25px 25px, rgba(0, 240, 255, 0.1) 2%, transparent 0%),
          radial-gradient(circle at 75px 75px, rgba(0, 240, 255, 0.05) 2%, transparent 0%);
        background-size: 100px 100px;
      }

      body.light-theme {
        background-color: #f9fafb;
        background-image:
          radial-gradient(circle at 25px 25px, rgba(0, 0, 0, 0.03) 2%, transparent 0%),
          radial-gradient(circle at 75px 75px, rgba(0, 0, 0, 0.02) 2%, transparent 0%);
        background-size: 100px 100px;
      }

      .font-orbitron {
        font-family: 'Orbitron', sans-serif;
      }

      .font-plex-mono {
        font-family: 'IBM Plex Mono', monospace;
      }

      .neon-glow-cyan {
        text-shadow: 0 0 5px rgba(0, 240, 255, 0.7), 0 0 10px rgba(0, 240, 255, 0.5), 0 0 15px rgba(0, 240, 255, 0.3);
      }

      .light-shadow-sky {
        text-shadow: 0 0 8px rgba(14, 165, 233, 0.4);
      }

      .neon-glow-green {
        text-shadow: 0 0 5px rgba(0, 230, 118, 0.7), 0 0 10px rgba(0, 230, 118, 0.5), 0 0 15px rgba(0, 230, 118, 0.3);
      }

      .light-shadow-emerald {
        text-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
      }

      .neon-border-cyan {
        box-shadow: 0 0 2px #fff, 0 0 4px #fff, 0 0 6px #00f0ff, 0 0 10px #00f0ff, 0 0 12px #00f0ff, 0 0 15px #00f0ff, 0 0 20px #00f0ff;
      }

      .line-clamp-2 {
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
      }
    </style>
    <script type="importmap">
{
  "imports": {
    "react/": "https://esm.sh/react@^19.1.1/",
    "react": "https://esm.sh/react@^19.1.1",
    "react-dom/": "https://esm.sh/react-dom@^19.1.1/",
    "react-dom/client": "https://esm.sh/react-dom@^19.1.1/client",
    "@google/genai": "https://esm.sh/@google/genai@^1.17.0",
    "lucide-react": "https://esm.sh/lucide-react@^0.542.0",
    "react-markdown": "https://esm.sh/react-markdown@9.0.1",
    "remark-gfm": "https://esm.sh/remark-gfm@4.0.0",
    "react-syntax-highlighter": "https://esm.sh/react-syntax-highlighter@15.5.0",
    "react-syntax-highlighter/dist/esm/styles/prism": "https://esm.sh/react-syntax-highlighter@15.5.0/dist/esm/styles/prism"
  }
}
</script>
    <link rel="stylesheet" href="/index.css">
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>

</html>

/// index.tsx ///
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './src/App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

// Register Service Worker for PWA offline functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js').then(registration => {
      console.log('ServiceWorker registration successful with scope: ', registration.scope);
    }).catch(error => {
      console.log('ServiceWorker registration failed: ', error);
    });
  });
}


const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

/// manifest.json ///
{
  "short_name": "Grompt",
  "name": "Grompt: AI Prompt Crafter | Kubex",
  "description": "Transform raw ideas into professional AI prompts. Part of Kubex Ecosystem ‚Äî modular, open-source, AI-powered tools following principles of radical simplicity and no lock-in.",
  "icons": [
    {
      "src": "/assets/favicon.ico",
      "sizes": "16x16 32x32 48x48",
      "type": "image/x-icon",
      "purpose": "any"
    },
    {
      "src": "/assets/icons/favicon.svg",
      "sizes": "any",
      "type": "image/svg+xml",
      "purpose": "any"
    },
    {
      "src": "/assets/apple-touch-icon.png",
      "sizes": "180x180",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/assets/icons/android-chrome-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/assets/icons/android-chrome-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    }
  ],
  "start_url": "/",
  "display": "standalone",
  "orientation": "portrait-primary",
  "theme_color": "#0a0f14",
  "background_color": "#0a0f14",
  "categories": [
    "productivity",
    "developer",
    "ai",
    "tools"
  ],
  "scope": "/",
  "lang": "en-US"
}

/// metadata.json ///
{
  "name": "Grompt",
  "description": "An AI-powered tool that transforms raw, unstructured ideas into professional, well-structured prompts for large language models, following the Kubex design principles.",
  "requestFramePermissions": []
}

/// package.json ///
{
  "name": "grompt",
  "private": false,
  "version": "2.0.0",
  "description": "AI prompt crafting tool that transforms raw ideas into professional prompts. Part of Kubex Ecosystem ‚Äî modular, open-source tools following principles of radical simplicity and no lock-in.",
  "keywords": [
    "ai",
    "prompts",
    "prompt-engineering",
    "kubex",
    "open-source",
    "no-lock-in",
    "modular",
    "react",
    "typescript"
  ],
  "markdown": "github",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kubex-ecosystem/grompt.git"
  },
  "author": "Rafael Mori <faelmori@live.com>",
  "license": "MIT",
  "homepage": "https://kubex.world/grompt",
  "readme": "https://github.com/kubex-ecosystem/grompt/README.md",
  "bugs": {
    "url": "https://github.com/kubex-ecosystem/grompt/issues"
  },
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "build:static": "vite build --mode production",
    "serve": "vite preview --port 4173 --host"
  },
  "dependencies": {
    "@google/genai": "^1.17.0",
    "lucide-react": "^0.542.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-markdown": "9.0.1",
    "react-syntax-highlighter": "^15.6.6",
    "remark-gfm": "4.0.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@types/react": "^19.1.12",
    "@types/react-dom": "^19.1.9",
    "@types/react-syntax-highlighter": "^15.5.13",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  },
  "browserslist": [
    "last 1 version",
    "> 1%",
    "maintained node versions",
    "not dead"
  ],
  "browser": {
    "fs": false,
    "path": false,
    "os": false,
    "child_process": false
  },
  "engines": {
    "node": ">=22"
  },
  "main": "src/index.tsx",
  "files": [
    "src",
    "services",
    "types.d.ts",
    "index.html",
    "index.css",
    "assets",
    "package.json",
    "README.md",
    "LICENSE"
  ]
}

/// public/.well-known/security.txt ///
Contact: mailto:faelmori@live.com
Contact: https://github.com/kubex-ecosystem/grompt/issues
Expires: 2026-09-08T00:00:00.000Z
Encryption: https://github.com/rafa-mori.gpg
Preferred-Languages: en, pt-BR
Canonical: https://kubex.world/.well-known/security.txt
Policy: https://kubex.world/security-policy
Acknowledgments: https://kubex.world/security-acknowledgments

# Kubex Ecosystem Security Policy
# We appreciate responsible disclosure of security vulnerabilities
# Please allow reasonable time for fixes before public disclosure

/// public/_document-head.html ///
<!-- Meta / Open Graph -->
<title>Kubex ‚Äî Code Fast. Own Everything.</title>
<meta name="description"
  content="Kubex Ecosystem ‚Äî modular, open-source, AI-powered tools for Devs, Ops & Builders. No lock-in. No excuses." />
<meta name="theme-color" content="#0a0f14" />

<meta property="og:type" content="website" />
<meta property="og:title" content="Kubex ‚Äî Code Fast. Own Everything." />
<meta property="og:description"
  content="Democratizing modular, accessible and powerful tech. From old laptops to enterprise clusters." />
<meta property="og:url" content="https://kubex.world/" />
<meta property="og:image" content="https://kubex.world/assets/kubex_og.png" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Kubex ‚Äî Code Fast. Own Everything." />
<meta name="twitter:description" content="AI-powered, open-source ecosystem. No lock-in. No excuses." />
<meta name="twitter:image" content="https://kubex.world/assets/kubex_og.png" />

<!-- Favicon -->
<link rel="icon" href="/assets/favicon.ico" />
<link rel="apple-touch-icon" href="/assets/apple-touch-icon.png" />
<link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#00f0ff" />

/// public/humans.txt ///
/* TEAM */
Creator & Lead Developer: Rafael Mori
Contact: faelmori [at] live.com
From: Brasil
GitHub: https://github.com/rafa-mori

/* THANKS */
AI Assistant: GitHub Copilot
Community: Open Source Contributors
Inspiration: The need for truly free, no-lock-in developer tools

/* SITE */
Last update: 2025/09/08
Standards: HTML5, CSS3, ES2023, TypeScript
Components: React 19, Vite 6, Tailwind CSS
Software: VS Code, GitHub, Vercel
AI Models: Google Gemini (optional)

/* KUBEX PRINCIPLES */
Radical Simplicity: One command = one result
Modularity: Well-structured, reusable components
No Cages: Platform-agnostic, open formats, no vendor lock-in

CODE FAST. OWN EVERYTHING.

/// public/robots.txt ///
User-agent: *
Allow: /

Sitemap: https://kubex.world/sitemap.xml

/// public/sitemap.xml ///
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://kubex.world/</loc>
    <lastmod>2025-09-08</lastmod>
    <changefreq>weekly</changefreq>
    <priority>1.0</priority>
  </url>
  <url>
    <loc>https://kubex.world/grompt</loc>
    <lastmod>2025-09-08</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.9</priority>
  </url>
  <url>
    <loc>https://kubex.world/grompt/</loc>
    <lastmod>2025-09-08</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.8</priority>
  </url>
</urlset>

/// services/geminiService.ts ///
import { GenerateContentResponse, GoogleGenAI } from "@google/genai";
import { Idea } from '../types';

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  console.warn("Gemini API key not found. Running in demo mode with simulated responses.");
}

// Function to get user's API key from localStorage
const getUserApiKey = (): string | null => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('userApiKey');
  }
  return null;
};

// Function to get active API key (user's key takes precedence)
const getActiveApiKey = (): string | null => {
  return getUserApiKey() || API_KEY || null;
};

const createAIInstance = (apiKey: string) => {
  return new GoogleGenAI({ apiKey });
};

// FIX: Updated model to 'gemini-2.5-flash' to comply with guidelines.
const model = 'gemini-2.5-flash';

export interface PromptGenerationResult {
  prompt: string;
  // FIX: Made token count properties optional to match the Gemini API response type.
  usageMetadata?: {
    promptTokenCount?: number;
    candidatesTokenCount?: number;
    totalTokenCount?: number;
  };
}

// Demo mode simulation
const generateDemoPrompt = (ideas: Idea[], purpose: string): PromptGenerationResult => {
  const ideasText = ideas.map((idea, index) => `- ${idea.text}`).join('\n');

  const demoPrompt = `# ${purpose} Expert Assistant

## Primary Objective
Transform the provided ideas into actionable ${purpose.toLowerCase()} solutions following Kubex principles of radical simplicity and modularity.

## User Requirements
${ideasText}

## Task Instructions
You are an expert ${purpose.toLowerCase()} specialist. Based on the requirements above, provide a comprehensive solution that:

### Key Requirements:
- Follow KUBEX principles: Radical Simplicity, Modularity, No Cages
- Use clear, anti-jargon language
- Provide modular, reusable components
- Ensure outputs are platform-agnostic

### Expected Output Format:
- Use Markdown for clear structure
- Include code examples when applicable
- Provide step-by-step instructions
- Add relevant comments and documentation

### Constraints:
- Avoid vendor lock-in solutions
- Keep complexity minimal
- Focus on practical, implementable solutions
- Use open standards and formats

## Context
This prompt was generated using Grompt, part of the Kubex Ecosystem, following principles of radical simplicity and avoiding technological cages.

---
*Generated in demo mode - Connect your AI provider API key for enhanced AI-powered prompts*`;

  // Simulate token usage for demo
  const estimatedTokens = Math.floor(demoPrompt.length / 4); // Rough estimation: 1 token ‚âà 4 characters

  return {
    prompt: demoPrompt,
    usageMetadata: {
      promptTokenCount: Math.floor(estimatedTokens * 0.3),
      candidatesTokenCount: Math.floor(estimatedTokens * 0.7),
      totalTokenCount: estimatedTokens
    }
  };
};

const createMetaPrompt = (ideas: Idea[], purpose: string): string => {
  const ideasText = ideas.map((idea, index) => `- ${idea.text}`).join('\n');

  return `
You are a world-class prompt engineering expert, a key copilot in the Kubex Ecosystem. Your mission is to transform a user's raw, unstructured ideas into a clean, effective, and professional prompt for large language models, adhering strictly to Kubex principles.

**KUBEX PRINCIPLES:**
- **Simplicidade Radical:** The prompt must be direct, pragmatic, and anti-jargon. "One command = one result."
- **Modularidade:** The output should be well-structured and easily usable.
- **Sem Jaulas (No Cages):** The prompt should use open, clear formats (like Markdown) and not lock the user into a specific model's quirks.

**User's Raw Ideas:**
${ideasText}

**Desired Purpose of the Final Prompt:**
${purpose}

**Your Task:**
Based on the ideas and purpose provided, generate a single, comprehensive, and well-structured prompt in Markdown format. The generated prompt must be ready for immediate use.

**Key Directives:**
1.  **Define a Persona:** Start the prompt by defining a clear, expert role for the AI (e.g., "You are an expert software architect specializing in cloud-native solutions...").
2.  **State the Objective:** Clearly articulate the main goal of the prompt in a "Primary Objective" section.
3.  **Provide Structure:** Use Markdown (headings, lists, bold text) to create a logical and readable structure. Use sections like "Requirements", "Expected Output", "Constraints", and "Context".
4.  **List Key Requirements:** Systematically break down the user's ideas into specific, actionable requirements in a bulleted list.
5.  **Specify Output Format:** If applicable, describe the desired output format (e.g., JSON schema, code block with language specifier, table).
6.  **Include Constraints:** Add any negative constraints or things to avoid (e.g., "Do not use libraries outside the standard library.").
7.  **Add Context:** If implied by the ideas, add a "Context" section to provide background that will help the AI generate a better response.

**OUTPUT CONTRACT:**
Return ONLY the generated prompt in Markdown. Do not include any introductory text, explanations, or concluding remarks like "Here is the prompt:". Your response must start directly with the Markdown content of the prompt (e.g., starting with a '# Title' or '**Persona:**').
`;
};

const MAX_RETRIES = parseInt(process.env.MAX_RETRIES || "3", 10);
const RETRY_DELAY_MS = parseInt(process.env.RETRY_DELAY_MS || "1000", 10);

/**
 * Checks if an error is likely a transient network issue and thus retryable.
 * @param error The error object.
 * @returns True if the error is retryable, false otherwise.
 */
const isRetryableError = (error: any): boolean => {
  const errorMessage = (error?.message || '').toLowerCase();
  // Simple check for network-related errors.
  return errorMessage.includes('fetch') || errorMessage.includes('network');
};

/**
 * Formats an API error into a user-friendly string.
 * @param error The error object from the API call.
 * @returns A user-friendly error message string.
 */
const formatApiError = (error: any): string => {
  // Keep a detailed log for developers
  console.error("Gemini API Error:", error);

  if (error instanceof Error) {
    // Provide a more specific message for common, user-actionable errors.
    if (error.message.includes('API key not valid')) {
      return 'API Configuration Error: The API key is not valid. Please contact the administrator.';
    }
    // For other errors, provide a message that includes the API's feedback.
    return `An error occurred: ${error.message}. Please check your input or try again. If the issue persists, it may be a network problem.`;
  }

  return "An unknown error occurred while communicating with the Gemini API. Please check your connection and try again.";
};

export const generateStructuredPrompt = async (ideas: Idea[], purpose: string): Promise<PromptGenerationResult> => {
  const activeApiKey = getActiveApiKey();

  // If no API key available, use demo mode
  if (!activeApiKey) {
    return generateDemoPrompt(ideas, purpose);
  }

  const ai = createAIInstance(activeApiKey);

  const isRetryableError = (error: any): boolean => {
    if (error.message?.includes('rate limit') || error.message?.includes('quota')) {
      return true;
    }
    if (error.status === 429 || error.status === 500 || error.status === 502 || error.status === 503) {
      return true;
    }
    return false;
  };

  const formatApiError = (error: any): string => {
    if (error.message?.includes('API key')) {
      return "API key issue. Please check your Gemini API key configuration.";
    }
    if (error.message?.includes('rate limit') || error.message?.includes('quota')) {
      return "Rate limit exceeded. Please try again later.";
    }
    return `Gemini API error: ${error.message || 'Unknown error occurred'}`;
  };

  let lastError: any = null;

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      const metaPrompt = createMetaPrompt(ideas, purpose);
      const response: GenerateContentResponse = await ai.models.generateContent({
        model: model,
        contents: metaPrompt,
        config: {
          temperature: 0.3,
          topP: 0.9,
          topK: 40,
        }
      });

      const generatedText = response.text;
      if (!generatedText) {
        throw new Error("Empty response received from Gemini API");
      }

      return {
        prompt: generatedText,
        usageMetadata: response.usageMetadata
      };
    } catch (error) {
      lastError = error;
      if (isRetryableError(error) && attempt < MAX_RETRIES) {
        console.warn(`API call failed (attempt ${attempt}/${MAX_RETRIES}), retrying after delay...`);
        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * attempt)); // Simple exponential backoff
      } else {
        // Not a retryable error or max retries reached
        throw new Error(formatApiError(error));
      }
    }
  }
  // This fallback should ideally not be reached, but it's here for safety.
  throw new Error(formatApiError(lastError || new Error("Failed to generate prompt after multiple retries.")));
};

/// src/App.tsx ///
import { AlertTriangle } from 'lucide-react';
import { useEffect, useState } from 'react';
import Footer from './components/layout/Footer';
import Header from './components/layout/Header';
import PromptCrafter from './components/prompt-crafter/PromptCrafter';
import { LanguageContext } from './context/LanguageContext';
import { useLanguage } from './hooks/useLanguage';
import { useTheme } from './hooks/useTheme';
import { useAnalytics } from './services/analytics';
import { initStorage } from './services/storageService';

const App: React.FC = () => {
  const [theme, toggleTheme] = useTheme();
  const { language, setLanguage, t } = useLanguage();
  const [isApiKeyMissing, setIsApiKeyMissing] = useState(false);

  // Initialize analytics
  useAnalytics();

  // Initialize the storage service on app load
  useEffect(() => {
    initStorage();
    // Check for the API key availability on mount
    if (!process.env.API_KEY) {
      console.log("Running in demo mode - API key not configured");
      setIsApiKeyMissing(true);
    }
  }, []);

  return (
    <LanguageContext.Provider value={{ language, setLanguage, t }}>
      <div className="min-h-screen text-slate-800 dark:text-[#e0f7fa] font-plex-mono p-4 sm:p-6 lg:p-8">
        <div className="max-w-7xl mx-auto">
          <Header theme={theme} toggleTheme={toggleTheme} />
          {isApiKeyMissing && (
            <div className="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md mb-6 dark:bg-blue-900/30 dark:text-blue-300 dark:border-blue-600 flex items-start gap-3" role="alert">
              <AlertTriangle className="h-6 w-6 text-blue-500 dark:text-blue-400 flex-shrink-0 mt-0.5" />
              <div>
                <p className="font-bold">{t('apiKeyMissingTitle')}</p>
                <p>{t('apiKeyMissingText')}</p>
              </div>
            </div>
          )}
          <main>
            <PromptCrafter theme={theme} isApiKeyMissing={isApiKeyMissing} />
          </main>
          <Footer />
        </div>
      </div>
    </LanguageContext.Provider>
  );
};

export default App;

/// src/components/prompt-crafter/ApiKeyInput.tsx ///
import { AlertCircle, Check, Eye, EyeOff, Key } from 'lucide-react';
import React, { useEffect, useState } from 'react';
import { useTranslations } from '../../i18n/useTranslations';

interface ApiKeyInputProps {
  onApiKeyChange: (apiKey: string) => void;
  isVisible: boolean;
}

const ApiKeyInput: React.FC<ApiKeyInputProps> = ({ onApiKeyChange, isVisible }) => {
  const { t } = useTranslations();
  const [apiKey, setApiKey] = useState('');
  const [showKey, setShowKey] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [isValid, setIsValid] = useState<boolean | null>(null);

  // Load API key from localStorage on mount
  useEffect(() => {
    const savedKey = localStorage.getItem('userApiKey');
    if (savedKey) {
      setApiKey(savedKey);
      onApiKeyChange(savedKey);
      setIsValid(true);
    }
  }, [onApiKeyChange]);

  const handleApiKeyChange = (value: string) => {
    setApiKey(value);
    setIsValid(null);

    if (value.trim()) {
      // Save to localStorage
      localStorage.setItem('userApiKey', value.trim());
      onApiKeyChange(value.trim());

      // Simple validation - check if it looks like a Gemini API key
      const isValidFormat = value.startsWith('AIza') && value.length > 35;
      setIsValid(isValidFormat);
    } else {
      localStorage.removeItem('userApiKey');
      onApiKeyChange('');
      setIsValid(null);
    }
  };

  const clearApiKey = () => {
    setApiKey('');
    setIsValid(null);
    localStorage.removeItem('userApiKey');
    onApiKeyChange('');
  };

  if (!isVisible) return null;

  return (
    <div className="bg-gray-50 dark:bg-gray-800/50 border border-gray-200 dark:border-gray-700 rounded-lg p-4 mb-6">
      <div className="flex items-center gap-2 mb-3">
        <Key className="h-5 w-5 text-blue-500" />
        <h3 className="font-bold text-lg">Connect Your Gemini API Key</h3>
      </div>

      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
        To get AI-powered prompts, enter your Gemini API key. Get one free at{' '}
        <a
          href="https://ai.google.dev/"
          target="_blank"
          rel="noopener noreferrer"
          className="text-blue-500 hover:underline"
        >
          ai.google.dev
        </a>
      </p>

      <div className="relative">
        <input
          type={showKey ? 'text' : 'password'}
          value={apiKey}
          onChange={(e) => handleApiKeyChange(e.target.value)}
          placeholder="AIza..."
          className="w-full px-4 py-2 pr-20 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />

        <div className="absolute right-2 top-1/2 transform -translate-y-1/2 flex items-center gap-1">
          {isValid === true && (
            <Check className="h-4 w-4 text-green-500" />
          )}
          {isValid === false && (
            <AlertCircle className="h-4 w-4 text-red-500" />
          )}

          <button
            type="button"
            onClick={() => setShowKey(!showKey)}
            className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            {showKey ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
          </button>
        </div>
      </div>

      {isValid === false && (
        <p className="text-sm text-red-600 dark:text-red-400 mt-2">
          Invalid API key format. Gemini API keys start with "AIza" and are longer than 35 characters.
        </p>
      )}

      {apiKey && (
        <div className="flex justify-between items-center mt-3">
          <p className="text-sm text-green-600 dark:text-green-400">
            ‚úì API key saved locally (never sent to our servers)
          </p>
          <button
            onClick={clearApiKey}
            className="text-sm text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
          >
            Clear
          </button>
        </div>
      )}
    </div>
  );
};

export default ApiKeyInput;

/// src/components/prompt-crafter/GeneratedPrompt.tsx ///
import { AlertTriangle, BrainCircuit, Check, Clipboard, ClipboardCheck, Code, Copy, Eye, Loader, Share2, Wand2, X } from 'lucide-react';
import React, { useEffect, useRef, useState } from 'react';
import ReactMarkdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark, oneLight } from 'react-syntax-highlighter/dist/esm/styles/prism';
import remarkGfm from 'remark-gfm';
import { useTranslations } from '../../i18n/useTranslations';
import { Idea, Theme } from '../../types';


interface GeneratedPromptProps {
  isLoading: boolean;
  error: string | null;
  setError: (error: string | null) => void;
  generatedPrompt: string;
  ideas: Idea[];
  purpose: string;
  tokenUsage: { input: number; output: number; total: number; } | null;
  theme: Theme;
}

const GeneratedPrompt: React.FC<GeneratedPromptProps> = ({ isLoading, error, setError, generatedPrompt, ideas, purpose, tokenUsage, theme }) => {
  const { t } = useTranslations();
  const [isCopied, setIsCopied] = useState(false);
  const [isLinkCopied, setIsLinkCopied] = useState(false);
  const [viewMode, setViewMode] = useState<'preview' | 'raw'>('preview');
  const [copiedCode, setCopiedCode] = useState<string | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Auto-resize textarea
  useEffect(() => {
    if (viewMode === 'raw' && textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      const scrollHeight = textareaRef.current.scrollHeight;
      textareaRef.current.style.height = `${scrollHeight}px`;
    }
  }, [generatedPrompt, viewMode]);

  const handleCopy = () => {
    if (generatedPrompt) {
      navigator.clipboard.writeText(generatedPrompt);
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), 2000);
    }
  };

  const handleShare = () => {
    if (!generatedPrompt) return;
    try {
      const dataToShare = {
        ideas,
        purpose,
        prompt: generatedPrompt,
      };
      const jsonString = JSON.stringify(dataToShare);
      const encodedData = btoa(jsonString);
      const shareUrl = `${window.location.origin}${window.location.pathname}#prompt=${encodedData}`;

      navigator.clipboard.writeText(shareUrl);
      setIsLinkCopied(true);
      setTimeout(() => setIsLinkCopied(false), 2500);

    } catch (e) {
      console.error("Failed to create share link", e);
      setError("An unexpected error occurred while creating the shareable link.");
    }
  };

  const handleCodeCopy = async (code: string) => {
    try {
      await navigator.clipboard.writeText(code);
      setCopiedCode(code);
      setTimeout(() => setCopiedCode(null), 2000);
    } catch (err) {
      console.error('Failed to copy code to clipboard:', err);
    }
  };

  const markdownComponents = {
    code({ node, inline, className, children, ...props }: any) {
      const match = /language-(\w+)/.exec(className || '');
      const codeString = String(children).replace(/\n$/, '');
      return !inline && match ? (
        <div className="relative group my-4">
          <SyntaxHighlighter
            style={theme === 'dark' ? oneDark : oneLight}
            language={match[1]}
            PreTag="div"
            className="rounded-md"
            customStyle={{ margin: 0, padding: '1rem', backgroundColor: theme === 'dark' ? '#10151b' : '#f1f5f9' }}
            {...props}
          >
            {codeString}
          </SyntaxHighlighter>
          <button
            onClick={() => handleCodeCopy(codeString)}
            className={`absolute top-2 right-2 p-1.5 rounded-md text-white opacity-0 group-hover:opacity-100 transition-all duration-200 ${copiedCode === codeString
                ? 'bg-emerald-600'
                : 'bg-slate-700/50 hover:bg-slate-600/70'
              }`}
            aria-label={copiedCode === codeString ? t('copied') : t('copyCode')}
            title={copiedCode === codeString ? t('copied') : t('copyCode')}
          >
            {copiedCode === codeString ? <Check size={16} /> : <Copy size={16} />}
          </button>
        </div>
      ) : (
        <code className={className} {...props}>
          {children}
        </code>
      )
    }
  };


  return (
    <div className="bg-white/60 dark:bg-[#10151b]/30 p-6 rounded-lg border-2 border-slate-200 dark:border-[#00e676]/30 backdrop-blur-sm flex-grow flex flex-col shadow-2xl shadow-slate-500/10">
      <h3 className="text-2xl font-bold font-orbitron text-emerald-600 dark:text-[#00e676] tracking-wider mb-4 light-shadow-emerald dark:neon-glow-green">{t('generatedPromptTitle')}</h3>
      <div className="flex-grow bg-slate-100 dark:bg-[#0a0f14] rounded-md min-h-[300px] flex flex-col border border-slate-200 dark:border-transparent">
        <div className="relative flex-grow p-4 overflow-y-auto">
          {isLoading && (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-slate-100/80 dark:bg-[#0a0f14]/80 backdrop-blur-sm z-20">
              <Loader className="animate-spin text-sky-500 dark:text-[#00f0ff]" size={48} />
              <p className="mt-4 text-sky-500 dark:text-[#00f0ff] font-semibold">{t('generatingMessage')}</p>
            </div>
          )}
          {error && (
            <div className="absolute inset-0 flex flex-col items-center justify-center bg-slate-100/80 dark:bg-[#0a0f14]/80 backdrop-blur-sm p-4 z-20">
              <div className="bg-red-100 dark:bg-red-900/50 border border-red-300 dark:border-red-500 text-red-700 dark:text-red-300 p-4 rounded-lg flex flex-col items-center gap-2 text-center shadow-lg">
                <AlertTriangle size={32} />
                <h4 className="font-bold">{t('generationFailedTitle')}</h4>
                <p className="text-sm">{error}</p>
                <button onClick={() => setError(null)} className="mt-2 bg-red-500/20 dark:bg-red-500/50 hover:bg-red-500/30 dark:hover:bg-red-500/80 text-red-800 dark:text-white px-3 py-1 text-sm rounded-md flex items-center gap-1">
                  <X size={14} /> {t('close')}
                </button>
              </div>
            </div>
          )}
          {generatedPrompt && !isLoading && !error && (
            <>
              <div className="absolute top-2 right-2 flex gap-2 z-10">
                <button onClick={() => setViewMode(viewMode === 'raw' ? 'preview' : 'raw')} className="bg-white dark:bg-[#10151b] p-2 rounded-md text-sky-500 dark:text-[#00f0ff] hover:bg-sky-100 dark:hover:bg-[#00f0ff] hover:text-sky-600 dark:hover:text-black transition-all duration-200" aria-label={t('toggleView')}>
                  {viewMode === 'raw' ? <Eye size={20} /> : <Code size={20} />}
                </button>
                <button onClick={handleShare} className="bg-white dark:bg-[#10151b] p-2 rounded-md text-sky-500 dark:text-[#00f0ff] hover:bg-sky-100 dark:hover:bg-[#00f0ff] hover:text-sky-600 dark:hover:text-black transition-all duration-200" aria-label={t('copyLink')}>
                  {isLinkCopied ? <ClipboardCheck size={20} /> : <Share2 size={20} />}
                </button>
                <button onClick={handleCopy} className="bg-white dark:bg-[#10151b] p-2 rounded-md text-sky-500 dark:text-[#00f0ff] hover:bg-sky-100 dark:hover:bg-[#00f0ff] hover:text-sky-600 dark:hover:text-black transition-all duration-200" aria-label={t('copyPrompt')}>
                  {isCopied ? <ClipboardCheck size={20} /> : <Clipboard size={20} />}
                </button>
              </div>
              {viewMode === 'preview' ? (
                <div className="prose prose-sm max-w-none text-slate-800 dark:text-[#e0f7fa] dark:prose-invert prose-headings:font-orbitron prose-code:font-plex-mono prose-code:bg-slate-200 dark:prose-code:bg-[#10151b] prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded-md">
                  <ReactMarkdown remarkPlugins={[remarkGfm]} components={markdownComponents}>{generatedPrompt}</ReactMarkdown>
                </div>
              ) : (
                <textarea
                  title='Generated Prompt'
                  ref={textareaRef}
                  readOnly
                  value={generatedPrompt}
                  className="w-full h-auto bg-transparent resize-none border-none focus:ring-0 p-0 m-0 font-plex-mono text-sm leading-relaxed text-slate-800 dark:text-[#e0f7fa] overflow-hidden"
                  rows={1}
                />
              )}
            </>
          )}
          {!generatedPrompt && !isLoading && !error && (
            <div className="flex flex-col items-center justify-center h-full text-slate-400 dark:text-[#90a4ae]/50">
              <Wand2 size={48} className="mb-4" />
              <p className="font-semibold text-center">{t('promptPlaceholder')}</p>
            </div>
          )}
        </div>
        {tokenUsage && (
          <div className="flex-shrink-0 bg-slate-200/50 dark:bg-[#10151b]/50 p-2 border-t border-slate-200 dark:border-slate-700/50">
            <div className="flex items-center justify-center gap-4 text-xs text-slate-600 dark:text-slate-400 font-semibold">
              <BrainCircuit size={16} className="text-sky-500 dark:text-sky-400" />
              <span>{t('input')}: <span className="font-bold text-sky-600 dark:text-sky-300">{tokenUsage.input}</span> {t('tokens')}</span>
              <span className="text-slate-300 dark:text-slate-600">|</span>
              <span>{t('output')}: <span className="font-bold text-emerald-600 dark:text-emerald-300">{tokenUsage.output}</span> {t('tokens')}</span>
              <span className="text-slate-300 dark:text-slate-600">|</span>
              <span>{t('total')}: <span className="font-bold text-indigo-600 dark:text-indigo-300">{tokenUsage.total}</span> {t('tokens')}</span>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default GeneratedPrompt;

/// src/components/prompt-crafter/IdeaInput.tsx ///
import React from 'react';
import { useTranslations } from '../../i18n/useTranslations';
import { Plus } from 'lucide-react';

interface IdeaInputProps {
  currentIdea: string;
  setCurrentIdea: (value: string) => void;
  onAddIdea: () => void;
  disabled?: boolean;
}

const IdeaInput: React.FC<IdeaInputProps> = React.memo(({ currentIdea, setCurrentIdea, onAddIdea, disabled }) => {
  const { t } = useTranslations();
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      onAddIdea();
    }
  };

  return (
    <div className="flex gap-2">
      <input
        type="text"
        value={currentIdea}
        onChange={(e) => setCurrentIdea(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder={t('ideaPlaceholder')}
        className="flex-grow bg-white dark:bg-[#10151b] border-2 border-slate-300 dark:border-[#7c4dff]/50 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:focus:ring-[#7c4dff] focus:border-indigo-500 dark:focus:border-[#7c4dff] transition-all duration-300 placeholder:text-slate-400 dark:placeholder:text-[#90a4ae]/50 text-slate-800 dark:text-white"
      />
      <button
        onClick={onAddIdea}
        disabled={!currentIdea.trim() || disabled}
        className="bg-indigo-500 dark:bg-[#7c4dff] text-white p-3 rounded-md flex items-center justify-center hover:bg-indigo-600 dark:hover:bg-[#8e24aa] disabled:bg-slate-400 dark:disabled:bg-gray-600 disabled:cursor-not-allowed transition-all duration-300 shadow-lg shadow-indigo-500/30 dark:shadow-[0_0_10px_rgba(124,77,255,0.5)] hover:shadow-xl hover:shadow-indigo-500/40 dark:hover:shadow-[0_0_15px_rgba(142,36,170,0.7)]"
        aria-label={t('addIdea')}
      >
        <Plus size={24} />
      </button>
    </div>
  );
});

export default IdeaInput;

/// src/components/prompt-crafter/IdeasList.tsx ///
import React from 'react';
import { useTranslations } from '../../i18n/useTranslations';
import { Idea } from '../../types';
import { Trash2 } from 'lucide-react';

interface IdeasListProps {
  ideas: Idea[];
  onRemoveIdea: (id: string) => void;
}
const IdeasList: React.FC<IdeasListProps> = React.memo(({ ideas, onRemoveIdea }) => {
  const { t } = useTranslations();
  return (
    <div className="space-y-3 mt-4 pr-2 max-h-60 overflow-y-auto">
      {ideas.map((idea, index) => (
        <div key={idea.id} className="bg-slate-100/50 dark:bg-[#10151b]/50 p-3 rounded-md flex justify-between items-center border border-transparent hover:border-sky-400/50 dark:hover:border-[#00f0ff]/30 transition-colors duration-300 animate-fade-in" style={{ animationDelay: `${index * 50}ms` }}>
          <span className="text-slate-700 dark:text-[#e0f7fa]">{idea.text}</span>
          <button
            onClick={() => onRemoveIdea(idea.id)}
            className="text-red-500 dark:text-red-400 hover:text-red-600 dark:hover:text-red-300 p-1 rounded-full hover:bg-red-500/10 dark:hover:bg-red-500/20 transition-all duration-200"
            aria-label={t('removeIdea', { idea: idea.text })}
          >
            <Trash2 size={16} />
          </button>
        </div>
      ))}
    </div>
  );
});

export default IdeasList;

/// src/components/prompt-crafter/PromptCrafter.tsx ///
import { Lightbulb, Loader, Wand2 } from 'lucide-react';
import React, { useCallback, useState } from 'react';
import { examples } from '../../constants/prompts';
import { useTranslations } from '../../i18n/useTranslations';
import { generateStructuredPrompt } from '../../services/geminiService';
import { HistoryItem, Idea, Theme } from '../../types';

// Import hooks
import { useAutosaveDraft } from '../../hooks/useAutosaveDraft';
import { usePromptHistory } from '../../hooks/usePromptHistory';
import { useUrlSharing } from '../../hooks/useUrlSharing';

// Import sub-components
import ApiKeyInput from './ApiKeyInput';
import GeneratedPrompt from './GeneratedPrompt';
import IdeaInput from './IdeaInput';
import IdeasList from './IdeasList';
import PromptHistoryDisplay from './PromptHistoryDisplay';
import PurposeSelector from './PurposeSelector';

interface PromptCrafterProps {
  theme: Theme;
  isApiKeyMissing: boolean;
}

const PromptCrafter: React.FC<PromptCrafterProps> = ({ theme, isApiKeyMissing }) => {
  const { t } = useTranslations();

  // State managed by hooks
  const { ideas, setIdeas, purpose, setPurpose } = useAutosaveDraft();
  const { promptHistory, setPromptHistory, deleteFromHistory, clearHistory } = usePromptHistory();

  // Local component state
  const [currentIdea, setCurrentIdea] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [generatedPrompt, setGeneratedPrompt] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [tokenUsage, setTokenUsage] = useState<{ input: number; output: number; total: number; } | null>(null);
  const [isExampleLoaded, setIsExampleLoaded] = useState(false);
  const [userApiKey, setUserApiKey] = useState<string>('');

  // Handler for API key changes
  const handleApiKeyChange = (apiKey: string) => {
    setUserApiKey(apiKey);
    // Force re-render to update UI state when API key is added/removed
    if (apiKey && isApiKeyMissing) {
      // We can now use the API instead of demo mode
      setError(null);
    }
  };

  // Hook for loading shared URL
  useUrlSharing({ setIdeas, setPurpose, setGeneratedPrompt, setTokenUsage, setError });

  // Create wrapped state setters to reset the example flag on user interaction
  const handleSetCurrentIdea = (value: string) => {
    // If an example is loaded, any typing signifies a modification.
    // Reset the flag to re-enable the generate button.
    if (isExampleLoaded) {
      setIsExampleLoaded(false);
    }
    setCurrentIdea(value);
  };

  const handleSetPurpose = (value: string) => {
    // If an example is loaded, changing the purpose signifies a modification.
    // Reset the flag to re-enable the generate button.
    if (isExampleLoaded) {
      setIsExampleLoaded(false);
    }
    setPurpose(value);
  };

  const handleAddIdea = useCallback(() => {
    if (currentIdea.trim() !== '') {
      setIdeas(prev => [...prev, { id: Date.now().toString(), text: currentIdea.trim() }]);
      setCurrentIdea('');
      // If an example is loaded, adding a new idea signifies a modification.
      // Reset the flag to re-enable the generate button.
      if (isExampleLoaded) {
        setIsExampleLoaded(false);
      }
    }
  }, [currentIdea, setIdeas, isExampleLoaded]);

  const handleRemoveIdea = useCallback((id: string) => {
    setIdeas(prev => prev.filter(idea => idea.id !== id));
    // If an example is loaded, removing an idea signifies a modification.
    // Reset the flag to re-enable the generate button.
    if (isExampleLoaded) {
      setIsExampleLoaded(false);
    }
  }, [setIdeas, isExampleLoaded]);

  const handleGenerate = async () => {
    if (ideas.length === 0) {
      setError(t('errorAddIdea'));
      return;
    }
    if (!purpose.trim()) {
      setError(t('errorSpecifyPurpose'));
      return;
    }
    setError(null);
    setIsLoading(true);
    setGeneratedPrompt('');
    setTokenUsage(null);
    try {
      const result = await generateStructuredPrompt(ideas, purpose);
      setGeneratedPrompt(result.prompt);
      const inputTokens = result.usageMetadata?.promptTokenCount ?? 0;
      const outputTokens = result.usageMetadata?.candidatesTokenCount ?? 0;
      const totalTokens = result.usageMetadata?.totalTokenCount ?? (inputTokens + outputTokens);
      setTokenUsage({ input: inputTokens, output: outputTokens, total: totalTokens });

      const newItem: HistoryItem = {
        id: Date.now().toString(),
        prompt: result.prompt,
        purpose,
        ideas: [...ideas],
        timestamp: Date.now(),
        inputTokens,
        outputTokens,
        totalTokens,
      };
      setPromptHistory(prev => [newItem, ...prev].slice(0, 20));
    } catch (err: any) {
      setError(err.message || 'An unknown error occurred.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleLoadExample = useCallback(() => {
    setError(null);
    setGeneratedPrompt('');
    setTokenUsage(null);
    const randomIndex = Math.floor(Math.random() * examples.length);
    const example = examples[randomIndex];
    const exampleIdeas: Idea[] = example.ideas.map((text, index) => ({
      id: `example-${Date.now()}-${index}`,
      text,
    }));
    setPurpose(example.purpose);
    setIdeas(exampleIdeas);
    setIsExampleLoaded(true);
  }, [setIdeas, setPurpose]);

  const handleLoadFromHistory = useCallback((item: HistoryItem) => {
    setIdeas(item.ideas);
    setPurpose(item.purpose);
    setGeneratedPrompt(item.prompt);
    setTokenUsage(item.inputTokens != null && item.outputTokens != null
      ? {
        input: item.inputTokens,
        output: item.outputTokens,
        total: item.totalTokens ?? (item.inputTokens + item.outputTokens)
      }
      : null);
    setError(null);
    setIsExampleLoaded(false); // Reset flag when loading from history
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }, [setIdeas, setPurpose]);

  return (
    <div className="grid lg:grid-cols-2 gap-8">
      {/* API Key Input Section - only show when no API key is configured */}
      {isApiKeyMissing && (
        <div className="lg:col-span-2">
          <ApiKeyInput
            onApiKeyChange={handleApiKeyChange}
            isVisible={isApiKeyMissing}
          />
        </div>
      )}
      {/* Input Section */}
      <div className="bg-white/60 dark:bg-[#10151b]/30 p-6 rounded-lg border-2 border-slate-200 dark:border-[#7c4dff]/30 backdrop-blur-sm shadow-2xl shadow-slate-500/10">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-2xl font-bold font-orbitron text-indigo-600 dark:text-[#7c4dff] tracking-wider">{t('inputIdeasTitle')}</h3>
          <button
            onClick={handleLoadExample}
            className="flex items-center gap-2 px-3 py-1 text-sm bg-slate-200/50 dark:bg-[#10151b] text-indigo-600 dark:text-[#7c4dff] rounded-full hover:bg-slate-300/50 dark:hover:bg-slate-800 transition-colors duration-200"
            aria-label={t('loadExample')}
          >
            <Lightbulb size={16} />
            <span>{t('loadExample')}</span>
          </button>
        </div>
        <IdeaInput
          currentIdea={currentIdea}
          setCurrentIdea={handleSetCurrentIdea}
          onAddIdea={handleAddIdea}
          disabled={isExampleLoaded}
        />
        <IdeasList ideas={ideas} onRemoveIdea={handleRemoveIdea} />
        <PurposeSelector purpose={purpose} setPurpose={handleSetPurpose} />
      </div>

      {/* Output Section */}
      <div className="flex flex-col">
        <GeneratedPrompt
          isLoading={isLoading}
          error={error}
          setError={setError}
          generatedPrompt={generatedPrompt}
          ideas={ideas}
          purpose={purpose}
          tokenUsage={tokenUsage}
          theme={theme}
        />
        <button
          onClick={handleGenerate}
          disabled={isLoading || ideas.length === 0 || !purpose.trim() || isExampleLoaded}
          className="w-full mt-6 bg-gradient-to-r from-emerald-500 to-sky-500 dark:from-[#00e676] dark:to-[#00f0ff] text-white dark:text-black font-bold font-orbitron text-lg p-4 rounded-lg flex items-center justify-center gap-3 hover:scale-105 disabled:scale-100 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300 shadow-lg shadow-sky-500/40 dark:shadow-[0_0_15px_rgba(0,230,118,0.5)] hover:shadow-xl hover:shadow-sky-500/50 dark:hover:shadow-[0_0_25px_rgba(0,240,255,0.7)]"
        >
          {isLoading ? <Loader className="animate-spin" size={28} /> : <Wand2 size={28} />}
          {isLoading ? t('generatingButton') : t('generateButton')}
        </button>
      </div>

      {/* Prompt History Section */}
      <PromptHistoryDisplay
        history={promptHistory}
        onLoad={handleLoadFromHistory}
        onDelete={deleteFromHistory}
        onClear={clearHistory}
      />
    </div>
  );
};

export default PromptCrafter;

/// src/components/prompt-crafter/PromptHistoryDisplay.tsx ///
import React from 'react';
import { useTranslations } from '../../i18n/useTranslations';
import { HistoryItem } from '../../types';
import { formatRelativeTime } from '../../lib/time';
import { History, XCircle, Eye, Trash2 } from 'lucide-react';

interface PromptHistoryProps {
  history: HistoryItem[];
  onLoad: (item: HistoryItem) => void;
  onDelete: (id: string) => void;
  onClear: () => void;
}

const PromptHistoryDisplay: React.FC<PromptHistoryProps> = React.memo(({ history, onLoad, onDelete, onClear }) => {
  const { t, language } = useTranslations();
  return (
    <div className="lg:col-span-2 bg-white/60 dark:bg-[#10151b]/30 p-6 rounded-lg border-2 border-slate-200 dark:border-sky-500/30 backdrop-blur-sm shadow-2xl shadow-slate-500/10">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-2xl font-bold font-orbitron text-sky-600 dark:text-sky-400 tracking-wider">{t('historyTitle')}</h3>
        {history.length > 0 && (
          <button
            onClick={onClear}
            className="flex items-center gap-2 px-3 py-1 text-sm bg-red-500/10 dark:bg-red-500/20 text-red-600 dark:text-red-300 rounded-full hover:bg-red-500/20 dark:hover:bg-red-500/30 transition-colors duration-200"
            aria-label={t('clearAll')}
          >
            <XCircle size={16} />
            <span>{t('clearAll')}</span>
          </button>
        )}
      </div>
      <div className="max-h-96 overflow-y-auto pr-2 space-y-3">
        {history.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-40 text-slate-400 dark:text-[#90a4ae]/50">
            <History size={48} className="mb-4" />
            <p className="font-semibold text-center">{t('historyPlaceholder')}</p>
          </div>
        ) : (
          history.map(item => (
            <div key={item.id} className="bg-slate-100/50 dark:bg-[#10151b]/50 p-3 rounded-md flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3 border border-transparent hover:border-sky-400/50 dark:hover:border-sky-500/50 transition-colors duration-300">
              <div className="flex-grow overflow-hidden">
                <div className="flex items-center gap-2 mb-1 flex-wrap">
                  <span className="px-2 py-0.5 text-xs font-bold text-white dark:text-black rounded-full bg-sky-500 dark:bg-sky-400 flex-shrink-0">{item.purpose}</span>
                  <span className="text-xs text-slate-500 dark:text-[#90a4ae] truncate">{formatRelativeTime(item.timestamp, language)}</span>
                </div>
                <p className="text-sm text-slate-700 dark:text-[#e0f7fa] line-clamp-2">
                  {item.prompt}
                </p>
              </div>
              <div className="flex items-center gap-2 self-end sm:self-center flex-shrink-0">
                <button 
                  onClick={() => onLoad(item)}
                  className="p-2 rounded-md bg-indigo-500/10 dark:bg-indigo-400/20 text-indigo-600 dark:text-indigo-300 hover:bg-indigo-500/20 dark:hover:bg-indigo-400/30 transition-colors duration-200"
                  aria-label={t('loadPrompt')}
                >
                  <Eye size={18} />
                </button>
                <button 
                  onClick={() => onDelete(item.id)}
                  className="p-2 rounded-md bg-red-500/10 dark:bg-red-400/20 text-red-600 dark:text-red-300 hover:bg-red-500/20 dark:hover:bg-red-400/30 transition-colors duration-200"
                  aria-label={t('deletePrompt')}
                >
                  <Trash2 size={18} />
                </button>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
});

export default PromptHistoryDisplay;

/// src/components/prompt-crafter/PurposeSelector.tsx ///
// import React from 'react';
import React from 'react';
import { purposeKeys } from '../../constants/prompts';
import { useTranslations } from '../../i18n/useTranslations';

interface PurposeSelectorProps {
  purpose: string;
  setPurpose: (value: string) => void;
}
const PurposeSelector: React.FC<PurposeSelectorProps> = React.memo(({ purpose, setPurpose }) => {
  const { t } = useTranslations();
  const purposes = Object.keys(purposeKeys);

  return (
    <div className="mt-6">
      <label htmlFor="purpose-input" className="block text-lg font-medium text-sky-500 dark:text-[#00f0ff] mb-3 light-shadow-sky dark:neon-glow-cyan">{t('purposeLabel')}</label>
      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 mb-4">
        {purposes.map(p => (
          <button
            key={p}
            onClick={() => setPurpose(p)}
            className={`p-2 rounded-md text-sm font-medium border-2 transition-all duration-200 ${purpose === p
              ? 'bg-emerald-500/20 dark:bg-[#00e676]/20 border-emerald-500 dark:border-[#00e676] text-emerald-700 dark:text-white scale-105'
              : 'bg-slate-100 dark:bg-[#10151b]/50 border-transparent hover:border-emerald-500/50 dark:hover:border-[#00e676]/50 text-slate-600 dark:text-slate-300'
              }`}
          >
            {t(purposeKeys[p])}
          </button>
        ))}
      </div>
      <input
        id="purpose-input"
        type="text"
        value={purpose}
        onChange={(e) => setPurpose(e.target.value)}
        list="purposes-list"
        placeholder={t('customPurposePlaceholder')}
        className="w-full bg-white dark:bg-[#10151b] border-2 border-emerald-500/50 dark:border-[#00e676]/30 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-emerald-500 dark:focus:ring-[#00e676] focus:border-emerald-500 dark:focus:border-[#00e676] transition-all duration-300 placeholder:text-slate-400 dark:placeholder:text-[#90a4ae]/50 text-emerald-600 dark:text-[#00e676] font-semibold"
      />
      <datalist id="purposes-list">
        {purposes.map(p => <option key={p} value={p} />)}
      </datalist>
    </div>
  );
});

export default PurposeSelector;

/// src/constants/prompts.ts ///
export interface Example {
  purpose: string;
  ideas: string[];
}

export const examples: Example[] = [
  {
    purpose: "Code Generation",
    ideas: [
      "Create a React hook for fetching data from an API.",
      "It should handle loading, error, and data states.",
      "Use the native `fetch` API.",
      "The hook should be written in TypeScript and be well-documented.",
    ],
  },
  {
    purpose: "Creative Writing",
    ideas: [
      "Write a short story opening.",
      "The setting is a neon-lit cyberpunk city in 2077.",
      "The main character is a grizzled detective who is part-cyborg.",
      "It's perpetually raining and the streets are reflective.",
    ],
  },
  {
    purpose: "Data Analysis",
    ideas: [
      "Analyze a dataset of customer sales from the last quarter.",
      "The dataset includes columns: 'Date', 'CustomerID', 'ProductCategory', 'Revenue', 'UnitsSold'.",
      "Identify the top 3 product categories by total revenue.",
      "Calculate the average revenue per customer.",
      "Look for any weekly sales trends or seasonality.",
    ],
  },
  {
    purpose: "Marketing Copy",
    ideas: [
      "Draft an email campaign for a new productivity app.",
      "The target audience is busy professionals and university students.",
      "Highlight features like AI-powered task scheduling, calendar sync, and focus mode.",
      "The tone should be encouraging, professional, and slightly urgent.",
    ],
  },
  {
    purpose: "Technical Documentation",
    ideas: [
        "Write the 'Getting Started' section for a new JavaScript library.",
        "The library is called 'ChronoWarp' and it simplifies date manipulation.",
        "Include a simple installation guide using npm.",
        "Provide a clear, concise code example for its primary use case."
    ]
  }
];

export const purposeKeys: Record<string, string> = {
  "Code Generation": "purposeCodeGeneration",
  "Creative Writing": "purposeCreativeWriting",
  "Data Analysis": "purposeDataAnalysis",
  "Technical Documentation": "purposeTechnicalDocumentation",
  "Marketing Copy": "purposeMarketingCopy",
  "General Summarization": "purposeGeneralSummarization",
};

/// src/context/LanguageContext.tsx ///
import { createContext } from 'react';
import { Language } from '../types';

export interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
  t: (key: string, params?: Record<string, string>) => string;
}

export const LanguageContext = createContext<LanguageContextType>({
  language: 'en',
  setLanguage: () => {},
  t: (key) => key,
});

/// src/hooks/useAutosaveDraft.ts ///
import { useState, useEffect, useRef } from 'react';
import { Idea } from '../types';
import { getDraft, saveDraft } from '../services/storageService';

export const useAutosaveDraft = () => {
    const [ideas, setIdeas] = useState<Idea[]>([]);
    const [purpose, setPurpose] = useState('Code Generation');
    const isInitialLoad = useRef(true);

    // Load draft from storage service on mount
    useEffect(() => {
        const loadDraft = async () => {
            try {
                const savedDraft = await getDraft();
                if (savedDraft) {
                    setIdeas(savedDraft.ideas);
                    setPurpose(savedDraft.purpose);
                }
            } catch (e) {
                console.error("Failed to load draft from storage service", e);
            } finally {
                isInitialLoad.current = false;
            }
        };
        loadDraft();
    }, []);

    // Save draft to storage service on changes
    useEffect(() => {
        if (isInitialLoad.current) {
            return;
        }
        const handler = setTimeout(() => {
            try {
                saveDraft({ ideas, purpose });
            } catch (e) {
                console.error("Failed to save draft via storage service", e);
            }
        }, 500);
        return () => clearTimeout(handler);
    }, [ideas, purpose]);

    return { ideas, setIdeas, purpose, setPurpose };
};

/// src/hooks/useLanguage.ts ///
import { useState, useEffect } from 'react';
import { Language } from '../types';
import { translations } from '../i18n/translations';

export const useLanguage = () => {
  const [language, setLanguage] = useState<Language>('en');

  useEffect(() => {
    try {
      const savedLang = localStorage.getItem('language') as Language | null;
      const browserLang = navigator.language.split('-')[0] as Language;
      const initialLang = savedLang || (['en', 'es', 'zh', 'pt'].includes(browserLang) ? browserLang : 'en');
      setLanguage(initialLang);
    } catch (error) {
        console.warn('Could not access localStorage to get language. Using default.', error);
        // Fallback to browser language if localStorage is not available
        const browserLang = navigator.language.split('-')[0] as Language;
        setLanguage((['en', 'es', 'zh', 'pt'].includes(browserLang) ? browserLang : 'en'));
    }
  }, []);

  useEffect(() => {
    try {
      localStorage.setItem('language', language);
    } catch (error) {
      console.warn('Could not access localStorage to save language.', error);
    }
  }, [language]);

  const t = (key: string, params?: Record<string, string>): string => {
    let translation = translations[language][key] || translations.en[key] || key;
    if (params) {
      Object.keys(params).forEach(paramKey => {
        translation = translation.replace(`{${paramKey}}`, params[paramKey]);
      });
    }
    return translation;
  };

  return { language, setLanguage, t };
};

/// src/hooks/usePromptHistory.ts ///
import { useState, useEffect, useCallback } from 'react';
import { HistoryItem } from '../types';
import { getHistory, saveHistory } from '../services/storageService';

export const usePromptHistory = () => {
    const [promptHistory, setPromptHistory] = useState<HistoryItem[]>([]);

    // Load history from the storage service on initial render
    useEffect(() => {
        const loadHistory = async () => {
            const history = await getHistory();
            setPromptHistory(history);
        };
        loadHistory();
    }, []);

    // Save history to the storage service whenever it changes
    useEffect(() => {
        // Avoid saving on initial empty state before anything is loaded
        if (promptHistory.length === 0) {
            const checkStorage = async () => {
                const existing = await getHistory();
                if (existing.length === 0) return;
                saveHistory(promptHistory);
            }
            checkStorage();
        } else {
             saveHistory(promptHistory);
        }
    }, [promptHistory]);

    const deleteFromHistory = useCallback((id: string) => {
        setPromptHistory(prev => prev.filter(item => item.id !== id));
    }, []);

    const clearHistory = useCallback(() => {
        setPromptHistory([]);
        // The useEffect will handle saving the empty array
    }, []);

    return { promptHistory, setPromptHistory, deleteFromHistory, clearHistory };
};

/// src/hooks/useTheme.ts ///
import { useState, useEffect } from 'react';
import { Theme } from '../types';

export const useTheme = (): [Theme, () => void] => {
  const [theme, setTheme] = useState<Theme>('dark');

  useEffect(() => {
    try {
      const savedTheme = localStorage.getItem('theme') as Theme | null;
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
      setTheme(initialTheme);
    } catch (error) {
      console.warn('Could not access localStorage to get theme. Using default.', error);
      // Fallback to prefers-color-scheme if localStorage is not available
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      setTheme(prefersDark ? 'dark' : 'light');
    }
  }, []);

  useEffect(() => {
    try {
      const root = window.document.documentElement;
      const body = window.document.body;
      root.classList.remove('light', 'dark');
      root.classList.add(theme);
      body.classList.remove('light-theme', 'dark-theme');
      body.classList.add(`${theme}-theme`);
      localStorage.setItem('theme', theme);
    } catch (error) {
      console.warn('Could not access localStorage to save theme.', error);
    }
  }, [theme]);

  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return [theme, toggleTheme];
};

/// src/hooks/useUrlSharing.ts ///
import { useEffect } from 'react';
import { Idea } from '../types';

interface UseUrlSharingProps {
    setIdeas: (ideas: Idea[]) => void;
    setPurpose: (purpose: string) => void;
    setGeneratedPrompt: (prompt: string) => void;
    setTokenUsage: (usage: null) => void;
    setError: (error: string | null) => void;
}

export const useUrlSharing = ({ setIdeas, setPurpose, setGeneratedPrompt, setTokenUsage, setError }: UseUrlSharingProps) => {
    useEffect(() => {
        const loadSharedPrompt = () => {
            try {
                const hash = window.location.hash;
                if (hash.startsWith('#prompt=')) {
                    const encodedData = hash.substring('#prompt='.length);
                    const decodedJson = atob(encodedData);
                    const data = JSON.parse(decodedJson) as { ideas: Idea[], purpose: string, prompt: string };

                    if (data.ideas && data.purpose && data.prompt) {
                        setIdeas(data.ideas);
                        setPurpose(data.purpose);
                        setGeneratedPrompt(data.prompt);
                        setTokenUsage(null); // Tokens are not shared in link
                        setError(null);
                        window.history.replaceState(null, document.title, window.location.pathname + window.location.search);
                    }
                }
            } catch (e) {
                console.error("Failed to parse shared prompt from URL", e);
                setError("The shared link appears to be invalid or corrupted.");
                window.history.replaceState(null, document.title, window.location.pathname + window.location.search);
            }
        };
        loadSharedPrompt();
    }, [setIdeas, setPurpose, setGeneratedPrompt, setTokenUsage, setError]);
};

/// src/i18n/translations.ts ///
import { Language } from '../types';

export const translations: Record<Language, Record<string, string>> = {
  en: {
    'promptCrafter': 'AI Prompt Crafter',
    'toggleTheme': 'Switch to {theme} mode',
    'poweredBy': 'Kubex Principles: Radical Simplicity, No Cages.',
    'motto': 'CODE FAST. OWN EVERYTHING.',
    "inputIdeasTitle": "1. INPUT IDEAS",
    "loadExample": "Load Example",
    "ideaPlaceholder": "Enter a raw idea, concept, or requirement...",
    "addIdea": "Add Idea",
    "removeIdea": "Remove idea: {idea}",
    "purposeLabel": "Purpose",
    "purposeCodeGeneration": "Code Generation",
    "purposeCreativeWriting": "Creative Writing",
    "purposeDataAnalysis": "Data Analysis",
    "purposeTechnicalDocumentation": "Technical Documentation",
    "purposeMarketingCopy": "Marketing Copy",
    "purposeGeneralSummarization": "General Summarization",
    "customPurposePlaceholder": "Or type a custom purpose...",
    "generatedPromptTitle": "2. GENERATED PROMPT",
    "generatingMessage": "Generating with Gemini...",
    "generationFailedTitle": "Generation Failed",
    "close": "Close",
    "toggleView": "Toggle view mode",
    "copyLink": "Copy shareable link",
    "copyPrompt": "Copy prompt text",
    "copyCode": "Copy code",
    "copied": "Copied!",
    "promptPlaceholder": "Your professional prompt will appear here.",
    "generateButton": "GENERATE PROMPT",
    "generatingButton": "GENERATING...",
    "historyTitle": "3. PROMPT HISTORY",
    "clearAll": "Clear All",
    "historyPlaceholder": "Your generated prompts will be saved here.",
    "loadPrompt": "Load this prompt",
    "deletePrompt": "Delete this prompt",
    "errorAddIdea": "Please add at least one idea before generating.",
    "errorSpecifyPurpose": "Please specify a purpose for the prompt before generating.",
    "tokens": "tokens",
    "input": "Input",
    "output": "Output",
    "total": "Total",
    "lang_en": "English",
    "lang_es": "Espa√±ol",
    "lang_zh": "‰∏≠Êñá",
    "lang_pt": "Portugu√™s",
    "apiKeyMissingTitle": "Demo Mode Active",
    "apiKeyMissingText": "Running in demo mode with simulated AI responses. Connect your Gemini API key for enhanced AI-powered prompts.",
    "demoModeNote": "This prompt was generated in demo mode. Connect your Gemini API key for AI-enhanced results.",
  },
  es: {
    'promptCrafter': 'Creador de Prompts con IA',
    'toggleTheme': 'Cambiar a modo {theme}',
    'poweredBy': 'Principios de Kubex: Simplicidad Radical, Sin Jaulas.',
    'motto': 'CODIFICA R√ÅPIDO. S√â DUE√ëO DE TODO.',
    "inputIdeasTitle": "1. INGRESAR IDEAS",
    "loadExample": "Cargar Ejemplo",
    "ideaPlaceholder": "Introduce una idea, concepto o requisito...",
    "addIdea": "A√±adir Idea",
    "removeIdea": "Quitar idea: {idea}",
    "purposeLabel": "Prop√≥sito",
    "purposeCodeGeneration": "Generaci√≥n de C√≥digo",
    "purposeCreativeWriting": "Escritura Creativa",
    "purposeDataAnalysis": "An√°lisis de Datos",
    "purposeTechnicalDocumentation": "Documentaci√≥n T√©cnica",
    "purposeMarketingCopy": "Copy de Marketing",
    "purposeGeneralSummarization": "Resumen General",
    "customPurposePlaceholder": "O escribe un prop√≥sito personalizado...",
    "generatedPromptTitle": "2. PROMPT GENERADO",
    "generatingMessage": "Generando con Gemini...",
    "generationFailedTitle": "Fall√≥ la Generaci√≥n",
    "close": "Cerrar",
    "toggleView": "Cambiar vista",
    "copyLink": "Copiar enlace para compartir",
    "copyPrompt": "Copiar texto del prompt",
    "copyCode": "Copiar c√≥digo",
    "copied": "¬°Copiado!",
    "promptPlaceholder": "Tu prompt profesional aparecer√° aqu√≠.",
    "generateButton": "GENERAR PROMPT",
    "generatingButton": "GENERANDO...",
    "historyTitle": "3. HISTORIAL DE PROMPTS",
    "clearAll": "Limpiar Todo",
    "historyPlaceholder": "Tus prompts generados se guardar√°n aqu√≠.",
    "loadPrompt": "Cargar este prompt",
    "deletePrompt": "Eliminar este prompt",
    "errorAddIdea": "Por favor, a√±ade al menos una idea antes de generar.",
    "errorSpecifyPurpose": "Por favor, especifica un prop√≥sito para el prompt antes de generar.",
    "tokens": "tokens",
    "input": "Entrada",
    "output": "Salida",
    "total": "Total",
    "lang_en": "English",
    "lang_es": "Espa√±ol",
    "lang_zh": "‰∏≠Êñá",
    "lang_pt": "Portugu√™s",
    "apiKeyMissingTitle": "Modo Demo Activo",
    "apiKeyMissingText": "Ejecut√°ndose en modo demo con respuestas de IA simuladas. Conecta tu clave API de Gemini para prompts mejorados con IA.",
    "demoModeNote": "Este prompt fue generado en modo demo. Conecta tu clave API de Gemini para resultados mejorados con IA.",
  },
  zh: {
    'promptCrafter': 'AI ÊèêÁ§∫ËØçÊûÑÂª∫Âô®',
    'toggleTheme': 'ÂàáÊç¢Âà∞{theme}Ê®°Âºè',
    'poweredBy': 'Kubex ÂéüÂàôÔºöÊûÅËá¥ÁÆÄÁ∫¶ÔºåÊó†ÊãòÊó†Êùü„ÄÇ',
    'motto': 'Âø´ÈÄüÁºñÁ†Å„ÄÇÊã•Êúâ‰∏ÄÂàá„ÄÇ',
    "inputIdeasTitle": "1. ËæìÂÖ•ÊÉ≥Ê≥ï",
    "loadExample": "Âä†ËΩΩÁ§∫‰æã",
    "ideaPlaceholder": "ËæìÂÖ•‰∏Ä‰∏™ÂéüÂßãÊÉ≥Ê≥ï„ÄÅÊ¶ÇÂøµÊàñË¶ÅÊ±Ç...",
    "addIdea": "Ê∑ªÂä†ÊÉ≥Ê≥ï",
    "removeIdea": "Âà†Èô§ÊÉ≥Ê≥ï: {idea}",
    "purposeLabel": "ÁõÆÁöÑ",
    "purposeCodeGeneration": "‰ª£Á†ÅÁîüÊàê",
    "purposeCreativeWriting": "ÂàõÊÑèÂÜô‰Ωú",
    "purposeDataAnalysis": "Êï∞ÊçÆÂàÜÊûê",
    "purposeTechnicalDocumentation": "ÊäÄÊúØÊñáÊ°£",
    "purposeMarketingCopy": "Ëê•ÈîÄÊñáÊ°à",
    "purposeGeneralSummarization": "ÈÄöÁî®ÊÄªÁªì",
    "customPurposePlaceholder": "ÊàñËæìÂÖ•Ëá™ÂÆö‰πâÁõÆÁöÑ...",
    "generatedPromptTitle": "2. ÁîüÊàêÁöÑÊèêÁ§∫",
    "generatingMessage": "Ê≠£Âú®ÈÄöËøá Gemini ÁîüÊàê...",
    "generationFailedTitle": "ÁîüÊàêÂ§±Ë¥•",
    "close": "ÂÖ≥Èó≠",
    "toggleView": "ÂàáÊç¢ËßÜÂõæ",
    "copyLink": "Â§çÂà∂ÂàÜ‰∫´ÈìæÊé•",
    "copyPrompt": "Â§çÂà∂ÊèêÁ§∫ÊñáÊú¨",
    "copyCode": "Â§çÂà∂‰ª£Á†Å",
    "copied": "Â∑≤Â§çÂà∂ÔºÅ",
    "promptPlaceholder": "ÊÇ®ÁöÑ‰∏ì‰∏öÊèêÁ§∫Â∞ÜÂá∫Áé∞Âú®ËøôÈáå„ÄÇ",
    "generateButton": "ÁîüÊàêÊèêÁ§∫",
    "generatingButton": "Ê≠£Âú®ÁîüÊàê...",
    "historyTitle": "3. ÊèêÁ§∫ÂéÜÂè≤",
    "clearAll": "ÂÖ®ÈÉ®Ê∏ÖÈô§",
    "historyPlaceholder": "ÊÇ®ÁîüÊàêÁöÑÊèêÁ§∫Â∞Ü‰øùÂ≠òÂú®ËøôÈáå„ÄÇ",
    "loadPrompt": "Âä†ËΩΩÊ≠§ÊèêÁ§∫",
    "deletePrompt": "Âà†Èô§Ê≠§ÊèêÁ§∫",
    "errorAddIdea": "ÁîüÊàêÂâçËØ∑Ëá≥Â∞ëÊ∑ªÂä†‰∏Ä‰∏™ÊÉ≥Ê≥ï„ÄÇ",
    "errorSpecifyPurpose": "ÁîüÊàêÂâçËØ∑‰∏∫ÊèêÁ§∫ÊåáÂÆö‰∏Ä‰∏™ÁõÆÁöÑ„ÄÇ",
    "tokens": "‰∏™ token",
    "input": "ËæìÂÖ•",
    "output": "ËæìÂá∫",
    "total": "ÊÄªËÆ°",
    "lang_en": "English",
    "lang_es": "Espa√±ol",
    "lang_zh": "‰∏≠Êñá",
    "lang_pt": "Portugu√™s",
    "apiKeyMissingTitle": "ÊºîÁ§∫Ê®°ÂºèÊøÄÊ¥ª",
    "apiKeyMissingText": "Ê≠£Âú®ÊºîÁ§∫Ê®°Âºè‰∏ãËøêË°åÔºå‰ΩøÁî®Ê®°Êãü AI ÂìçÂ∫î„ÄÇËøûÊé•ÊÇ®ÁöÑ Gemini API ÂØÜÈí•‰ª•Ëé∑ÂæóÂ¢ûÂº∫ÁöÑ AI ÊèêÁ§∫„ÄÇ",
    "demoModeNote": "Ê≠§ÊèêÁ§∫Âú®ÊºîÁ§∫Ê®°Âºè‰∏ãÁîüÊàê„ÄÇËøûÊé•ÊÇ®ÁöÑ Gemini API ÂØÜÈí•‰ª•Ëé∑Âæó AI Â¢ûÂº∫ÁöÑÁªìÊûú„ÄÇ",
  },
  pt: {
    'promptCrafter': 'Criador de Prompts IA',
    'toggleTheme': 'Alternar para modo {theme}',
    'poweredBy': 'Princ√≠pios Kubex: Simplicidade Radical, Sem Jaulas.',
    'motto': 'CODIFIQUE R√ÅPIDO. SEJA DONO DE TUDO.',
    "inputIdeasTitle": "1. INSIRA AS IDEIAS",
    "loadExample": "Carregar Exemplo",
    "ideaPlaceholder": "Digite uma ideia, conceito ou requisito...",
    "addIdea": "Adicionar Ideia",
    "removeIdea": "Remover ideia: {idea}",
    "purposeLabel": "Prop√≥sito",
    "purposeCodeGeneration": "Gera√ß√£o de C√≥digo",
    "purposeCreativeWriting": "Escrita Criativa",
    "purposeDataAnalysis": "An√°lise de Dados",
    "purposeTechnicalDocumentation": "Documenta√ß√£o T√©cnica",
    "purposeMarketingCopy": "Copy de Marketing",
    "purposeGeneralSummarization": "Resumo Geral",
    "customPurposePlaceholder": "Ou digite um prop√≥sito personalizado...",
    "generatedPromptTitle": "2. PROMPT GERADO",
    "generatingMessage": "Gerando com Gemini...",
    "generationFailedTitle": "Falha na Gera√ß√£o",
    "close": "Fechar",
    "toggleView": "Alternar visualiza√ß√£o",
    "copyLink": "Copiar link compartilh√°vel",
    "copyPrompt": "Copiar texto do prompt",
    "copyCode": "Copiar c√≥digo",
    "copied": "Copiado!",
    "promptPlaceholder": "Seu prompt profissional aparecer√° aqui.",
    "generateButton": "GERAR PROMPT",
    "generatingButton": "GERANDO...",
    "historyTitle": "3. HIST√ìRICO DE PROMPTS",
    "clearAll": "Limpar Tudo",
    "historyPlaceholder": "Seus prompts gerados ser√£o salvos aqui.",
    "loadPrompt": "Carregar este prompt",
    "deletePrompt": "Excluir este prompt",
    "errorAddIdea": "Por favor, adicione pelo menos uma ideia antes de gerar.",
    "errorSpecifyPurpose": "Por favor, especifique um prop√≥sito para o prompt antes de gerar.",
    "tokens": "tokens",
    "input": "Entrada",
    "output": "Sa√≠da",
    "total": "Total",
    "lang_en": "English",
    "lang_es": "Espa√±ol",
    "lang_zh": "‰∏≠Êñá",
    "lang_pt": "Portugu√™s",
    "apiKeyMissingTitle": "Modo Demo Ativo",
    "apiKeyMissingText": "Executando em modo demo com respostas simuladas de IA. Conecte sua chave API do Gemini para prompts aprimorados com IA.",
    "demoModeNote": "Este prompt foi gerado em modo demo. Conecte sua chave API do Gemini para resultados aprimorados com IA.",
  }
};

/// src/i18n/useTranslations.ts ///
import { useContext } from 'react';
import { LanguageContext, LanguageContextType } from '../context/LanguageContext';

export const useTranslations = (): Omit<LanguageContextType, 'setLanguage'> => {
  const { language, t } = useContext(LanguageContext);
  return { language, t };
};

/// src/lib/db.ts ///


/// src/lib/time.ts ///
export const formatRelativeTime = (timestamp: number, locale: string): string => {
    try {
        const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
        const seconds = Math.floor((Date.now() - timestamp) / 1000);

        if (seconds < 60) return rtf.format(Math.floor(-seconds), 'second');
        if (seconds < 3600) return rtf.format(-Math.floor(seconds / 60), 'minute');
        if (seconds < 86400) return rtf.format(-Math.floor(seconds / 3600), 'hour');
        if (seconds < 2592000) return rtf.format(-Math.floor(seconds / 86400), 'day');
        if (seconds < 31536000) return rtf.format(-Math.floor(seconds / 2592000), 'month');
        return rtf.format(-Math.floor(seconds / 31536000), 'year');
    } catch (e) {
        console.error("Error formatting relative time", e);
        return new Date(timestamp).toLocaleDateString();
    }
};

/// src/services/analytics.ts ///
import { useEffect } from 'react';

interface AnalyticsEvent {
  action: string;
  category: string;
  label?: string;
  value?: number;
}

// Simple, privacy-first analytics
class KubexAnalytics {
  private static instance: KubexAnalytics;
  private isEnabled: boolean = false;

  private constructor() {
    // Only enable in production
    this.isEnabled = window.location.hostname === 'kubex.world';
  }

  public static getInstance(): KubexAnalytics {
    if (!KubexAnalytics.instance) {
      KubexAnalytics.instance = new KubexAnalytics();
    }
    return KubexAnalytics.instance;
  }

  public track(event: AnalyticsEvent): void {
    if (!this.isEnabled) return;

    // Simple privacy-first tracking - no personal data
    const data = {
      ...event,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent.substring(0, 100), // Truncated for privacy
      referrer: document.referrer || 'direct',
      url: window.location.pathname,
    };

    // Send to your own analytics endpoint or console log for now
    console.log('üìä Analytics:', data);

    // You can later integrate with privacy-focused analytics like:
    // - Plausible Analytics
    // - Fathom Analytics
    // - Your own endpoint
  }

  public trackPageView(): void {
    this.track({
      action: 'page_view',
      category: 'navigation',
      label: window.location.pathname,
    });
  }

  public trackPromptGeneration(mode: 'demo' | 'api'): void {
    this.track({
      action: 'prompt_generated',
      category: 'user_interaction',
      label: mode,
    });
  }

  public trackApiKeyConnected(): void {
    this.track({
      action: 'api_key_connected',
      category: 'user_interaction',
    });
  }

  public trackLanguageChange(language: string): void {
    this.track({
      action: 'language_changed',
      category: 'user_preference',
      label: language,
    });
  }

  public trackThemeToggle(theme: string): void {
    this.track({
      action: 'theme_toggled',
      category: 'user_preference',
      label: theme,
    });
  }
}

export const analytics = KubexAnalytics.getInstance();

// Hook for easy usage in components
export const useAnalytics = () => {
  useEffect(() => {
    analytics.trackPageView();
  }, []);

  return analytics;
};

export default analytics;

/// src/services/geminiService.ts ///
import { GenerateContentResponse, GoogleGenAI } from "@google/genai";
import { Idea } from '../types';

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  console.warn("Gemini API key not found. Using mock data. Please set the API_KEY environment variable.");
}

const ai = new GoogleGenAI({ apiKey: API_KEY! });
// FIX: Updated model to 'gemini-2.5-flash' to comply with guidelines.
const model = 'gemini-2.5-flash';

export interface PromptGenerationResult {
  prompt: string;
  usageMetadata?: {
    promptTokenCount?: number;
    candidatesTokenCount?: number;
    totalTokenCount?: number;
  };
}

const createMetaPrompt = (ideas: Idea[], purpose: string): string => {
  const ideasText = ideas.map((idea, index) => `- ${idea.text}`).join('\n');

  return `
You are a world-class prompt engineering expert, a key copilot in the Kubex Ecosystem. Your mission is to transform a user's raw, unstructured ideas into a clean, effective, and professional prompt for large language models, adhering strictly to Kubex principles.

**KUBEX PRINCIPLES:**
- **Simplicidade Radical:** The prompt must be direct, pragmatic, and anti-jargon. "One command = one result."
- **Modularidade:** The output should be well-structured and easily usable.
- **Sem Jaulas (No Cages):** The prompt should use open, clear formats (like Markdown) and not lock the user into a specific model's quirks.

**User's Raw Ideas:**
${ideasText}

**Desired Purpose of the Final Prompt:**
${purpose}

**Your Task:**
Based on the ideas and purpose provided, generate a single, comprehensive, and well-structured prompt in Markdown format. The generated prompt must be ready for immediate use.

**Key Directives:**
1.  **Define a Persona:** Start the prompt by defining a clear, expert role for the AI (e.g., "You are an expert software architect specializing in cloud-native solutions...").
2.  **State the Objective:** Clearly articulate the main goal of the prompt in a "Primary Objective" section.
3.  **Provide Structure:** Use Markdown (headings, lists, bold text) to create a logical and readable structure. Use sections like "Requirements", "Expected Output", "Constraints", and "Context".
4.  **List Key Requirements:** Systematically break down the user's ideas into specific, actionable requirements in a bulleted list.
5.  **Specify Output Format:** If applicable, describe the desired output format (e.g., JSON schema, code block with language specifier, table).
6.  **Include Constraints:** Add any negative constraints or things to avoid (e.g., "Do not use libraries outside the standard library.").
7.  **Add Context:** If implied by the ideas, add a "Context" section to provide background that will help the AI generate a better response.

**OUTPUT CONTRACT:**
Return ONLY the generated prompt in Markdown. Do not include any introductory text, explanations, or concluding remarks like "Here is the prompt:". Your response must start directly with the Markdown content of the prompt (e.g., starting with a '# Title' or '**Persona:**').
`;
};

const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 1000;

/**
 * Checks if an error is likely a transient network issue and thus retryable.
 * @param error The error object.
 * @returns True if the error is retryable, false otherwise.
 */
const isRetryableError = (error: any): boolean => {
  const errorMessage = (error?.message || '').toLowerCase();
  // Simple check for network-related errors.
  return errorMessage.includes('fetch') || errorMessage.includes('network');
};

/**
 * Formats an API error into a user-friendly string.
 * @param error The error object from the API call.
 * @returns A user-friendly error message string.
 */
const formatApiError = (error: any): string => {
  // Keep a detailed log for developers
  console.error("Gemini API Error:", error);

  if (error instanceof Error) {
    // Provide a more specific message for common, user-actionable errors.
    if (error.message.includes('API key not valid')) {
      return 'API Configuration Error: The API key is not valid. Please contact the administrator.';
    }
    // For other errors, provide a message that includes the API's feedback.
    return `An error occurred: ${error.message}. Please check your input or try again. If the issue persists, it may be a network problem.`;
  }

  return "An unknown error occurred while communicating with the Gemini API. Please check your connection and try again.";
};


export const generateStructuredPrompt = async (ideas: Idea[], purpose: string): Promise<PromptGenerationResult> => {
  if (!API_KEY) {
    // Mock response for environments without an API key
    await new Promise(resolve => setTimeout(resolve, 1500));
    const ideasText = ideas.map((idea, index) => `- ${idea.text}`).join('\n');
    const mockPrompt = `
**Persona:** You are a mock AI assistant.

**Primary Objective:** Demonstrate a structured prompt based on user input.

**Context:** This is a mock response because the Gemini API key is not configured.

**User's Ideas Provided:**
${ideasText}

**Stated Purpose:**
${purpose}

**Expected Output (Mock):**
- A well-formatted response that addresses each of the user's ideas.
- Clear structure using Markdown.
- Adherence to the requested purpose.
`;
    // Mock token counts
    const inputTokens = Math.floor(mockPrompt.length / 4);
    const outputTokens = Math.floor(ideasText.length / 4);

    return {
      prompt: mockPrompt,
      usageMetadata: {
        promptTokenCount: inputTokens,
        candidatesTokenCount: outputTokens,
        totalTokenCount: inputTokens + outputTokens
      }
    };
  }

  let lastError: any = null;

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      const metaPrompt = createMetaPrompt(ideas, purpose);
      const response: GenerateContentResponse = await ai.models.generateContent({
        model: model,
        contents: metaPrompt,
        config: {
          temperature: 0.3,
          topP: 0.9,
          topK: 40,
        }
      });
      return {
        // FIX: Using response.text directly as per Gemini API guidelines.
        prompt: response.text || '',
        usageMetadata: response.usageMetadata
      };
    } catch (error) {
      lastError = error;
      if (isRetryableError(error) && attempt < MAX_RETRIES) {
        console.warn(`API call failed (attempt ${attempt}/${MAX_RETRIES}), retrying after delay...`);
        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * attempt)); // Simple exponential backoff
      } else {
        // Not a retryable error or max retries reached
        throw new Error(formatApiError(error));
      }
    }
  }
  // This fallback should ideally not be reached, but it's here for safety.
  throw new Error(formatApiError(lastError || new Error("Failed to generate prompt after multiple retries.")));
};

/// src/services/storageService.ts ///
import { HistoryItem, Draft } from '../types';

const DB_NAME = 'GromptDB';
const HISTORY_STORE = 'history';
const DRAFT_STORE = 'drafts';
const DB_VERSION = 1;

// LocalStorage fallback keys
const HISTORY_FALLBACK_KEY = 'history_fallback';
const DRAFT_FALLBACK_KEY = 'draft_fallback';

let dbPromise: Promise<IDBDatabase> | null = null;

const openDB = (): Promise<IDBDatabase> => {
  if (dbPromise) {
    return dbPromise;
  }
  dbPromise = new Promise((resolve, reject) => {
    try {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onerror = () => {
        console.warn("IndexedDB could not be opened. It might be blocked or unavailable.");
        reject(new Error("IndexedDB unavailable"));
      };
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains(HISTORY_STORE)) {
          db.createObjectStore(HISTORY_STORE, { keyPath: 'id' });
        }
        if (!db.objectStoreNames.contains(DRAFT_STORE)) {
          db.createObjectStore(DRAFT_STORE);
        }
      };
    } catch (error) {
        console.error("Error initiating IndexedDB open request.", error);
        reject(error);
    }
  });
  return dbPromise;
};

const getFromStore = <T>(storeName: string, key: IDBValidKey): Promise<T | undefined> => {
    return openDB().then(db => {
        return new Promise<T | undefined>((resolve, reject) => {
            const transaction = db.transaction(storeName, 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(key);
            request.onerror = () => reject(new Error(`Error getting item ${key} from ${storeName}`));
            request.onsuccess = () => resolve(request.result as T | undefined);
        });
    });
};

const getAllFromStore = <T>(storeName: string): Promise<T[]> => {
    return openDB().then(db => {
        return new Promise<T[]>((resolve, reject) => {
            const transaction = db.transaction(storeName, 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            request.onerror = () => reject(new Error(`Error getting all items from ${storeName}`));
            request.onsuccess = () => resolve(request.result as T[]);
        });
    });
};

const putInStore = <T>(storeName: string, value: T, key?: IDBValidKey): Promise<void> => {
    return openDB().then(db => {
        return new Promise<void>((resolve, reject) => {
            const transaction = db.transaction(storeName, 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = key ? store.put(value, key) : store.put(value);
            request.onerror = () => reject(new Error(`Error putting item into ${storeName}`));
            request.onsuccess = () => resolve();
        });
    });
};

// --- History Persistence ---

export const saveHistory = async (history: HistoryItem[]): Promise<void> => {
    try {
        const db = await openDB();
        const transaction = db.transaction(HISTORY_STORE, 'readwrite');
        const store = transaction.objectStore(HISTORY_STORE);
        store.clear(); // Clear old history
        for (const item of history) {
            store.put(item); // Add new items
        }
    } catch (error) {
        console.warn('Failed to save history to IndexedDB, using localStorage fallback.', error);
        try {
            localStorage.setItem(HISTORY_FALLBACK_KEY, JSON.stringify(history));
        } catch (lsError) {
            console.error('Failed to save history to localStorage fallback.', lsError);
        }
    }
};

export const getHistory = async (): Promise<HistoryItem[]> => {
    try {
        const history = await getAllFromStore<HistoryItem>(HISTORY_STORE);
        return history.sort((a, b) => b.timestamp - a.timestamp);
    } catch (error) {
        console.warn('Failed to get history from IndexedDB, using localStorage fallback.', error);
        try {
            const storedHistory = localStorage.getItem(HISTORY_FALLBACK_KEY);
            return storedHistory ? JSON.parse(storedHistory) : [];
        } catch (lsError) {
            console.error('Failed to get history from localStorage fallback.', lsError);
            return [];
        }
    }
};

// --- Draft Persistence ---

export const saveDraft = async (draft: Draft): Promise<void> => {
    try {
        await putInStore(DRAFT_STORE, draft, 'currentDraft');
    } catch (error) {
        console.warn('Failed to save draft to IndexedDB, using localStorage fallback.', error);
        try {
            localStorage.setItem(DRAFT_FALLBACK_KEY, JSON.stringify(draft));
        } catch (lsError) {
            console.error('Failed to save draft to localStorage fallback.', lsError);
        }
    }
};

export const getDraft = async (): Promise<Draft | undefined> => {
    try {
        return await getFromStore<Draft>(DRAFT_STORE, 'currentDraft');
    } catch (error) {
        console.warn('Failed to get draft from IndexedDB, using localStorage fallback.', error);
        try {
            const storedDraft = localStorage.getItem(DRAFT_FALLBACK_KEY);
            return storedDraft ? JSON.parse(storedDraft) : undefined;
        } catch (lsError) {
            console.error('Failed to get draft from localStorage fallback.', lsError);
            return undefined;
        }
    }
};

// --- Initialization and Migration ---

const migrateFromLocalStorage = async () => {
    try {
        // Check for history fallback
        const historyFallback = localStorage.getItem(HISTORY_FALLBACK_KEY);
        if (historyFallback) {
            console.log('Found history in localStorage, migrating to IndexedDB...');
            const history: HistoryItem[] = JSON.parse(historyFallback);
            await saveHistory(history); // This will save to IndexedDB if available
            localStorage.removeItem(HISTORY_FALLBACK_KEY);
            console.log('History migration successful.');
        }

        // Check for draft fallback
        const draftFallback = localStorage.getItem(DRAFT_FALLBACK_KEY);
        if (draftFallback) {
            console.log('Found draft in localStorage, migrating to IndexedDB...');
            const draft: Draft = JSON.parse(draftFallback);
            await saveDraft(draft); // This will save to IndexedDB if available
            localStorage.removeItem(DRAFT_FALLBACK_KEY);
            console.log('Draft migration successful.');
        }
    } catch (error) {
        console.error('Failed to migrate data from localStorage to IndexedDB.', error);
    }
};


let isInitialized = false;
export const initStorage = () => {
    if (isInitialized) return;

    // Attempt to open DB and migrate on successful connection
    openDB()
        .then(() => {
            console.log("IndexedDB connection successful. Checking for migrations...");
            migrateFromLocalStorage();
        })
        .catch(err => {
            console.warn("IndexedDB is not available on initial load.", err.message);
        });

    isInitialized = true;
};

/// src/types/index.ts ///
export type Theme = 'light' | 'dark';
export type Language = 'en' | 'es' | 'zh' | 'pt';

export interface Idea {
  id: string;
  text: string;
}

export interface HistoryItem {
  id: string;
  prompt: string;
  purpose: string;
  ideas: Idea[];
  timestamp: number;
  inputTokens?: number;
  outputTokens?: number;
  totalTokens?: number;
}

export interface Draft {
  ideas: Idea[];
  purpose: string;
}

/// sw.js ///
const CACHE_NAME = 'grompt-cache-v1';
const urlsToCache = [
  '/',
  '/index.html',
  'https://cdn.tailwindcss.com',
  'https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=IBM+Plex+Mono:wght@400;500&display=swap'
];

self.addEventListener('install', event => {
  // Perform install steps
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Opened cache');
        // Add core app shell files to cache.
        // Other assets will be cached on-the-fly by the fetch handler.
        return cache.addAll(urlsToCache);
      })
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Cache hit - return response
        if (response) {
          return response;
        }

        // Not in cache - fetch from network
        return fetch(event.request).then(
          (networkResponse) => {
            // IMPORTANT: Clone the response. A response is a stream
            // and because we want the browser to consume the response
            // as well as the cache consuming the response, we need
            // to clone it so we have two streams.
            const responseToCache = networkResponse.clone();

            caches.open(CACHE_NAME)
              .then(cache => {
                // We don't cache POST requests or chrome-extension requests
                if (event.request.method !== 'GET' || event.request.url.startsWith('chrome-extension://')) {
                  return;
                }
                cache.put(event.request, responseToCache);
              });

            return networkResponse;
          }
        );
      }
      ).catch(() => {
        // Fallback for when both cache and network fail
        // You can return a custom offline page here if you have one.
      })
  );
});

// Clean up old caches
self.addEventListener('activate', event => {
  const cacheWhitelist = [CACHE_NAME];
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

/// tsconfig.json ///
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "types": [],
    "typeRoots": [
      "./node_modules/@types"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  },
  "exclude": [
    "node_modules",
    "dist",
    "build",
    "**/*.test.ts",
    "**/*.test.tsx"
  ],
  "ts-node": {
    "skipProject": true
  }
}

/// types.ts ///
// FIX: Removed self-import of Idea which conflicts with the interface declaration below.
export interface Idea {
  id: string;
  text: string;
}

export interface HistoryItem {
  id:string;
  prompt: string;
  purpose: string;
  ideas: Idea[];
  timestamp: number;
  inputTokens?: number;
  outputTokens?: number;
}

/// vite.config.ts ///
import path from 'path';
import { defineConfig, loadEnv } from 'vite';

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, '.', '');
  return {
    define: {
      /*

      Environment variables for the Application
      They are all prefixed with "process.env." to be compatible with libraries that expect this format.

      !!!!! DON'T LET THEM LEAK INTO THE FRONTEND CODE !!!!
      !!!!! THEY SHOULD ONLY BE USED IN SERVER-SIDE CODE !!!!!

      */
      'process.env.API_KEY': JSON.stringify(env.GRT_API_KEY || ''),
      'process.env.PORT': JSON.stringify(env.PORT || '3000'),
      'process.env.MAX_RETRIES': JSON.stringify(env.MAX_RETRIES || '3'),
      'process.env.RETRY_DELAY_MS': JSON.stringify(env.RETRY_DELAY_MS || '1000'),
      'process.env.DEBUG': JSON.stringify(env.DEBUG || 'false'),
      'process.env.TEST_MODE': JSON.stringify(env.TEST_MODE || 'false'),
      'process.env.LOG_LEVEL': JSON.stringify(env.LOG_LEVEL || 'info'),
      'process.env.SECURITY_ENABLED': JSON.stringify(env.SECURITY_ENABLED || 'true'),
      'process.env.RATE_LIMIT': JSON.stringify(env.RATE_LIMIT || '100'),
      'process.env.RATE_LIMIT_WINDOW': JSON.stringify(env.RATE_LIMIT_WINDOW || '1m'),

      // 'process.env.CORS_ORIGIN': JSON.stringify(env.CORS_ORIGIN || '*'),
      // 'process.env.CORS_CREDENTIALS': JSON.stringify(env.CORS_CREDENTIALS || 'true'),

      'process.env.OPENAI_API_KEY': JSON.stringify(env.OPENAI_API_KEY || ''),
      'process.env.CHATGPT_API_KEY': JSON.stringify(env.CHATGPT_API_KEY || ''),
      'process.env.ANTHROPIC_API_KEY': JSON.stringify(env.ANTHROPIC_API_KEY || ''),
      'process.env.DEEPSEEK_API_KEY': JSON.stringify(env.DEEPSEEK_API_KEY || ''),
      'process.env.OLLAMA_API_KEY': JSON.stringify(env.OLLAMA_API_KEY || ''),
      'process.env.OLLAMA_API_URL': JSON.stringify(env.OLLAMA_API_URL || ''),
      'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY || ''),

      // 'process.env.GOOGLE_AI_STUDIO_API_KEY': JSON.stringify(env.GOOGLE_AI_STUDIO_API_KEY || ''),
      // 'process.env.GOOGLE_ANALYTICS_API_KEY': JSON.stringify(env.GOOGLE_ANALYTICS_API_KEY || ''),

      // 'process.env.PINECONE_API_KEY': JSON.stringify(env.PINECONE_API_KEY || ''),
      // 'process.env.GITHUB_PAT_TOKEN': JSON.stringify(env.GITHUB_PAT_TOKEN || ''),

      // 'process.env.VITE_SUPABASE_URL': JSON.stringify(env.VITE_SUPABASE_URL || ''),
      // 'process.env.VITE_SUPABASE_ANON_KEY': JSON.stringify(env.VITE_SUPABASE_ANON_KEY || ''),
      // 'process.env.VITE_SUPABASE_SERVICE_ROLE_KEY': JSON.stringify(env.VITE_SUPABASE_SERVICE_ROLE_KEY || ''),
      // 'process.env.VITE_SUPABASE_BEARER_TOKEN': JSON.stringify(env.VITE_SUPABASE_BEARER_TOKEN || ''),
      // 'process.env.VITE_SUPABASE_FALLBACK_ENABLE': JSON.stringify(env.VITE_SUPABASE_FALLBACK_ENABLE || 'false'),
      // 'process.env.VITE_SUPABASE_FALLBACK_URL': JSON.stringify(env.VITE_SUPABASE_FALLBACK_URL || ''),
      // 'process.env.VITE_SUPABASE_FALLBACK_ANON_KEY': JSON.stringify(env.VITE_SUPABASE_FALLBACK_ANON_KEY || ''),

      // 'process.env.POSTGRES_HOST': JSON.stringify(env.POSTGRES_HOST || ''),
      // 'process.env.POSTGRES_PORT': JSON.stringify(env.POSTGRES_PORT || ''),
      // 'process.env.POSTGRES_USER': JSON.stringify(env.POSTGRES_USER || ''),
      // 'process.env.POSTGRES_PASSWORD': JSON.stringify(env.POSTGRES_PASSWORD || ''),
      // 'process.env.POSTGRES_DB': JSON.stringify(env.POSTGRES_DB || ''),
      // 'process.env.POSTGRES_SSL': JSON.stringify(env.POSTGRES_SSL || ''),
      // 'process.env.POSTGRES_MAX_CLIENTS': JSON.stringify(env.POSTGRES_MAX_CLIENTS || ''),

      // 'process.env.REDIS_HOST': JSON.stringify(env.REDIS_HOST || ''),
      // 'process.env.REDIS_PORT': JSON.stringify(env.REDIS_PORT || ''),
      // 'process.env.REDIS_PASSWORD': JSON.stringify(env.REDIS_PASSWORD || ''),
      // 'process.env.REDIS_SENTINEL_ENABLED': JSON.stringify(env.REDIS_SENTINEL_ENABLED || ''),
      // 'process.env.REDIS_SENTINEL_HOST': JSON.stringify(env.REDIS_SENTINEL_HOST || ''),
      // 'process.env.REDIS_SENTINEL_PORT': JSON.stringify(env.REDIS_SENTINEL_PORT || ''),
      // 'process.env.REDIS_SENTINEL_MASTER_NAME': JSON.stringify(env.REDIS_SENTINEL_MASTER_NAME || ''),

      // 'process.env.RABBITMQ_HOST': JSON.stringify(env.RABBITMQ_HOST || ''),
      // 'process.env.RABBITMQ_PORT': JSON.stringify(env.RABBITMQ_PORT || ''),
      // 'process.env.RABBITMQ_USER': JSON.stringify(env.RABBITMQ_USER || ''),
      // 'process.env.RABBITMQ_PASSWORD': JSON.stringify(env.RABBITMQ_PASSWORD || ''),
      // 'process.env.RABBITMQ_VHOST': JSON.stringify(env.RABBITMQ_VHOST || ''),
      // 'process.env.RABBITMQ_QUEUE_NAME': JSON.stringify(env.RABBITMQ_QUEUE_NAME || ''),
      // 'process.env.RABBITMQ_QUEUE_DURABLE': JSON.stringify(env.RABBITMQ_QUEUE_DURABLE || ''),
      // 'process.env.RABBITMQ_QUEUE_AUTO_DELETE': JSON.stringify(env.RABBITMQ_QUEUE_AUTO_DELETE || ''),

      // 'process.env.MONGODB_URI': JSON.stringify(env.MONGODB_URI || ''),
      // 'process.env.MONGODB_DB': JSON.stringify(env.MONGODB_DB || ''),
      // 'process.env.MONGODB_USER': JSON.stringify(env.MONGODB_USER || ''),
      // 'process.env.MONGODB_PASSWORD': JSON.stringify(env.MONGODB_PASSWORD || ''),
      // 'process.env.MONGODB_AUTH_SOURCE': JSON.stringify(env.MONGODB_AUTH_SOURCE || ''),
      // 'process.env.MONGODB_SSL': JSON.stringify(env.MONGODB_SSL || ''),
      // 'process.env.MONGODB_REPLICA_SET': JSON.stringify(env.MONGODB_REPLICA_SET || ''),
      // 'process.env.MONGODB_MAX_POOL_SIZE': JSON.stringify(env.MONGODB_MAX_POOL_SIZE || ''),
      // 'process.env.MONGODB_MIN_POOL_SIZE': JSON.stringify(env.MONGODB_MIN_POOL_SIZE || ''),
      // 'process.env.MONGODB_CONNECT_TIMEOUT_MS': JSON.stringify(env.MONGODB_CONNECT_TIMEOUT_MS || ''),
      // 'process.env.MONGODB_SOCKET_TIMEOUT_MS': JSON.stringify(env.MONGODB_SOCKET_TIMEOUT_MS || ''),
      // 'process.env.MONGODB_SERVER_SELECTION_TIMEOUT_MS': JSON.stringify(env.MONGODB_SERVER_SELECTION_TIMEOUT_MS || ''),
      // 'process.env.MONGODB_HEARTBEAT_FREQUENCY_MS': JSON.stringify(env.MONGODB_HEARTBEAT_FREQUENCY_MS || ''),

      // 'process.env.BACKUP_ENABLED': JSON.stringify(env.BACKUP_ENABLED || ''),
      // 'process.env.BACKUP_SCHEDULE': JSON.stringify(env.BACKUP_SCHEDULE || ''),
      // 'process.env.BACKUP_RETENTION': JSON.stringify(env.BACKUP_RETENTION || ''),
      // 'process.env.BACKUP_PATH': JSON.stringify(env.BACKUP_PATH || ''),

      // 'process.env.SMTP_HOST': JSON.stringify(env.SMTP_HOST || ''),
      // 'process.env.SMTP_PORT': JSON.stringify(env.SMTP_PORT || ''),
      // 'process.env.SMTP_USER': JSON.stringify(env.SMTP_USER || ''),
      // 'process.env.SMTP_PASSWORD': JSON.stringify(env.SMTP_PASSWORD || ''),
      // 'process.env.SMTP_FROM': JSON.stringify(env.SMTP_FROM || ''),
      // 'process.env.SMTP_FROM_NAME': JSON.stringify(env.SMTP_FROM_NAME || '')
    },
    resolve: {
      alias: {
        '@': path.resolve(__dirname, '.'),
      }
    },
    build: {
      rollupOptions: {
        output: {
          manualChunks: {
            vendor: [
              'react',
              'react-dom'
            ],
          },
        },
      },
      chunkSizeWarningLimit: 1512,
    },
  };
});
