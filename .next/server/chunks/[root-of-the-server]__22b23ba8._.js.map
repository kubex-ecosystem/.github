{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///srv/apps/LIFE/RAFA-MORI/rafa-mori/src/app/api/extract-project/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport JSZip from 'jszip';\n\n// Interface para resultados da extração\ninterface ParsedMarker {\n  filename: string;\n  content: string;\n  startLine: number;\n  endLine: number;\n}\n\ninterface ExtractionResults {\n  totalMarkers: number;\n  totalFiles: number;\n  totalBytes: number;\n  errors: Array<{ line: number; message: string }>;\n  markers: ParsedMarker[];\n}\n\n// Parser de marcadores (baseado na sua extensão)\nclass MarkerParser {\n  private readonly FS_CHAR = String.fromCharCode(28);\n  private readonly markerRegex = new RegExp(`^\\\\/\\\\/${this.FS_CHAR.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\/ (.+?) \\\\/${this.FS_CHAR.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\/\\\\/$`);\n\n  parseMarkedFile(filePath: string): ExtractionResults {\n    const results: ExtractionResults = {\n      totalMarkers: 0,\n      totalFiles: 0,\n      totalBytes: 0,\n      errors: [],\n      markers: []\n    };\n\n    try {\n      const content = fs.readFileSync(filePath, 'utf-8');\n      const lines = content.split('\\n');\n      \n      let currentMarker: Partial<ParsedMarker> | null = null;\n      let currentContent: string[] = [];\n      \n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        const lineNumber = i + 1;\n        \n        const markerMatch = line.match(this.markerRegex);\n        \n        if (markerMatch) {\n          // Salvar marcador anterior se existir\n          if (currentMarker && currentMarker.filename) {\n            const marker: ParsedMarker = {\n              filename: currentMarker.filename,\n              content: currentContent.join('\\n'),\n              startLine: currentMarker.startLine || 0,\n              endLine: lineNumber - 1\n            };\n            results.markers.push(marker);\n            results.totalBytes += marker.content.length;\n          }\n          \n          // Iniciar novo marcador\n          currentMarker = {\n            filename: markerMatch[1],\n            startLine: lineNumber + 1\n          };\n          currentContent = [];\n          results.totalMarkers++;\n        } else if (currentMarker) {\n          currentContent.push(line);\n        }\n      }\n      \n      // Salvar último marcador\n      if (currentMarker && currentMarker.filename) {\n        const marker: ParsedMarker = {\n          filename: currentMarker.filename,\n          content: currentContent.join('\\n'),\n          startLine: currentMarker.startLine || 0,\n          endLine: lines.length\n        };\n        results.markers.push(marker);\n        results.totalBytes += marker.content.length;\n      }\n      \n      results.totalFiles = results.markers.length;\n      \n    } catch (error) {\n      results.errors.push({\n        line: 0,\n        message: `Erro ao ler arquivo: ${error}`\n      });\n    }\n    \n    return results;\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  const projectFile = searchParams.get('project');\n  \n  if (!projectFile) {\n    return NextResponse.json({ error: 'Project file parameter required' }, { status: 400 });\n  }\n  \n  try {\n    const projectPath = path.join(process.cwd(), 'public', 'projects', projectFile);\n    \n    if (!fs.existsSync(projectPath)) {\n      return NextResponse.json({ error: 'Project file not found' }, { status: 404 });\n    }\n    \n    const parser = new MarkerParser();\n    const results = parser.parseMarkedFile(projectPath);\n    \n    return NextResponse.json({\n      success: true,\n      projectName: projectFile,\n      stats: {\n        totalFiles: results.totalFiles,\n        totalMarkers: results.totalMarkers,\n        totalBytes: results.totalBytes,\n        errors: results.errors\n      },\n      files: results.markers.map(marker => ({\n        path: marker.filename,\n        content: marker.content,\n        size: marker.content.length,\n        lines: marker.content.split('\\n').length\n      }))\n    });\n    \n  } catch (error) {\n    return NextResponse.json({ \n      error: 'Failed to process project', \n      details: error instanceof Error ? error.message : 'Unknown error' \n    }, { status: 500 });\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { projectFile, format = 'json' } = await request.json();\n    \n    if (!projectFile) {\n      return NextResponse.json({ error: 'Project file required' }, { status: 400 });\n    }\n    \n    const projectPath = path.join(process.cwd(), 'public', 'projects', projectFile);\n    \n    if (!fs.existsSync(projectPath)) {\n      return NextResponse.json({ error: 'Project file not found' }, { status: 404 });\n    }\n    \n    const parser = new MarkerParser();\n    const results = parser.parseMarkedFile(projectPath);\n    \n    if (format === 'zip') {\n      // Criar ZIP com todos os arquivos\n      const zip = new JSZip();\n      \n      results.markers.forEach(marker => {\n        zip.file(marker.filename, marker.content);\n      });\n      \n      const zipBuffer = await zip.generateAsync({ type: 'uint8array' });\n      const arrayBuffer = new ArrayBuffer(zipBuffer.length);\n      const view = new Uint8Array(arrayBuffer);\n      view.set(zipBuffer);\n      \n      return new Response(arrayBuffer, {\n        headers: {\n          'Content-Type': 'application/zip',\n          'Content-Disposition': `attachment; filename=\"${projectFile.replace('.txt', '')}.zip\"`\n        }\n      });\n    }\n    \n    return NextResponse.json({\n      success: true,\n      extracted: true,\n      projectName: projectFile,\n      stats: {\n        totalFiles: results.totalFiles,\n        totalMarkers: results.totalMarkers,\n        totalBytes: results.totalBytes\n      },\n      files: results.markers\n    });\n    \n  } catch (error) {\n    return NextResponse.json({ \n      error: 'Failed to extract project', \n      details: error instanceof Error ? error.message : 'Unknown error' \n    }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}