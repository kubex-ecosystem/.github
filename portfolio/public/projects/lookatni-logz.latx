# LookAtni Code - Gerado automaticamente
# Data: 2025-07-13T23:16:37.518Z
# Fonte: /srv/apps/KUBEX/logz/
# Total de arquivos: 40

/// CODE_OF_CONDUCT.md ///
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
discord.gg/CCBJsFHT.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
<https://www.contributor-covenant.org/version/2/0/code_of_conduct.html>.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
<https://www.contributor-covenant.org/faq>. Translations are available at
<https://www.contributor-covenant.org/translations>.>.

/// DIAG.md ///
graph TD
    CLI[CLI (cobra)] -->|calls| Factory[Factory Layer]
    Factory -->|SetLogger, Config| InternalConfig[internal Config]
    Factory -->|SetNotifier| InternalNotifier[internal Notifier]
    InternalConfig -->|Log, Debug, Info| CoreLogger[Core Logger Logic]
    InternalNotifier -->|Alert, Notify| NotifierMgr[Notifier Manager]
    CoreLogger -->|Write JSON/Text| Writer[log writer & format]
    NotifierMgr -->|Send HTTP/Prometheus| PromHTTP[Prometheus HTTP endpoint]
    CLI -->|can import as lib| CoreLogger
    Writer -->|Outputs| Output[Console, File, etc.]
    PromHTTP -->|/metrics| Output

/// NOTICE.md ///
# NOTICE

This software is licensed under the MIT License. Below are additional notes on usage and attribution:

## Attribution Requirement (Optional)

- When distributing or using this software, please provide credit to the original author(s) in one or more of the following ways:
- Retain the copyright notice: `Copyright (c) 2025 Rafael Mori`.
- Include a link to the original project repository or website.

## Acknowledgment

This project was developed with the goal of enhancing usability and providing open access to its features.

For further information about the license and terms of use, please refer to the `LICENSE` file included with this project.

/// README.md ///
# ![Logz Banner](docs/assets/top_banner.png)

---

**An advanced logging and metrics management tool with native support for Prometheus integration, dynamic notifications, and a powerful CLI.**

---

## **Table of Contents**

1. [About the Project](#about-the-project)
2. [Features](#features)
3. [Installation](#installation)
4. [Usage](#usage)
    - [CLI](#cli)
    - [Configuration](#configuration)
5. [Prometheus Integration](#prometheus-integration)
6. [Roadmap](#roadmap)
7. [Contributing](#contributing)
8. [Contact](#contact)

---

## **About the Project**

Logz is a flexible and powerful solution for managing logs and metrics in modern systems. Built in **Go**, it provides extensive support for multiple notification methods such as **HTTP Webhooks**, **ZeroMQ**, and **DBus**, alongside seamless integration with **Prometheus** for advanced monitoring.

Logz is designed to be robust, highly configurable, and scalable, catering to developers, DevOps teams, and software architects who need a centralized approach to logging, metrics and many other aspects of their systems.

**Why Logz?**

- üí° **Ease of Use**: Configure and manage logs effortlessly.
- üåê **Seamless Integration**: Easily integrates with Prometheus and other systems.
- üîß **Extensibility**: Add new notifiers and services as needed.

---

## **Features**

‚ú® **Dynamic Notifiers**:

- Support for multiple notifiers simultaneously.
- Centralized and flexible configuration via JSON or YAML.

üìä **Monitoring and Metrics**:

- Exposes Prometheus-compatible metrics.
- Dynamic management of metrics with persistence support.

üíª **Powerful CLI**:

- Straightforward commands to manage logs and services.
- Extensible for additional workflows.

üîí **Resilient and Secure**:

- Validates against Prometheus naming conventions.
- Distinct modes for standalone and service execution.

---

## **Installation**

Requirements:

- **Go** version 1.19 or later.
- Prometheus (optional for advanced monitoring).

```bash
# Clone this repository
git clone https://github.com/kubex-ecosystem/logz.git

# Navigate to the project directory
cd logz

# Build the binary using make
make build

# Install the binary using make
make install

# (Optional) Add the binary to the PATH to use it globally
export PATH=$PATH:$(pwd)
```

---

## **Usage**

### CLI

Here are some examples of commands you can execute with Logz‚Äôs CLI:

```bash
# Log at different levels
logz info --msg "Starting the application."
logz error --msg "Database connection failed."

# Start the detached service
logz start

# Stop the detached service
logz stop

# Watch logs in real-time
logz watch
```

### **Usage Examples**

Here are some practical examples of how to use `logz` to log messages and enhance your application's logging capabilities:

#### **1. Log a Debug Message with Metadata**

```bash
logz debug \
--msg 'Just an example for how it works and show logs with this app.. AMAZING!! Dont you think?' \
--output "stdout" \
--metadata requestId=12345,user=admin
```

**Output:**

```plaintext
[2025-03-02T04:09:16Z] üêõ DEBUG - Just an example for how it works and show logs with this app.. AMAZING!! Dont you think?
                     {"requestId":"12345","user":"admin"}
```

#### **2. Log an Info Message to a File**

```bash
logz info \
--msg "This is an information log entry!" \
--output "/path/to/logfile.log" \
--metadata sessionId=98765,location=server01
```

#### **3. Log an Error Message in JSON Format**

```bash
logz error \
--msg "An error occurred while processing the request" \
--output "stdout" \
--format "json" \
--metadata errorCode=500,details="Internal Server Error"
```

**Output (JSON):**

```json
{
  "timestamp": "2025-03-02T04:10:52Z",
  "level": "ERROR",
  "message": "An error occurred while processing the request",
  "metadata": {
    "errorCode": 500,
    "details": "Internal Server Error"
  }
}
```

---

#### The image below shows the CLI in action, demonstrating how to log messages at different levels and formats

![img.png](docs/assets/cli_print.png)

---

### **Description of Commands and Flags**

- **`--msg`**: Specifies the log message.
- **`--output`**: Defines where to output the log (`stdout` for console or a file path).
- **`--format`**: Sets the format of the log (e.g., `text` or `json`).
- **`--metadata`**: Adds metadata to the log entry in the form of key-value pairs.

---

### Configuration

Logz uses a JSON or YAML configuration file to centralize its setup. The file is automatically generated on first use or can be manually configured at:
`~/.kubex/logz/config.json`.

**Example Configuration**:

```json
{
  "port": "2112",
  "bindAddress": "0.0.0.0",
  "logLevel": "info",
  "notifiers": {
    "webhook1": {
      "type": "http",
      "webhookURL": "https://example.com/webhook",
      "authToken": "your-token-here"
    }
  }
}
```

---

## **Prometheus Integration**

Once started, Logz exposes metrics at the endpoint:

```plaintext
http://localhost:2112/metrics
```

**Example Prometheus Configuration**:

```yaml
scrape_configs:
  - job_name: 'logz'
    static_configs:
      - targets: ['localhost:2112']
```

---

## **Roadmap**

üîú **Upcoming Features**:

- Support for additional notifier types (e.g., Slack, Discord, and email).
- Integrated monitoring dashboard.
- Advanced configuration with automated validation.

---

## **Contributing**

Contributions are welcome! Feel free to open issues or submit pull requests. Check out the [Contributing Guide](docs/CONTRIBUTING.md) for more details.

---

## **Contact**

üíå **Developer**:

Rafael Mori

- üåê [Portfolio](https://rafa-mori.dev)
- üîó [LinkedIn](https://www.linkedin.com/in/kubex-ecosystem/)
- üìß [Email](mailto:faelmori@gmail.com)
- üíº Follow me on GitHub:
  - [faelmori](https://github.com/faelmori)
  - [rafa-mori](https://github.com/rafa-mori)

---

***I'm open to new work opportunities and collaborations. If you find this project interesting, don‚Äôt hesitate to reach out!***

/// cmd/cli/cmds_metrics.go ///
package cli

import (
	il "github.com/kubex-ecosystem/logz/internal/core"

	"github.com/spf13/cobra"

	"fmt"
	"strconv"
	"sync"
	"time"
)

// MetricsCmd creates the main command for managing Prometheus metrics.
func MetricsCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use: "metrics",
		Annotations: GetDescriptions(
			[]string{"Manage Prometheus metrics"},
			false,
		),
	}

	cmd.AddCommand(enableMetricsCmd())
	cmd.AddCommand(disableMetricsCmd())
	cmd.AddCommand(addMetricCmd())
	cmd.AddCommand(removeMetricCmd())
	cmd.AddCommand(listMetricsCmd())
	cmd.AddCommand(watchMetricsCmd())

	return cmd
}

// enableMetricsCmd creates the command to enable Prometheus integration.
func enableMetricsCmd() *cobra.Command {
	var port string
	var mu sync.RWMutex

	enMCmd := &cobra.Command{
		Use:     "enable",
		Aliases: []string{"en"},
		Short:   "Enable Prometheus integration",
		Run: func(cmd *cobra.Command, args []string) {
			mu.Lock()
			defer mu.Unlock()

			pm := il.GetPrometheusManager()
			pm.Enable(port)
		},
	}
	enMCmd.Flags().StringVarP(&port, "port", "p", "2112", "Port to expose Prometheus metrics")
	return enMCmd
}

// disableMetricsCmd creates the command to disable Prometheus integration.
func disableMetricsCmd() *cobra.Command {
	var mu sync.RWMutex

	return &cobra.Command{
		Use:     "disable",
		Aliases: []string{"dis"},
		Short:   "Disable Prometheus integration",
		Run: func(cmd *cobra.Command, args []string) {
			mu.Lock()
			defer mu.Unlock()

			pm := il.GetPrometheusManager()
			pm.Disable()
		},
	}
}

// addMetricCmd creates the command to add or update a Prometheus metric.
func addMetricCmd() *cobra.Command {
	var mu sync.RWMutex

	return &cobra.Command{
		Use:     "add [name] [value]",
		Aliases: []string{"a"},
		Short:   "Add or update a Prometheus metric",
		Args:    cobra.ExactArgs(2),
		Run: func(cmd *cobra.Command, args []string) {
			mu.Lock()
			defer mu.Unlock()

			name := args[0]
			value, valueErr := strconv.ParseFloat(args[1], 64)
			if valueErr != nil {
				fmt.Printf("Invalid metric value: %v\n", valueErr)
				return
			}
			pm := il.GetPrometheusManager()
			pm.AddMetric(name, value, nil)
		},
	}
}

// removeMetricCmd creates the command to remove a Prometheus metric.
func removeMetricCmd() *cobra.Command {
	var mu sync.RWMutex

	return &cobra.Command{
		Use:     "remove [name]",
		Aliases: []string{"r"},
		Short:   "Remove a Prometheus metric",
		Args:    cobra.ExactArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			mu.Lock()
			defer mu.Unlock()

			name := args[0]
			pm := il.GetPrometheusManager()
			pm.RemoveMetric(name)
		},
	}
}

// listMetricsCmd creates the command to list all Prometheus metrics.
func listMetricsCmd() *cobra.Command {
	var mu sync.RWMutex

	return &cobra.Command{
		Use:     "list",
		Aliases: []string{"l"},
		Short:   "List all Prometheus metrics",
		Run: func(cmd *cobra.Command, args []string) {
			mu.RLock()
			defer mu.RUnlock()

			pm := il.GetPrometheusManager()
			metrics := pm.GetMetrics()
			if len(metrics) == 0 {
				fmt.Println("No metrics registered.")
				return
			}
			fmt.Println("Registered metrics:")
			for name, value := range metrics {
				fmt.Printf(" - %s: %f\n", name, value)
			}
		},
	}
}

// watchMetricsCmd creates the command to watch Prometheus metrics in real time.
func watchMetricsCmd() *cobra.Command {
	return &cobra.Command{
		Use:     "watch",
		Aliases: []string{"w"},
		Short:   "Watch Prometheus metrics in real time",
		Run: func(cmd *cobra.Command, args []string) {
			fmt.Println("Watching metrics (press Ctrl+C to exit):")
			ticker := time.NewTicker(2 * time.Second)
			defer ticker.Stop()
			for {
				select {
				case <-ticker.C:
					metrics := il.GetPrometheusManager().GetMetrics()
					fmt.Println("Current Metrics:")
					if len(metrics) == 0 {
						fmt.Println("  No metrics registered.")
					} else {
						for name, value := range metrics {
							fmt.Printf(" - %s: %f\n", name, value)
						}
					}
					fmt.Println("-----")
				}
			}
		},
	}
}

/// cmd/cli/cmds_service.go ///
package cli

import (
	il "github.com/kubex-ecosystem/logz/internal/core"

	"github.com/spf13/cobra"

	"fmt"
)

// ServiceCmd creates the main command for managing the web service.
func ServiceCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use: "service",
		Annotations: GetDescriptions(
			[]string{"Start, stop, and get information about the web service"},
			false,
		),
	}
	cmd.AddCommand(startServiceCmd())
	cmd.AddCommand(stopServiceCmd())
	cmd.AddCommand(getServiceCmd())
	cmd.AddCommand(spawnServiceCmd())
	return cmd
}

// startServiceCmd creates the command to start the web service.
func startServiceCmd() *cobra.Command {
	return &cobra.Command{
		Use:    "start",
		Short:  "Start the web service",
		Hidden: true,
		Run: func(cmd *cobra.Command, args []string) {
			configManager := il.NewConfigManager()
			if configManager == nil {
				fmt.Println("ErrorCtx initializing ConfigManager.")
				return
			}
			cfgMgr := *configManager

			_, err := cfgMgr.LoadConfig()
			if err != nil {
				fmt.Printf("ErrorCtx loading configuration: %v\n", err)
				return
			}

			if err := il.Start("9999"); err != nil {
				fmt.Printf("ErrorCtx starting service: %v\n", err)
			} else {
				fmt.Println("Service started successfully.")
			}
		},
	}
}

// stopServiceCmd creates the command to stop the web service.
func stopServiceCmd() *cobra.Command {
	return &cobra.Command{
		Use:    "stop",
		Hidden: true,
		Short:  "Stop the web service",
		Run: func(cmd *cobra.Command, args []string) {
			if err := il.Stop(); err != nil {
				fmt.Printf("ErrorCtx stopping service: %v\n", err)
			} else {
				fmt.Println("Service stopped successfully.")
			}
		},
	}
}

// getServiceCmd creates the command to get information about the running web service.
func getServiceCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "status",
		Short: "Get information about the running service",
		Run: func(cmd *cobra.Command, args []string) {
			pid, port, pidPath, err := il.GetServiceInfo()
			if err != nil {
				fmt.Println("Service is not running")
			} else {
				fmt.Printf("Service running with PID %d on port %s\n", pid, port)
				fmt.Printf("PID file: %s\n", pidPath)
			}
		},
	}
}

// spawnServiceCmd creates the command to spawn a new instance of the web service.
func spawnServiceCmd() *cobra.Command {
	var configPath string
	spCmd := &cobra.Command{
		Use:    "spawn",
		Hidden: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := il.Run(); err != nil {
				return err
			}
			return nil
		},
	}
	spCmd.Flags().StringVarP(&configPath, "config", "c", "", "Path to the service configuration file")
	return spCmd
}

/// cmd/cli/common.go ///
package cli

import (
	"os"
	"strings"
)

func GetDescriptions(descriptionArg []string, hideBanner bool) map[string]string {
	var description, banner string

	if strings.Contains(strings.Join(os.Args[0:], ""), "-h") {
		description = descriptionArg[0]
	} else {
		if len(descriptionArg) > 1 {
			description = descriptionArg[1]
		} else {
			description = descriptionArg[0]
		}
	}

	if !hideBanner {
		banner = `
 __
|  \
| ‚ñì‚ñì       ______   ______  ________
| ‚ñì‚ñì      /      \ /      \|        \
| ‚ñì‚ñì     |  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\\‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì
| ‚ñì‚ñì     | ‚ñì‚ñì  | ‚ñì‚ñì ‚ñì‚ñì  | ‚ñì‚ñì /    ‚ñì‚ñì
| ‚ñì‚ñì_____| ‚ñì‚ñì__/ ‚ñì‚ñì ‚ñì‚ñì__| ‚ñì‚ñì/  ‚ñì‚ñì‚ñì‚ñì_
| ‚ñì‚ñì     \\‚ñì‚ñì    ‚ñì‚ñì\‚ñì‚ñì    ‚ñì‚ñì  ‚ñì‚ñì    \
 \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì _\‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì
                  |  \__| ‚ñì‚ñì
                   \‚ñì‚ñì    ‚ñì‚ñì
                    \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì          `
	} else {
		banner = ""
	}
	return map[string]string{"banner": banner, "description": description}
}

/// cmd/install.go ///
package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

const BinaryName = "logz"

func installLogz() {
	err := installBinary(BinaryName)
	if err != nil {
		fmt.Printf("ErrorCtx during installation: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("Installation complete!")
}

func installBinary(binaryName string) error {
	// Obter o diret√≥rio atual e o caminho do bin√°rio
	binaryPath, err := os.Executable()
	if err != nil {
		return fmt.Errorf("failed to get executable path: %w", err)
	}
	targetDir := getInstallDirectory()
	targetPath := filepath.Join(targetDir, binaryName)
	if fileExists(targetPath) {
		fmt.Printf("‚úÖ Binary already exists at: %s\n", targetPath)
	} else {
		// Copiar o bin√°rio
		fmt.Printf("Installing binary to: %s\n", targetPath)
		err := copyFile(binaryPath, targetPath)
		if err != nil {
			return fmt.Errorf("failed to copy binary: %w", err)
		}
		fmt.Printf("‚úÖ Binary installed at: %s\n", targetPath)
	}
	if !isInPath(targetDir) {
		fmt.Printf("‚ö†Ô∏è  Warning: %s is not in your PATH.\n", targetDir)
		err := addToPathInstruction(targetDir)
		if err != nil {
			return fmt.Errorf("failed to provide PATH instructions: %w", err)
		}
	}
	return nil
}

func getInstallDirectory() string {
	if os.Geteuid() == 0 {
		return "/usr/local/bin"
	}
	return filepath.Join(os.Getenv("HOME"), ".local", "bin")
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func isInPath(dir string) bool {
	pathEnv := os.Getenv("PATH")
	paths := strings.Split(pathEnv, ":")
	for _, p := range paths {
		if p == dir {
			return true
		}
	}
	return false
}

func addToPathInstruction(dir string) error {
	shell := filepath.Base(os.Getenv("SHELL"))
	var shellConfigFile string

	switch shell {
	case "bash":
		shellConfigFile = filepath.Join(os.Getenv("HOME"), ".bashrc")
	case "zsh":
		shellConfigFile = filepath.Join(os.Getenv("HOME"), ".zshrc")
	case "sh":
		shellConfigFile = filepath.Join(os.Getenv("HOME"), ".profile")
	default:
		return fmt.Errorf("unsupported shell: %s", shell)
	}

	fmt.Printf("Add the following line to your %s file to include %s in your PATH:\n", shellConfigFile, dir)
	fmt.Printf("export PATH=%s:$PATH\n", dir)
	fmt.Printf("Then run: source %s\n", shellConfigFile)
	return nil
}

func copyFile(src, dest string) error {
	input, err := os.Open(src)
	if err != nil {
		return err
	}
	defer func(input *os.File) {
		_ = input.Close()
	}(input)
	output, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer func(output *os.File) {
		_ = output.Close()
	}(output)
	_, err = io.Copy(output, input)
	if err != nil {
		return err
	}
	// Ajustar permiss√µes do bin√°rio
	return os.Chmod(dest, 0755)
}

/// cmd/main.go ///
package main

import (
	"fmt"
	"os"
)

func main() {
	if logzErr := RegX().Execute(); logzErr != nil {
		fmt.Printf("ErrorCtx executing command: %v\n", logzErr)
		os.Exit(1)
	}
}

/// cmd/root.go ///
package main

import (
	cc "github.com/kubex-ecosystem/logz/cmd/cli"
	vs "github.com/kubex-ecosystem/logz/version"

	"github.com/spf13/cobra"

	"os"
	"strings"
)

// Logz represents the main structure for the logz command-line interface.
type Logz struct{}

// Alias returns the alias for the logz command.
func (m *Logz) alias() string {
	return "logs"
}

// Alias returns the alias for the logz command.
func (m *Logz) Alias() string {
	return "logs"
}

// ShortDescription provides a brief description of the logz command.
func (m *Logz) ShortDescription() string {
	return "LoggerLogz and logs manager"
}

// LongDescription provides a detailed description of the logz command.
func (m *Logz) LongDescription() string {
	return "The \"logz\" command-line interface (CLI) is an intuitive and user-friendly core and log management module designed for developers.\nIntegrated with Prometheus for monitoring, \"logz\" ensures comprehensive log management and is compatible with other plugins and\nthe Go programming language making it a versatile tool for maintaining system health and performance."
}

// Usage returns the usage information for the logz command.
func (m *Logz) Usage() string {
	return "logz [command] [args]"
}

// Examples returns example usages of the logz command.
func (m *Logz) Examples() []string {
	return []string{"logz show all", "lg error 'error message'"}
}

// Active indicates whether the logz command is active.
func (m *Logz) Active() bool {
	return true
}

// Module returns the module name for the logz command.
func (m *Logz) Module() string {
	return "logz"
}

// Execute runs the logz command.
func (m *Logz) Execute() error {
	return m.Command().Execute()
}

// Command creates and returns the main cobra.Command for the logz CLI.
func (m *Logz) Command() *cobra.Command {
	var logType, message, name string
	//var show, clearLogs, archive string
	//var filter []string
	//var follow, quiet bool

	cmd := &cobra.Command{
		Use:         m.Module(),
		Annotations: cc.GetDescriptions([]string{m.LongDescription(), m.ShortDescription()}, false),
		Version:     vs.GetVersion(),
		Run: func(cmd *cobra.Command, args []string) {
			// Placeholder for the command execution logic
			// return logzCmd.NewLogger([]string{logType, message, name, strconv.FormatBool(quiet), show, strconv.FormatBool(follow), clearLogs, archive}...))
		},
	}

	// Define flags for the logz command
	cmd.Flags().StringVarP(&logType, "type", "t", "", "Log type")
	cmd.Flags().StringVarP(&message, "message", "m", "", "Log message")
	cmd.Flags().StringVarP(&name, "name", "n", "", "Log module name")
	//cmd.Flags().StringVarP(&show, "show", "s", "", "Show logs")
	//cmd.Flags().BoolVarP(&follow, "follow", "f", false, "Follow logs")
	//cmd.Flags().StringVarP(&clearLogs, "clear", "c", "", "Clear logs")
	//cmd.Flags().StringVarP(&archive, "archive", "z", "", "Archive logs")
	//cmd.Flags().StringArrayVarP(&filter, "filter", "F", []string{}, "Filter logs")
	//cmd.Flags().BoolVarP(&quiet, "quiet", "q", false, "Quiet mode")

	// Add subcommands to the logz command
	cmd.AddCommand(cc.LogzCmds()...)
	cmd.AddCommand(cc.ServiceCmd())
	cmd.AddCommand(cc.MetricsCmd())

	cmd.AddCommand(vs.CliCommand())

	// Set usage definitions for the command and its subcommands
	setUsageDefinition(cmd)
	for _, c := range cmd.Commands() {
		setUsageDefinition(c)
		if !strings.Contains(strings.Join(os.Args, " "), c.Use) {
			if c.Short == "" {
				c.Short = c.Annotations["description"]
			}
		}
	}

	return cmd
}

// concatenateExamples concatenates example usages into a single string.
func (m *Logz) concatenateExamples() string {
	examples := ""
	for _, example := range m.Examples() {
		examples += string(example) + "\n  "
	}
	return examples
}

// RegX returns a new instance of the Logz struct.
func RegX() *Logz {
	return &Logz{}
}

/// cmd/usage.go ///
package main

import (
	"fmt"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"os"
	"os/exec"
	"strings"
)

func colorYellow(s string) string {
	return color.New(color.FgYellow).SprintFunc()(s)
}
func colorGreen(s string) string {
	return color.New(color.FgGreen).SprintFunc()(s)
}
func colorBlue(s string) string {
	return color.New(color.FgBlue).SprintFunc()(s)
}
func colorRed(s string) string {
	return color.New(color.FgRed).SprintFunc()(s)
}
func colorHelp(s string) string {
	return color.New(color.FgCyan).SprintFunc()(s)
}
func hasServiceCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] == "true" {
			return true
		}
	}
	return false
}
func hasModuleCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] != "true" {
			return true
		}
	}
	return false
}
func setUsageDefinition(cmd *cobra.Command) {
	cobra.AddTemplateFunc("colorYellow", colorYellow)
	cobra.AddTemplateFunc("colorGreen", colorGreen)
	cobra.AddTemplateFunc("colorRed", colorRed)
	cobra.AddTemplateFunc("colorBlue", colorBlue)
	cobra.AddTemplateFunc("colorHelp", colorHelp)
	cobra.AddTemplateFunc("hasServiceCommands", hasServiceCommands)
	cobra.AddTemplateFunc("hasModuleCommands", hasModuleCommands)

	// Altera o template de uso do cobra
	cmd.SetUsageTemplate(cliUsageTemplate)
}

var cliUsageTemplate = `{{- if index .Annotations "banner" }}{{colorBlue (index .Annotations "banner")}}{{end}}{{- if (index .Annotations "description") }}
{{index .Annotations "description"}}
{{- end }}

{{colorYellow "Usage:"}}{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command] [args]{{end}}{{if gt (len .Aliases) 0}}

{{colorYellow "Aliases:"}}
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

{{colorYellow "Example:"}}
  {{.Example}}{{end}}{{if .HasAvailableSubCommands}}
{{colorYellow "Available Commands:"}}{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{colorGreen (rpad .Name .NamePadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

{{colorYellow "Flags:"}}
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasAvailableInheritedFlags}}

{{colorYellow "Global Options:"}}
  {{.InheritedFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasHelpSubCommands}}

{{colorYellow "Additional help topics:"}}
{{range .Commands}}{{if .IsHelpCommand}}
  {{colorGreen (rpad .CommandPath .CommandPathPadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasSubCommands}}

{{colorYellow (printf "Use \"%s [command] --help\" for more information about a command." .CommandPath)}}{{end}}
`

const AppName = "logz"

func installCheck() {
	usrEnvs := os.Environ()
	envPath := os.Getenv("PATH")
	usrEnvs = append(usrEnvs, fmt.Sprintf("PATH=%s", envPath))
	appBinPath, appBinPathErr := exec.LookPath(AppName)
	if appBinPathErr != nil {
		fmt.Printf("ErrorCtx: %v\n", appBinPathErr)
		return
	}
	appBinPath = strings.Replace(appBinPath, AppName, "", 1)

}

/// docs/CONTRIBUTING.md ///
# **Contributing to Logz**

Thank you for your interest in contributing to **[Logz](https://github.com/kubex-ecosystem/logz)**! We are excited to have you as part of our community. This guide will help you get started and contribute effectively to the project.

---

## **How to Contribute**

There are several ways to contribute to [Logz](https://github.com/kubex-ecosystem/logz):

1. **Report Issues**
   - Found bugs or issues in the code? Open an issue detailing the problem.
   - Include as much information as possible: steps to reproduce the issue, logs, Go version used, etc.

2. **Suggest Improvements**
   - Have an idea to improve the project? Share your suggestion by opening an issue with the `enhancement` tag.

3. **Submit Pull Requests**
   - Want to fix a bug or implement something new? Submit a pull request with your changes.

4. **Test and Review Code**
   - Help review pull requests from other contributors.
   - Run existing tests and validate if the proposed changes keep the system functional.

---

## **Getting Started**

### 1. **Clone the Repository**
```bash
git clone https://github.com/kubex-ecosystem/logz.git
cd logz
```

### 2. **Set Up the Environment**
Make sure you have Go installed:

You can install Go using one of the following methods:

- [A super easy way to install Go](https://github.com/kubex-ecosystem/go-installer)
  ```shell
    curl -sSfL 'https://raw.githubusercontent.com/faelmori/go-installer/refs/heads/main/go.sh' | bash
  ```

- [Convencional way to download Go](https://go.dev/dl/)

### 3. **Install Dependencies**
```bash
# Download the necessary packages
go mod download
```

### 4. **Run Tests**
Before making changes, run the existing tests:
```bash
go test ./...
```

---

## **Creating a Pull Request**

### **1. Fork the Repository**
Create a fork of the project to your own GitHub.

### **2. Create a New Branch**
```bash
git checkout -b your-feature
```

### **3. Make Changes**
Make sure to follow the project's code conventions and best practices.

### **4. Add Tests (if applicable)**
Include test cases to validate the added functionality.

### **5. Run Tests**
Ensure all changes and tests are working:
```bash
go test ./...
```

### **6. Commit and Push**
```bash
git add .
git commit -m "Brief description of the change"
git push origin your-feature
```

### **7. Open the Pull Request**
Go to the original repository on GitHub and open a pull request explaining your changes.

---

## **Code Standards**

### **Code Style**
This project follows Go's code conventions. Some recommendations:
- Use `gofmt` to format the code:
```bash
gofmt -w .
```

- Name variables and functions clearly and descriptively.
- Break down long functions into smaller parts whenever possible.

### **Commits**
Commits should be clear and descriptive. Examples:
- `fix: fix bug in notification logic`
- `feat: add support for Slack notifier`

---

## **Best Practices**

1. **Be Respectful and Welcoming**
   This is an open-source project for everyone. Respect other contributors and collaborate constructively.

2. **Document Your Changes**
   Update the `README.md` or documentation, if necessary, to include your changes.

3. **Add Tests When Possible**
   Ensure any new functionality is accompanied by tests.

4. **Be Clear in Issue Reports**
   When opening an issue, be detailed and provide as much context as possible.

---

## **Where to Get Help**

If you need assistance, feel free to:
- Open an issue with the `question` tag.
- Contact me via the email or LinkedIn listed in the `README.md`.

---

## **Our Commitment**

We commit to reviewing pull requests and issues as quickly as possible. We value your contribution and appreciate the time dedicated to the project!

/// docs/README.pt-BR.md ///
![Logz Banner](assets/top_banner.png)

---

**Uma ferramenta de gerenciamento de logs e m√©tricas avan√ßada, com suporte nativo √† integra√ß√£o com Prometheus, notifica√ß√µes din√¢micas e uma CLI poderosa.**

---

## **√çndice**
1. [Sobre o Projeto](#sobre-o-projeto)
2. [Destaques](#destaques)
3. [Instala√ß√£o](#instala√ß√£o)
4. [Uso](#uso)
    - [CLI](#cli)
    - [Configura√ß√£o](#configura√ß√£o)
5. [Integra√ß√£o com Prometheus](#integra√ß√£o-com-prometheus)
6. [Roadmap](#roadmap)
7. [Contribui√ß√µes](#contribui√ß√µes)
8. [Contato](#contato)

---

## **Sobre o Projeto**
O Logz √© uma solu√ß√£o poderosa e flex√≠vel para gerenciar logs e m√©tricas em sistemas modernos. Constru√≠do com **Go**, oferece suporte extensivo a m√∫ltiplos m√©todos de notifica√ß√£o, incluindo **HTTP Webhooks**, **ZeroMQ**, e **DBus**, al√©m de integra√ß√£o fluida com o **Prometheus** para monitoramento avan√ßado.

O objetivo √© fornecer uma ferramenta robusta, altamente configur√°vel e escal√°vel para desenvolvedores, equipes DevOps e arquitetos de software que precisam de uma abordagem centralizada para gerenciar logs e m√©tricas.

**Principais Benef√≠cios:**
- üí° F√°cil de configurar e usar.
- üåê Integra√ß√£o direta com Prometheus e outros sistemas.
- üîß Extens√≠vel com novos notifiers e servi√ßos.

---

## **Destaques**
‚ú® **Notificadores Din√¢micos**:
- Suporte a m√∫ltiplos notifiers simultaneamente.
- Configura√ß√£o centralizada e flex√≠vel via JSON ou YAML.

üìä **Monitoramento e M√©tricas**:
- Exposi√ß√£o de m√©tricas compat√≠veis com Prometheus.
- Gerenciamento din√¢mico de m√©tricas com suporte a persist√™ncia.

üíª **CLI Poderoso**:
- Comandos simples e objetivos para gerenciar logs e servi√ßos.
- Extens√≠vel para novos fluxos de trabalho.

üîí **Resiliente e Seguro**:
- Valida√ß√µes em conformidade com as regras do Prometheus.
- Modos de opera√ß√£o distintos para processos destacados e convencionais.

---

## **Instala√ß√£o**
Requisitos:
- **Go** vers√£o 1.19 ou superior.
- Prometheus (opcional para monitoramento avan√ßado).

```bash
# Clone este reposit√≥rio
git clone https://github.com/kubex-ecosystem/logz.git

# Navegue at√© o diret√≥rio do projeto
cd logz

# Construa o bin√°rio usando make
make build

# Instale o bin√°rio usando make
make install

# (Opcional) Adicione o bin√°rio ao PATH para us√°-lo globalmente
export PATH=$PATH:$(pwd)
```

---

## **Uso**

### CLI
Aqui est√£o alguns exemplos de comandos que podem ser executados com a CLI:

```bash
# Registrar logs de diferentes n√≠veis
logz info --msg "Iniciando a aplica√ß√£o."
logz error --msg "Erro ao se conectar ao banco de dados."

# Iniciar o servi√ßo destacado
logz start

# Parar o servi√ßo destacado
logz stop

# Monitorar logs em tempo real
logz watch
```

### Configura√ß√£o
O Logz utiliza um arquivo de configura√ß√£o JSON ou YAML para centralizar sua configura√ß√£o. O arquivo ser√° automaticamente gerado no primeiro uso ou pode ser configurado manualmente em:
`~/.kubex/logz/config.json`.

Exemplo de configura√ß√£o:
```json
{
  "port": "2112",
  "bindAddress": "0.0.0.0",
  "logLevel": "info",
  "notifiers": {
    "webhook1": {
      "type": "http",
      "webhookURL": "https://example.com/webhook",
      "authToken": "seu-token-aqui"
    }
  }
}
```

---

## **Integra√ß√£o com Prometheus**
Uma vez iniciado, o Logz exp√µe m√©tricas no endpoint:
```
http://localhost:2112/metrics
```

### Exemplo de configura√ß√£o no Prometheus:
```yaml
scrape_configs:
  - job_name: 'logz'
    static_configs:
      - targets: ['localhost:2112']
```

---

## **Roadmap**
üîú **Pr√≥ximos Recursos**:
- Suporte a novos tipos de notificadores (como Slack, Discord e e-mails).
- Painel de monitoramento integrado.
- Configura√ß√£o avan√ßada com valida√ß√µes autom√°ticas.

---

## **Contribui√ß√µes**
Contribui√ß√µes s√£o bem-vindas! Sinta-se √† vontade para abrir issues ou enviar pull requests. Confira o [guia de contribui√ß√µes](CONTRIBUTING.md) para mais detalhes.

---

## **Contato**
üíå **Desenvolvedor:**
[Seu Nome](mailto:seu-email@dominio.com)
üåê [Seu LinkedIn](https://linkedin.com/in/seu-perfil)
üíº [Portf√≥lio](https://seu-portfolio.com)

Adoraria ouvir sobre novas oportunidades de trabalho ou colabora√ß√µes. Se voc√™ gostou desse projeto, n√£o hesite em entrar em contato comigo!

/// internal/core/config.go ///
package core

import (
	"encoding/json"
	"fmt"
	"github.com/fsnotify/fsnotify"
	"github.com/spf13/viper"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"sync"

	// "github.com/fsnotify/fsnotify"
	// "github.com/spf13/viper"
	//
	// "encoding/json"
	// "fmt"
	// "log"
	// "os"
	// "path/filepath"
	// "strconv"
	// "strings"
	// "sync"
	// "time"
	"strings"
	"time"
)

const (
	defaultPort        = "9999"
	defaultBindAddress = "0.0.0.0"
	defaultMode        = ModeStandalone
)

var defaultLogPath = "stdout"

// Config interface defines the methods to access configuration settings.
type Config interface {
	Port() string
	BindAddress() string
	Address() string
	PidFile() string
	ReadTimeout() time.Duration
	WriteTimeout() time.Duration
	IdleTimeout() time.Duration
	Output() string
	SetOutput(configPath string)
	NotifierManager() interface{}
	Mode() interface{}
	Level() string
	SetLevel(VLevel interface{})
	Format() string
	SetFormat(LogFormat interface{})
	GetInt(key string, value int) int
	GetFormatter() interface{}
}

// ConfigImpl implements the Config interface and holds the configuration values.
type ConfigImpl struct {
	// Config is a constraint to implement Config interface
	Config

	VlLevel           LogLevel
	VlFormat          LogFormat
	VlPort            string
	VlBindAddress     string
	VlAddress         string
	VlPidFile         string
	VlReadTimeout     time.Duration
	VlWriteTimeout    time.Duration
	VlIdleTimeout     time.Duration
	VlOutput          string
	VlNotifierManager NotifierManager
	VlMode            LogMode
}

func (c *ConfigImpl) GetFormatter() interface{} {
	switch c.Format() {
	case "json":
		return &JSONFormatter{}
	default:
		return &TextFormatter{}
	}
}
func (c *ConfigImpl) Port() string                 { return c.VlPort }
func (c *ConfigImpl) BindAddress() string          { return c.VlBindAddress }
func (c *ConfigImpl) Address() string              { return c.VlAddress }
func (c *ConfigImpl) PidFile() string              { return c.VlPidFile }
func (c *ConfigImpl) ReadTimeout() time.Duration   { return c.VlReadTimeout }
func (c *ConfigImpl) WriteTimeout() time.Duration  { return c.VlWriteTimeout }
func (c *ConfigImpl) IdleTimeout() time.Duration   { return c.VlIdleTimeout }
func (c *ConfigImpl) NotifierManager() interface{} { return c.VlNotifierManager }
func (c *ConfigImpl) Mode() interface{}            { return c.VlMode }
func (c *ConfigImpl) Level() string                { return strings.ToUpper(string(c.VlLevel)) }
func (c *ConfigImpl) SetLevel(VLevel interface{})  { c.VlLevel = LogLevel(VLevel.(string)) }
func (c *ConfigImpl) Format() string               { return strings.ToLower(string(c.VlFormat)) }
func (c *ConfigImpl) SetFormat(format interface{}) { c.VlFormat = LogFormat(format.(string)) }
func (c *ConfigImpl) Output() string {
	if c.VlOutput != "" {
		return c.VlOutput
	}
	home, homeErr := os.UserHomeDir()
	if homeErr != nil {
		home, homeErr = os.UserConfigDir()
		if homeErr != nil {
			home, homeErr = os.UserCacheDir()
			if homeErr != nil {
				home = "/tmp"
			}
		}
	}
	logPath := filepath.Join(home, ".kubex", "logz", "logz.log")
	if mkdirErr := os.MkdirAll(filepath.Dir(logPath), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
		return ""
	}
	if _, err := os.Stat(logPath); os.IsNotExist(err) {
		if _, createErr := os.Create(logPath); createErr != nil {
			return ""
		}
	}
	return logPath
}
func (c *ConfigImpl) SetOutput(configPath string) {
	c.VlOutput = configPath
}
func (c *ConfigImpl) GetInt(key string, defaultValue int) int {
	viperInstance := viper.GetViper()

	// Primeiro tenta buscar via Viper, se dispon√≠vel
	if viperInstance != nil {
		// Obt√©m o valor como string para lidar com chaves configuradas em diferentes formatos
		rawValue := viperInstance.GetString(key)
		if rawValue != "" {
			parsedVal, err := strconv.Atoi(rawValue) // Converte o valor para inteiro
			if err == nil {
				return parsedVal
			}
		}
	}

	// Caso n√£o encontre ou a convers√£o falhe, retorna o valor padr√£o
	return defaultValue
}
func (c *ConfigImpl) GetString(key string, defaultValue string) string {
	viperInstance := viper.GetViper()

	// Primeiro tenta buscar via Viper, se dispon√≠vel
	if viperInstance != nil {
		// Obt√©m o valor como string para lidar com chaves configuradas em diferentes formatos
		rawValue := viperInstance.GetString(key)
		if rawValue != "" {
			return rawValue
		}
	}

	// Caso n√£o encontre ou a convers√£o falhe, retorna o valor padr√£o
	return defaultValue
}

// ConfigManager interface defines methods to manage configuration.
type ConfigManager interface {
	GetConfig() Config
	GetPidPath() string
	GetConfigPath() string
	Output() string
	SetOutput(configPath string)
	LoadConfig() (Config, error)
}

// ConfigManagerImpl implements the ConfigManager interface.
type ConfigManagerImpl struct {
	VConfig Config
	Mu      sync.RWMutex
}

func (cm *ConfigManagerImpl) checkConfig() {
	cm.Mu.Lock()
	defer cm.Mu.Unlock()
	if cm.VConfig == nil {
		cm.VConfig = &ConfigImpl{}
	}
	home, homeErr := os.UserHomeDir()
	if homeErr != nil {
		home, homeErr = os.UserConfigDir()
		if homeErr != nil {
			home, homeErr = os.UserCacheDir()
			if homeErr != nil {
				home = "/tmp"
			}
		}
	}
	configPath := filepath.Join(home, ".kubex", "logz", "VConfig.json")
	if mkdirErr := os.MkdirAll(filepath.Dir(configPath), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
		return
	}
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		if _, createErr := os.Create(configPath); createErr != nil {
			return
		}
	}
}

func (cm *ConfigManagerImpl) Port() string {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()

	cm.checkConfig()
	if cm.VConfig != nil {
		return cm.VConfig.Port()
	}
	return defaultPort
}

func (cm *ConfigManagerImpl) BindAddress() string {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()

	cm.checkConfig()
	if cm.VConfig != nil {
		return cm.VConfig.BindAddress()
	}
	return defaultBindAddress
}

func (cm *ConfigManagerImpl) Address() string {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.Address()
	}
	return fmt.Sprintf("%s:%s", defaultBindAddress, defaultPort)
}

func (cm *ConfigManagerImpl) PidFile() string {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.PidFile()
	}
	return "logz_srv.pid"
}

func (cm *ConfigManagerImpl) ReadTimeout() time.Duration {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.ReadTimeout()
	}
	return time.Duration(15 * time.Second)
}

func (cm *ConfigManagerImpl) WriteTimeout() time.Duration {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.WriteTimeout()
	}
	return time.Duration(15 * time.Second)
}

func (cm *ConfigManagerImpl) IdleTimeout() time.Duration {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.IdleTimeout()
	}
	return time.Duration(60 * time.Second)
}

func (cm *ConfigManagerImpl) NotifierManager() interface{} {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.NotifierManager()
	}
	return nil
}

func (cm *ConfigManagerImpl) Mode() interface{} {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.Mode()
	}
	return defaultMode
}

func (cm *ConfigManagerImpl) Level() string {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.Level()
	}
	return strings.ToUpper(string(cm.VConfig.Level()))
}

func (cm *ConfigManagerImpl) Format() string {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	if cm.VConfig != nil {
		return cm.VConfig.Format()
	}
	return strings.ToLower(string(cm.VConfig.Format()))
}

func (cm *ConfigManagerImpl) GetInt(key string, value int) int {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	viperInstance := viper.GetViper()
	if viperInstance != nil {
		rawValue := viperInstance.GetString(key)
		if rawValue != "" {
			parsedVal, err := strconv.Atoi(rawValue)
			if err == nil {
				return parsedVal
			}
		}
	}
	return value
}

func (cm *ConfigManagerImpl) GetConfig() Config {
	cm.Mu.RLock()
	defer cm.Mu.RUnlock()
	return cm.VConfig
}

// GetPidPath returns the path to the PID file.
func (cm *ConfigManagerImpl) GetPidPath() string {
	cacheDir, cacheDirErr := os.UserCacheDir()
	if cacheDirErr != nil {
		cacheDir = "/tmp"
	}
	cacheDir = filepath.Join(cacheDir, "logz", cm.VConfig.PidFile())
	if mkdirErr := os.MkdirAll(filepath.Dir(cacheDir), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
		return ""
	}
	return cacheDir
}

// GetConfigPath returns the path to the configuration file.
func (cm *ConfigManagerImpl) GetConfigPath() string {
	if cm.VConfig != nil {
		if cm.VConfig.Output() != "" && cm.VConfig.Mode() == ModeService {
			return cm.VConfig.Output()
		}
	}

	home, homeErr := os.UserHomeDir()
	if homeErr != nil {
		home, homeErr = os.UserConfigDir()
		if homeErr != nil {
			home, homeErr = os.UserCacheDir()
			if homeErr != nil {
				home = "/tmp"
			}
		}
	}
	configPath := filepath.Join(home, ".kubex", "logz", "VConfig.json")
	if mkdirErr := os.MkdirAll(filepath.Dir(configPath), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
		return ""
	}
	return configPath
}

// SetOutput sets the path to the default log file.
func (cm *ConfigManagerImpl) SetOutput(output string) {
	cm.Mu.Lock()
	defer cm.Mu.Unlock()
	if cm.VConfig != nil {
		cm.VConfig.SetOutput(output)
	} else {

		if cm.VConfig.Mode() == ModeService {
			VConfig, configErr := cm.LoadConfig()
			if configErr != nil {
				log.Printf("ErrorCtx loading configuration: %v\n", configErr)
				return
			}
			VConfig.SetOutput(output)
			cm.VConfig = VConfig
		} else {
			log.Printf("Cannot set output in standalone VMode\n")
		}

	}
}

// Output returns the path to the configuration file.
func (cm *ConfigManagerImpl) Output() string {
	if cm.VConfig != nil {
		if cm.VConfig.Output() != "" {
			return cm.VConfig.Output()
		}
	}
	home, homeErr := os.UserHomeDir()
	if homeErr != nil {
		home, homeErr = os.UserConfigDir()
		if homeErr != nil {
			home, homeErr = os.UserCacheDir()
			if homeErr != nil {
				home = "/tmp"
			}
		}
	}
	logPath := filepath.Join(home, ".kubex", "logz", "logz.log")
	if mkdirErr := os.MkdirAll(filepath.Dir(logPath), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
		return ""
	}
	if _, err := os.Stat(logPath); os.IsNotExist(err) {
		if _, createErr := os.Create(logPath); createErr != nil {
			return ""
		}
	}
	return logPath
}

func (cm *ConfigManagerImpl) SetLevel(VLevel interface{}) {
	cm.Mu.Lock()
	defer cm.Mu.Unlock()
	if cm.VConfig != nil {
		cm.VConfig.SetLevel(VLevel)
	} else {
		VConfig, configErr := cm.LoadConfig()
		if configErr != nil {
			log.Printf("ErrorCtx loading configuration: %v\n", configErr)
			return
		}
		VConfig.SetLevel(VLevel)
		cm.VConfig = VConfig
	}
}

func (cm *ConfigManagerImpl) SetFormat(format interface{}) {
	cm.Mu.Lock()
	defer cm.Mu.Unlock()
	if cm.VConfig != nil {
		cm.VConfig.SetFormat(format)
	} else {
		VConfig, configErr := cm.LoadConfig()
		if configErr != nil {
			log.Printf("ErrorCtx loading configuration: %v\n", configErr)
			return
		}
		VConfig.SetFormat(format)
		cm.VConfig = VConfig
	}
}

// GetFormatter returns the formatter for the core.
func (cm *ConfigManagerImpl) GetFormatter() interface{} {
	switch cm.VConfig.Format() {
	case "text":
		return &TextFormatter{}
	default:
		return &JSONFormatter{}
	}
}

// LoadConfig loads the configuration from the file and returns a Config instance.
func (cm *ConfigManagerImpl) LoadConfig() (Config, error) {
	cm.Mu.Lock()
	defer cm.Mu.Unlock()
	configPath := cm.GetConfigPath()
	if err := ensureConfigExists(configPath); err != nil {
		return nil, fmt.Errorf("failed to ensure VConfig exists: %w", err)
	}

	viperObj := viper.New()
	viperObj.SetConfigFile(configPath)
	viperObj.SetConfigType(getConfigType(configPath))

	if readErr := viperObj.ReadInConfig(); readErr != nil {
		return nil, fmt.Errorf("failed to read VConfig: %w", readErr)
	}

	notifierManager := NewNotifierManager(nil)
	if notifierManager == nil {
		return nil, fmt.Errorf("failed to create notifier manager")
	}

	VMode := LogMode(viperObj.GetString("VMode"))
	if VMode != ModeService && VMode != ModeStandalone {
		VMode = defaultMode
	}

	VConfig := ConfigImpl{
		VlPort:            getOrDefault(viperObj.GetString("port"), defaultPort),
		VlBindAddress:     getOrDefault(viperObj.GetString("bindAddress"), defaultBindAddress),
		VlAddress:         fmt.Sprintf("%s:%s", defaultBindAddress, defaultPort),
		VlPidFile:         viperObj.GetString("pidFile"),
		VlReadTimeout:     viperObj.GetDuration("readTimeout"),
		VlWriteTimeout:    viperObj.GetDuration("writeTimeout"),
		VlIdleTimeout:     viperObj.GetDuration("idleTimeout"),
		VlOutput:          getOrDefault(viperObj.GetString("defaultLogPath"), defaultLogPath),
		VlNotifierManager: notifierManager,
		VlMode:            VMode,
	}

	cm.VConfig = &VConfig

	viperObj.WatchConfig()
	viperObj.OnConfigChange(func(e fsnotify.Event) {
		log.Printf("Configuration changed: %s", e.Name)
		// Update Config dynamically, if necessary
	})

	return cm.VConfig, nil
}

// NewConfigManager creates a new instance of ConfigManager.
func NewConfigManager() *ConfigManager {
	cfgMgr := &ConfigManagerImpl{}

	if cfg, err := cfgMgr.LoadConfig(); err != nil || cfg == nil {
		log.Printf("ErrorCtx loading configuration: %v\n", err)
		return nil
	}

	var cfgM ConfigManager
	cfgM = cfgMgr

	return &cfgM
}

// ensureConfigExists checks if the configuration file exists, and creates it with default values if it does not.
func ensureConfigExists(configPath string) error {
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		defaultConfig := ConfigImpl{
			VlPort:            defaultPort,
			VlBindAddress:     defaultBindAddress,
			VlAddress:         fmt.Sprintf("%s:%s", defaultBindAddress, defaultPort),
			VlPidFile:         "logz_srv.pid",
			VlReadTimeout:     15 * time.Second,
			VlWriteTimeout:    15 * time.Second,
			VlIdleTimeout:     60 * time.Second,
			VlOutput:          defaultLogPath,
			VlNotifierManager: NewNotifierManager(nil),
			VlMode:            defaultMode,
		}
		data, _ := json.MarshalIndent(defaultConfig, "", "  ")
		if writeErr := os.WriteFile(configPath, data, 0644); writeErr != nil {
			return fmt.Errorf("failed to create default VConfig: %w", writeErr)
		}
	}
	return nil
}

func getConfigType(configPath string) string {
	configType := filepath.Ext(configPath)
	switch configType {
	case ".yaml":
		return "yaml"
	case ".yml":
		return "yaml"
	case ".toml":
		return "toml"
	case ".ini":
		return "ini"
	default:
		return "json"
	}

}

// getOrDefault returns the value if it is not empty, otherwise returns the default value.
func getOrDefault(value, defaultValue string) string {
	if value == "" {
		return defaultValue
	}
	return value
}

/// internal/core/config_manager.go ///
package core

import (
	//"fmt"
	//c "github.com/kubex-ecosystem/kubex-interfaces/config"

	//c "github.com/kubex-ecosystem/kubex-interfaces/config"
	//"os"
	//"path/filepath"
	"time"
)

// LogzConfig specific to Logz
type LogzConfig struct {
	LogLevel     string
	LogFormat    string
	LogFilePath  string
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
	PidFile      string
}

//func (lc *LogzConfig) Validate() error {
//	if lc.LogLevel == "" {
//		return fmt.Errorf("LogLevel cannot be empty")
//	}
//	if lc.LogFilePath == "" {
//		return fmt.Errorf("LogFilePath cannot be empty")
//	}
//	return nil
//}
//
//// LogzConfigManager with validation support
//type LogzConfigManager struct {
//	*LogzConfig
//	config *LogzConfig
//}

//func NewLogzConfigManager() *LogzConfigManager {
//	return NewConfigManager()
//	//return &LogzConfigManager{
//	//	LogzConfig: &cfg
//	//}
//}

//func (lcm *LogzConfigManager) ValidateConfig() error {
//	if config, ok := any(lcm).(c.Configurable); ok {
//		return config.Validate()
//	}
//	return fmt.Errorf("invalid configuration or validation not supported")
//}
//
//func (lcm *LogzConfigManager) GetConfig() *LogzConfig { return lcm.config }
//
//// GetPidPath returns the path to the PID file.
//func (lcm *LogzConfigManager) GetPidPath() string {
//	cacheDir, cacheDirErr := os.UserCacheDir()
//	if cacheDirErr != nil {
//		cacheDir = "/tmp"
//	}
//	cacheDir = filepath.Join(cacheDir, "logz", lcm.config.PidFile)
//	if mkdirErr := os.MkdirAll(filepath.Dir(cacheDir), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
//		return ""
//	}
//	return cacheDir
//}
//
//// GetConfigPath returns the path to the configuration file.
//func (lcm *LogzConfigManager) GetConfigPath() string {
//	if lcm.config != nil {
//		if lcm.Output() != "" {
//			return lcm.Output()
//		}
//	}
//
//	home, homeErr := os.UserHomeDir()
//	if homeErr != nil {
//		home, homeErr = os.UserConfigDir()
//		if homeErr != nil {
//			home, homeErr = os.UserCacheDir()
//			if homeErr != nil {
//				home = "/tmp"
//			}
//		}
//	}
//	configPath := filepath.Join(home, ".kubex", "logz", "VConfig.json")
//	if mkdirErr := os.MkdirAll(filepath.Dir(configPath), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
//		return ""
//	}
//	return configPath
//}
//
//// SetOutput sets the path to the default log file.
//func (lcm *LogzConfigManager) SetOutput(output string) {
//	if lcm.config != nil {
//		lcm.SetOutput(output)
//	} else {
//		fmt.Println("Cannot set output in standalone VMode")
//	}
//}
//
//// Output returns the path to the configuration file.
//func (lcm *LogzConfigManager) Output() string {
//	if lcm.config != nil {
//		if lcm.Output() != "" {
//			return lcm.Output()
//		}
//	}
//	home, homeErr := os.UserHomeDir()
//	if homeErr != nil {
//		home, homeErr = os.UserConfigDir()
//		if homeErr != nil {
//			home, homeErr = os.UserCacheDir()
//			if homeErr != nil {
//				home = "/tmp"
//			}
//		}
//	}
//	logPath := filepath.Join(home, ".kubex", "logz", "logz.log")
//	if mkdirErr := os.MkdirAll(filepath.Dir(logPath), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
//		return ""
//	}
//	if _, err := os.Stat(logPath); os.IsNotExist(err) {
//		if _, createErr := os.Create(logPath); createErr != nil {
//			return ""
//		}
//	}
//	return logPath
//}
//
//func (lcm *LogzConfigManager) SetLevel(level LogLevel) { lcm.config.LogLevel = string(level) }
//
//func (lcm *LogzConfigManager) SetFormat(format LogFormat) {
//	lcm.config.LogFormat = string(format)
//}
//
//// GetFormatter returns the formatter for the core.
//func (lcm *LogzConfigManager) GetFormatter() LogFormatter {
//	switch lcm.config.LogFormat {
//	case "text":
//		return &TextFormatter{}
//	default:
//		return &JSONFormatter{}
//	}
//}

// LoadConfig loads the configuration from the file and returns a Config instance.
// func (lcm *LogzConfigManager) LoadConfig() (*LogzConfig, error) {
// 	cfg, err := InitConfigManager()
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to initialize the configuration manager: %w", err)
// 	}

// 	// Load the configuration from the file
// 	cf := cfg.GetConfig()

// 	// Validate the configuration
// 	if err := cf.Validate(); err != nil {
// 		return nil, fmt.Errorf("failed to validate the configuration: %w", err)
// 	}

// 	// Save the configuration
// 	lcm.VConfig = &cf

// 	return lcm.VConfig, nil
// }

/// internal/core/integration_test.go ///
package core

//func TestIntegrationLogger(t *testing.T) {
//	configManager := NewConfigManager()
//	if configManager == nil {
//		t.Fatal("ErrorCtx initializing ConfigManager.")
//	}
//	cfgMgr := *configManager
//	config, err := cfgMgr.LoadConfig()
//	if err != nil {
//		t.Fatalf("ErrorCtx loading configuration: %v", err)
//	}
//	logger := NewLogger(config)
//	if logger == nil {
//		t.Fatal("ErrorCtx creating core.")
//	}
//
//	var buf bytes.Buffer
//	logger.SetWriter(NewDefaultWriter(&buf, &TextFormatter{}))
//
//	logger.DebugCtx("debug message", nil)
//	if !bytes.Contains(buf.Bytes(), []byte("DEBUG")) {
//		t.Errorf("Expected 'DEBUG' log entry, got '%s'", buf.String())
//	}
//
//	logger.InfoCtx("info message", nil)
//	if !bytes.Contains(buf.Bytes(), []byte("INFO")) {
//		t.Errorf("Expected 'INFO' log entry, got '%s'", buf.String())
//	}
//
//	logger.WarnCtx("warn message", nil)
//	if !bytes.Contains(buf.Bytes(), []byte("WARN")) {
//		t.Errorf("Expected 'WARN' log entry, got '%s'", buf.String())
//	}
//
//	logger.ErrorCtx("error message", nil)
//	if !bytes.Contains(buf.Bytes(), []byte("ERROR")) {
//		t.Errorf("Expected 'ERROR' log entry, got '%s'", buf.String())
//	}
//}
//
//func TestIntegrationConcurrentAccess(t *testing.T) {
//	configManager := NewConfigManager()
//	if configManager == nil {
//		t.Fatal("ErrorCtx initializing ConfigManager.")
//	}
//	cfgMgr := *configManager
//	config, err := cfgMgr.LoadConfig()
//	if err != nil {
//		t.Fatalf("ErrorCtx loading configuration: %v", err)
//	}
//	logger := NewLogger(config)
//	if logger == nil {
//		t.Fatal("ErrorCtx creating core.")
//	}
//
//	var wg sync.WaitGroup
//	for i := 0; i < 100; i++ {
//		wg.Add(1)
//		go func(i int) {
//			defer wg.Done()
//			logger.SetMetadata("key", i)
//			logger.DebugCtx("concurrent message", nil)
//		}(i)
//	}
//	wg.Wait()
//}
//
//func TestIntegrationLogRotation(t *testing.T) {
//	configManager := NewConfigManager()
//	if configManager == nil {
//		t.Fatal("ErrorCtx initializing ConfigManager.")
//	}
//	cfgMgr := *configManager
//	config, err := cfgMgr.LoadConfig()
//	if err != nil {
//		t.Fatalf("ErrorCtx loading configuration: %v", err)
//	}
//	logger := NewLogger(config)
//	if logger == nil {
//		t.Fatal("ErrorCtx creating core.")
//	}
//
//	logFile := config.Output()
//	defer os.Remove(logFile)
//
//	for i := 0; i < 1000; i++ {
//		logger.InfoCtx("log rotation test message", nil)
//	}
//
//	err = CheckLogSize(config)
//	if err != nil {
//		t.Fatalf("ErrorCtx checking log size: %v", err)
//	}
//
//	_, err = os.Stat(logFile + ".tar.gz")
//	if os.IsNotExist(err) {
//		t.Errorf("Expected log rotation to create archive, but it did not.")
//	}
//}
//
//func TestIntegrationDynamicConfigChanges(t *testing.T) {
//	configManager := NewConfigManager()
//	if configManager == nil {
//		t.Fatal("ErrorCtx initializing ConfigManager.")
//	}
//	cfgMgr := *configManager
//	config, err := cfgMgr.LoadConfig()
//	if err != nil {
//		t.Fatalf("ErrorCtx loading configuration: %v", err)
//	}
//	logger := NewLogger(config)
//	if logger == nil {
//		t.Fatal("ErrorCtx creating core.")
//	}
//
//	viper.Set("logLevel", "DEBUG")
//	time.Sleep(1 * time.Second)
//
//	if logger.GetLevel() != DEBUG {
//		t.Errorf("Expected log VLevel to be 'DEBUG', got '%v'", logger.GetLevel())
//	}
//}
//
//func TestIntegrationNotifierManager(t *testing.T) {
//	configManager := NewConfigManager()
//	if configManager == nil {
//		t.Fatal("ErrorCtx initializing ConfigManager.")
//	}
//	cfgMgr := *configManager
//	config, err := cfgMgr.LoadConfig()
//	if err != nil {
//		t.Fatalf("ErrorCtx loading configuration: %v", err)
//	}
//	logger := NewLogger(config)
//	if logger == nil {
//		t.Fatal("ErrorCtx creating core.")
//	}
//
//	notifierManager := config.NotifierManager()
//	if notifierManager == nil {
//		t.Fatal("ErrorCtx initializing NotifierManager.")
//	}
//
//	notifierManager.AddNotifier("testNotifier", NewHTTPNotifier("http://example.com", ""))
//	if _, ok := notifierManager.GetNotifier("testNotifier"); !ok {
//		t.Errorf("Expected 'testNotifier' to be added, but it was not.")
//	}
//
//	notifierManager.RemoveNotifier("testNotifier")
//	if _, ok := notifierManager.GetNotifier("testNotifier"); ok {
//		t.Errorf("Expected 'testNotifier' to be removed, but it was not.")
//	}
//}
//
//func TestIntegrationService(t *testing.T) {
//	go func() {
//		if err := Run(); err != nil {
//			t.Fatalf("ErrorCtx running service: %v", err)
//		}
//	}()
//	time.Sleep(1 * time.Second)
//
//	resp, err := http.Get("http://localhost:9999/health")
//	if err != nil {
//		t.Fatalf("ErrorCtx making HTTP request: %v", err)
//	}
//	defer resp.Body.Close()
//
//	if resp.StatusCode != http.StatusOK {
//		t.Errorf("Expected status code 200, got %d", resp.StatusCode)
//	}
//
//	if err := Stop(); err != nil {
//		t.Fatalf("ErrorCtx stopping service: %v", err)
//	}
//}

/// internal/core/interface.go ///
package core

// LogzLogger combines the existing core with the standard Go log methods.
type LogzLogger interface {
	LogzCore
	// GetLevel returns the current log VLevel.
	// Method signature:
	// GetLevel() interface{}
	GetLevel() interface{}
	// SetLevel sets the log VLevel.
	// Method signature:
	// SetLevel(VLevel interface{})
	// The VLevel is an LogLevel type or string.
	SetLevel(interface{})
}

// LogzCore is the interface with the basic methods of the existing il.
type LogzCore interface {

	// SetMetadata sets a VMetadata key-value pair.
	// If the key is empty, it returns all VMetadata.
	// Returns the value and a boolean indicating if the key exists.
	SetMetadata(string, interface{})
	// TraceCtx logs a trace message with context.
	// Method signature:
	// TraceCtx(message string, context map[string]interface{})
	// The message is a string.
	// The context is a map of key-value pairs.
	TraceCtx(string, map[string]interface{})
	// NoticeCtx logs a notice message with context.
	// Method signature:
	// NoticeCtx(message string, context map[string]interface{})
	// The message is a string.
	// The context is a map of key-value pairs.
	NoticeCtx(string, map[string]interface{})
	// SuccessCtx logs a success message with context.
	// Method signature:
	// SuccessCtx(message string, context map[string]interface{})
	// The message is a string.
	// The context is a map of key-value pairs.
	SuccessCtx(string, map[string]interface{})
	// DebugCtx logs a debug message with context.
	// Method signature:
	// DebugCtx(message string, context map[string]interface{})
	// The message is a string.
	// The context is a map of key-value pairs.
	DebugCtx(string, map[string]interface{})
	// InfoCtx logs an informational message with context.
	// Method signature:
	// InfoCtx(message string, context map[string]interface{})
	// The message is a string.
	// The context is a map of key-value pairs.
	InfoCtx(string, map[string]interface{})
	// WarnCtx logs a warning message with context.
	// Method signature:
	// WarnCtx(message string, context map[string]interface{})
	// The message is a string.
	// The context is a map of key-value pairs.
	WarnCtx(string, map[string]interface{})
	// ErrorCtx logs an error message with context.
	// Method signature:
	// ErrorCtx(message string, context map[string]interface{})
	// The message is a string.
	// The context is a map of key-value pairs.
	ErrorCtx(string, map[string]interface{})
	// FatalCtx logs a fatal message with context and exits the application.
	// Method signature:
	// FatalCtx(message string, context map[string]interface{})
	// The message is a string.
	// The context is a map of key-value pairs.
	FatalCtx(string, map[string]interface{})
	// GetWriter returns the current VWriter.
	// Method signature:
	// GetWriter() interface{}
	// The VWriter is an interface that implements the LogWriter interface.
	GetWriter() interface{}
	// SetWriter sets the VWriter.
	// Method signature:
	// SetWriter(VWriter interface{})
	// The VWriter is an interface that implements the LogWriter interface or io.Writer.
	SetWriter(interface{})
	// GetConfig returns the current configuration.
	// Method signature:
	// GetConfig() interface{}
	// The configuration is an interface that implements the Config interface.
	GetConfig() interface{}
	// SetConfig sets the configuration.
	SetConfig(interface{})
	// SetFormat sets the format for the log entries.
	SetFormat(interface{})
	//// GetLevel returns the current log VLevel.
	//// Method signature:
	//// GetLevel() interface{}
	//GetLevel() interface{}
	//// SetLevel sets the log VLevel.
	//// Method signature:
	//// SetLevel(VLevel interface{})
	//// The VLevel is an LogLevel type or string.
	//SetLevel(interface{})
}

/// internal/core/log_rotate.go ///
package core

import (
	"archive/tar"
	"archive/zip"
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// CheckLogSize checks and manages the size of the logs
func CheckLogSize(config Config) error {
	logDir := config.Output()
	files, err := os.ReadDir(logDir)
	if err != nil {
		fmt.Println("ErrorCtx reading the log directory:", err)
		return err
	}

	// Fetch maximum log sizes from the configuration
	maxLogSize := config.GetInt("maxLogSize", 20*1024*1024)      // Default 20 MB
	moduleLogSize := config.GetInt("moduleLogSize", 5*1024*1024) // Default 5 MB

	var totalSize int64
	filesToRotate := []string{}

	for _, file := range files {
		if strings.HasSuffix(file.Name(), ".log") {
			fileInfo, err := file.Info()
			if err != nil {
				fmt.Println("ErrorCtx getting file information:", err)
				continue
			}
			totalSize += fileInfo.Size()
			if fileInfo.Size() > int64(moduleLogSize) {
				filesToRotate = append(filesToRotate, filepath.Join(logDir, file.Name()))
			}
		}
	}

	// Rotation based on total size
	if totalSize > int64(maxLogSize) {
		fmt.Println("Archiving logs due to excessive size...")
		if err := ArchiveLogs(filesToRotate); err != nil {
			fmt.Println("ErrorCtx archiving logs:", err)
			return err
		}
	}

	// Individual rotation of large files
	if len(filesToRotate) > 0 {
		fmt.Println("Rotating large log files...")
		if err := RotateLogFiles(filesToRotate); err != nil {
			fmt.Println("ErrorCtx rotating log files:", err)
			return err
		}
	}

	return nil
}

// RotateLogFiles compresses and recreates the log files
func RotateLogFiles(files []string) error {
	for _, logFile := range files {
		if err := RotateLogFile(logFile); err != nil {
			fmt.Println("ErrorCtx rotating the log file:", err)
			continue
		}
		fmt.Println("Log file rotated successfully:", logFile)
	}
	return nil
}

// RotateLogFile compresses a single log file
func RotateLogFile(logFilePath string) error {
	archivePath := fmt.Sprintf("%s.tar.gz", logFilePath)
	if err := CreateTarGz(archivePath, []string{logFilePath}); err != nil {
		return err
	}

	if err := os.Remove(logFilePath); err != nil {
		return fmt.Errorf("error removing the log file: %v", err)
	}

	if err := os.WriteFile(logFilePath, []byte{}, 0644); err != nil {
		return fmt.Errorf("error recreating the log file: %v", err)
	}
	return nil
}

// CreateTarGz creates a tar.gz file from the logs
func CreateTarGz(archivePath string, files []string) error {
	archiveFile, err := os.Create(archivePath)
	if err != nil {
		return fmt.Errorf("error creating the tar.gz file: %v", err)
	}
	defer archiveFile.Close()

	gw := gzip.NewWriter(archiveFile)
	defer gw.Close()

	tw := tar.NewWriter(gw)
	defer tw.Close()

	for _, file := range files {
		if err := addFileToTar(tw, file); err != nil {
			return err
		}
	}
	fmt.Println("Logs archived successfully:", archivePath)
	return nil
}

// addFileToTar adds a file to the tar archive
func addFileToTar(tw *tar.Writer, filePath string) error {
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("error opening the file: %v", err)
	}
	defer file.Close()

	info, err := file.Stat()
	if err != nil {
		return fmt.Errorf("error getting file information: %v", err)
	}

	header, err := tar.FileInfoHeader(info, "")
	if err != nil {
		return fmt.Errorf("error creating the tar header: %v", err)
	}
	header.Name = filepath.Base(filePath)

	if err := tw.WriteHeader(header); err != nil {
		return fmt.Errorf("error writing the tar header: %v", err)
	}

	if _, err := io.Copy(tw, file); err != nil {
		return fmt.Errorf("error copying the file content to the tar: %v", err)
	}

	return nil
}

// ArchiveLogs archives old logs into a zip file
func ArchiveLogs(files []string) error {
	logDir := GetLogPath()
	if len(files) == 0 {
		err := filepath.Walk(logDir, func(path string, info os.FileInfo, err error) error {
			if strings.HasSuffix(info.Name(), ".log") {
				files = append(files, path)
			}
			return nil
		})
		if err != nil {
			return fmt.Errorf("error listing the log files: %v", err)
		}
	}
	tempDir := os.TempDir()
	archiveName := fmt.Sprintf("logs_archive_%s.zip", time.Now().Format("20060102_150405"))
	archivePath := filepath.Join(tempDir, archiveName)

	zipFile, err := os.Create(archivePath)
	if err != nil {
		return fmt.Errorf("error creating the zip file: %v", err)
	}
	defer zipFile.Close()

	zipWriter := zip.NewWriter(zipFile)
	defer zipWriter.Close()

	for _, file := range files {
		if err := addFileToZip(zipWriter, file); err != nil {
			return err
		}
	}

	fmt.Println("Logs archived successfully:", archivePath)
	return nil
}

// addFileToZip adds a file to the zip archive
func addFileToZip(zipWriter *zip.Writer, filePath string) error {
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("error opening the file for zip: %v", err)
	}
	defer file.Close()

	info, err := file.Stat()
	if err != nil {
		return fmt.Errorf("error getting file information: %v", err)
	}

	header, err := zip.FileInfoHeader(info)
	if err != nil {
		return fmt.Errorf("error creating the zip header: %v", err)
	}
	header.Name = filepath.Base(filePath)

	writer, err := zipWriter.CreateHeader(header)
	if err != nil {
		return fmt.Errorf("error creating the file in the zip: %v", err)
	}

	if _, err := io.Copy(writer, file); err != nil {
		return fmt.Errorf("error copying the file content to the zip: %v", err)
	}

	return nil
}

func GetLogDirectorySize(directory string) (int64, error) {
	if directory == "" {
		directory = filepath.Dir(GetLogPath())
	}
	var totalSize int64

	// Traverse the specified directory
	err := filepath.Walk(directory, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("error accessing the path %s: %v", path, err)
		}

		// Only files are considered in the total size
		if !info.IsDir() {
			totalSize += info.Size()
		}

		return nil
	})

	if err != nil {
		return 0, fmt.Errorf("error calculating the directory size: %v", err)
	}

	return totalSize, nil
}

/// internal/core/logentry.go ///
package core

import (
	"errors"
	"fmt"
	"runtime"
	"time"
)

// LogLevel represents the severity VLevel of a log entry.
type LogLevel string

const (
	DEBUG   LogLevel = "DEBUG"
	TRACE   LogLevel = "TRACE"
	NOTICE  LogLevel = "NOTICE"
	INFO    LogLevel = "INFO"
	SUCCESS LogLevel = "SUCCESS"
	WARN    LogLevel = "WARN"
	ERROR   LogLevel = "ERROR"
	FATAL   LogLevel = "FATAL"
	SILENT  LogLevel = "SILENT"
)

// LogzEntry represents a single log entry with various attributes.
type LogzEntry interface {
	// WithLevel sets the log VLevel for the LogEntry.
	WithLevel(level LogLevel) LogzEntry
	// WithSource sets the source for the LogEntry.
	WithSource(source string) LogzEntry
	// WithContext sets the context for the LogEntry.
	WithContext(context string) LogzEntry
	// WithMessage sets the message for the LogEntry.
	WithMessage(message string) LogzEntry
	// WithProcessID sets the process ID for the LogEntry.
	WithProcessID(pid int) LogzEntry
	// WithHostname sets the hostname for the LogEntry.
	WithHostname(hostname string) LogzEntry
	// WithSeverity sets the severity VLevel for the LogEntry.
	WithSeverity(severity int) LogzEntry
	// WithTraceID sets the trace ID for the LogEntry.
	WithTraceID(traceID string) LogzEntry
	// AddTag adds a tag to the LogEntry.
	AddTag(key, value string) LogzEntry
	// AddMetadata adds VMetadata to the LogEntry.
	AddMetadata(key string, value interface{}) LogzEntry
	// GetMetadata returns the VMetadata of the LogEntry.
	GetMetadata() map[string]interface{}
	// GetContext returns the context of the LogEntry.
	GetContext() string
	// GetTimestamp returns the timestamp of the LogEntry.
	GetTimestamp() time.Time
	// GetMessage returns the message of the LogEntry.
	GetMessage() string
	// GetLevel returns the log VLevel of the LogEntry.
	GetLevel() LogLevel
	// GetSource returns the source of the LogEntry.
	GetSource() string
	// Validate checks if the LogEntry has all required fields set.
	Validate() error
	// String returns a string representation of the LogEntry.
	String() string
}

// LogEntry represents a single log entry with various attributes.
type LogEntry struct {
	Timestamp time.Time              `json:"timestamp"`           // The time when the log entry was created.
	Level     LogLevel               `json:"VLevel"`              // The severity VLevel of the log entry.
	Source    string                 `json:"source"`              // The source of the log entry.
	Context   string                 `json:"context,omitempty"`   // Additional context for the log entry.
	Message   string                 `json:"message"`             // The log message.
	Tags      map[string]string      `json:"tags,omitempty"`      // Optional tags associated with the log entry.
	Metadata  map[string]interface{} `json:"VMetadata,omitempty"` // Optional VMetadata associated with the log entry.
	ProcessID int                    `json:"pid,omitempty"`       // The process ID associated with the log entry.
	Hostname  string                 `json:"hostname,omitempty"`  // The hostname where the log entry was created.
	Severity  int                    `json:"severity"`            // The severity VLevel as an integer.
	TraceID   string                 `json:"trace_id,omitempty"`  // Optional trace ID for tracing logs.
	Caller    string                 `json:"caller,omitempty"`    // The caller of the log entry.
}

// NewLogEntry creates a new instance of LogEntry with the current timestamp and initialized maps.
func NewLogEntry() LogzEntry {
	le := LogEntry{
		Timestamp: time.Now(),
		Tags:      make(map[string]string),
		Metadata:  make(map[string]interface{}),
		Caller:    getCallerInfo(3),
	}
	return &le
}

// WithLevel sets the log VLevel for the LogEntry.
func (le *LogEntry) WithLevel(level LogLevel) LogzEntry {
	le.Level = level
	return le
}

// WithSource sets the source for the LogEntry.
func (le *LogEntry) WithSource(source string) LogzEntry {
	le.Source = source
	return le
}

// WithContext sets the context for the LogEntry.
func (le *LogEntry) WithContext(context string) LogzEntry {
	le.Context = context
	return le
}

// WithMessage sets the message for the LogEntry.
func (le *LogEntry) WithMessage(message string) LogzEntry {
	le.Message = message
	return le
}

// WithProcessID sets the process ID for the LogEntry.
func (le *LogEntry) WithProcessID(pid int) LogzEntry {
	le.ProcessID = pid
	return le
}

// WithHostname sets the hostname for the LogEntry.
func (le *LogEntry) WithHostname(hostname string) LogzEntry {
	le.Hostname = hostname
	return le
}

// WithSeverity sets the severity VLevel for the LogEntry.
func (le *LogEntry) WithSeverity(severity int) LogzEntry {
	le.Severity = severity
	return le
}

// WithTraceID sets the trace ID for the LogEntry.
func (le *LogEntry) WithTraceID(traceID string) LogzEntry {
	le.TraceID = traceID
	return le
}

// AddTag adds a tag to the LogEntry.
func (le *LogEntry) AddTag(key, value string) LogzEntry {
	if le.Tags == nil {
		le.Tags = make(map[string]string)
	}
	le.Tags[key] = value
	return le
}

// GetLevel returns the log VLevel of the LogEntry.
func (le *LogEntry) GetLevel() LogLevel { return le.Level }

// AddMetadata adds VMetadata to the LogEntry.
func (le *LogEntry) AddMetadata(key string, value interface{}) LogzEntry {
	if le.Metadata == nil {
		le.Metadata = make(map[string]interface{})
	}
	le.Metadata[key] = value
	return le
}

// GetMetadata returns the VMetadata of the LogEntry.
func (le *LogEntry) GetMetadata() map[string]interface{} { return le.Metadata }

// GetContext returns the context of the LogEntry.
func (le *LogEntry) GetContext() string { return le.Context }

// GetTimestamp returns the timestamp of the LogEntry.
func (le *LogEntry) GetTimestamp() time.Time { return le.Timestamp }

// GetMessage returns the message of the LogEntry.
func (le *LogEntry) GetMessage() string { return le.Message }

// GetSource returns the source of the LogEntry.
func (le *LogEntry) GetSource() string { return le.Source }

// Validate checks if the LogEntry has all required fields set.
func (le *LogEntry) Validate() error {
	if le.Timestamp.IsZero() {
		return errors.New("timestamp is required")
	}
	if le.Level == "" {
		return errors.New("VLevel is required")
	}
	if le.Message == "" {
		return errors.New("message is required")
	}
	if le.Severity <= 0 {
		return errors.New("severity must be greater than zero")
	}
	return nil
}

// String returns a string representation of the LogEntry.
func (le *LogEntry) String() string {
	return fmt.Sprintf("[%s] %s - %s",
		le.Timestamp.Format(time.RFC3339),
		le.Level,
		le.Message)
}

// getCallerInfo returns the caller information for the log entry.
func getCallerInfo(skip int) string {
	pc, file, line, ok := runtime.Caller(skip)
	if !ok {
		return "unknown"
	}
	funcName := runtime.FuncForPC(pc).Name()
	return fmt.Sprintf("%s:%d %s", trimFilePath(file), line, funcName)
}

/// internal/core/logger.go ///
package core

import (
	"io"
	"sync/atomic"

	//"io"
	"log"
	"os"
	"strings"
	"sync"
)

type LogMode string
type LogFormat string

const (
	JSON LogFormat = "json"
	TEXT LogFormat = "text"
	YAML LogFormat = "yaml"
	XML  LogFormat = "xml"
	RAW  LogFormat = "raw"
)

const (
	ModeService    LogMode = "service"    // Indicates that the core is being used by a detached process
	ModeStandalone LogMode = "standalone" // Indicates that the core is being used locally (e.g., CLI)
)

var logLevels = map[LogLevel]int{
	DEBUG:   1,
	TRACE:   2,
	INFO:    3,
	NOTICE:  4,
	SUCCESS: 5,
	WARN:    6,
	ERROR:   7,
	FATAL:   8,
	SILENT:  9,
}

// LogzCoreImpl represents a core with configuration and VMetadata.
type LogzCoreImpl struct {
	// LogzLogger is a constraint to implement this interface
	LogzLogger

	// Logger is a promoted global Go Logger
	log.Logger

	out       io.Writer                   // destination for output
	prefix    atomic.Pointer[string]      // prefix on each line to identify the logger (but see Lmsgprefix)
	prefixX   atomic.Pointer[*LogzLogger] // prefix on each line to identify the logger (but see Lmsgprefix)
	flag      atomic.Int32                // properties
	isDiscard atomic.Bool

	VLevel    LogLevel
	VWriter   LogWriter[any]
	VConfig   Config
	VMetadata map[string]interface{}
	VMode     LogMode // Mode control: service or standalone
	Mu        sync.RWMutex
}

// NewLogger creates a new instance of LogzCoreImpl with the provided configuration.
func NewLogger(prefix string) LogzLogger { //VConfig Config) LogzLogger {
	level := INFO // Default log VLevel

	//if VConfig == nil {
	// If no VConfig is provided, create a new default VConfig
	// Create a new ConfigManager
	//if cfgMgr := NNewConfigManager(); cfgMgr != nil {
	//	configMgr := *cfgMgr
	//	VConfig = configMgr.GetConfig()
	//} else {
	//	log.Println("ErrorCtx creating ConfigManager")
	//	return nil
	//}
	//}

	// Set the log VLevel from the Config
	//VLevel = LogLevel(VConfig.Level()) // Method VConfig.Level() returns the log VLevel as a string

	//var out *os.File
	//var err error
	//// Set the output to stdout if not specified or if the output is invalid
	//if strings.ToLower(VConfig.Output()) == "stdout" || VConfig.Output() == "" || VConfig.Output() == os.Stdout.Name() {
	//	out = os.Stdout
	//} else {
	//	fmt.Println("Output: ", VConfig.Output())
	//	// Ensure the log file exists and has the correct permissions
	//	if _, err = os.Stat(VConfig.Output()); os.IsNotExist(err) {
	//		if err = os.MkdirAll(filepath.Dir(VConfig.Output()), 0755); err != nil {
	//			log.Printf("ErrorCtx creating log directory: %v\nRedirecting to stdout...\n", err)
	//			out = os.Stdout
	//		} else {
	//			out, err = os.OpenFile(VConfig.Output(), os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	//			if err != nil {
	//				log.Printf("ErrorCtx opening log file: %v\nRedirecting to stdout...\n", err)
	//				out = os.Stdout
	//			}
	//		}
	//	} else {
	//		out, err = os.OpenFile(VConfig.Output(), os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	//		if err != nil {
	//			log.Printf("ErrorCtx opening log file: %v\nRedirecting to stdout...\n", err)
	//			out = os.Stdout
	//		}
	//	}
	//}
	//
	//// Initialize the formatter (JSON or text)
	//var formatter LogFormatter
	//if VConfig.Format() == "json" {
	//	formatter = &JSONFormatter{}
	//} else {
	//	formatter = &TextFormatter{}
	//}
	writer := NewDefaultWriter[any](os.Stdout, &TextFormatter{}) //out, formatter)

	// Read the VMode from Config
	//VMode := VConfig.Mode()
	//if VMode != ModeService && VMode != ModeStandalone {
	mode := ModeStandalone // Default to standalone if not specified
	//}

	lgr := &LogzCoreImpl{
		VLevel:  level,
		VWriter: writer,
		//VConfig:   VConfig,
		VMetadata: make(map[string]interface{}),
		VMode:     mode,
	}
	lgr.prefix.Store(&prefix)
	return lgr
}

// SetMetadata sets a VMetadata key-value pair for the LogzCoreImpl.
func (l *LogzCoreImpl) SetMetadata(key string, value interface{}) {
	l.Mu.Lock()
	defer l.Mu.Unlock()
	l.VMetadata[key] = value
}

// shouldLog checks if the log VLevel should be logged.
func (l *LogzCoreImpl) shouldLog(level LogLevel) bool {
	return logLevels[level] >= logLevels[l.VLevel]
}

// log logs a message with the specified VLevel and context.
func (l *LogzCoreImpl) log(level LogLevel, msg string, ctx map[string]interface{}) {
	if !l.shouldLog(level) {
		return
	}

	l.Mu.RLock()
	defer l.Mu.RUnlock()

	entry := NewLogEntry().
		WithLevel(level).
		WithMessage(msg).
		WithSeverity(logLevels[level])

	// Merge global and local VMetadata
	finalContext := mergeContext(l.VMetadata, ctx)
	for k, v := range finalContext {
		entry.AddMetadata(k, v)
	}

	// Merge global and local VMetadata
	finalMetadata := mergeMetadata(l.VMetadata, ctx)
	for k, v := range finalMetadata {
		entry.AddMetadata(k, v)
	}

	if level != SILENT {
		// Write the log using the configured VWriter
		if err := l.VWriter.Write(entry); err != nil {
			log.Printf("ErrorCtx writing log: %v", err)
		}
	}

	// Only in service VMode, notify via Notifiers
	if l.VMode == ModeService && l.VConfig != nil {
		//for _, name := range l.VConfig.NotifierManager().ListNotifiers() {
		//	if notifier, ok := l.VConfig.NotifierManager().GetNotifier(name); ok {
		//		if notifier != nil {
		//			ntf := notifier
		//			if ntfErr := ntf.Notify(entry); ntfErr != nil {
		//				log.Printf("ErrorCtx notifying %s: %v", name, ntfErr)
		//			}
		//		}
		//	}
		//}
	}

	// Update metrics in PrometheusManager, if enabled
	if l.VMode == ModeService {
		pm := GetPrometheusManager()
		if pm.IsEnabled() {
			pm.IncrementMetric("logs_total", 1)
			pm.IncrementMetric("logs_total_"+string(level), 1)
		}
	}

	// Terminate the process in case of FATAL log
	if level == FATAL {
		os.Exit(1)
	}
}

// TraceCtx logs a trace message with context.
func (l *LogzCoreImpl) TraceCtx(msg string, ctx map[string]interface{}) { l.log(TRACE, msg, ctx) }

// NoticeCtx logs a notice message with context.
func (l *LogzCoreImpl) NoticeCtx(msg string, ctx map[string]interface{}) { l.log(NOTICE, msg, ctx) }

// SuccessCtx logs a success message with context.
func (l *LogzCoreImpl) SuccessCtx(msg string, ctx map[string]interface{}) { l.log(SUCCESS, msg, ctx) }

// DebugCtx logs a debug message with context.
func (l *LogzCoreImpl) DebugCtx(msg string, ctx map[string]interface{}) { l.log(DEBUG, msg, ctx) }

// InfoCtx logs an info message with context.
func (l *LogzCoreImpl) InfoCtx(msg string, ctx map[string]interface{}) { l.log(INFO, msg, ctx) }

// WarnCtx logs a warning message with context.
func (l *LogzCoreImpl) WarnCtx(msg string, ctx map[string]interface{}) { l.log(WARN, msg, ctx) }

// ErrorCtx logs an error message with context.
func (l *LogzCoreImpl) ErrorCtx(msg string, ctx map[string]interface{}) { l.log(ERROR, msg, ctx) }

// FatalCtx logs a fatal message with context and terminates the process.
func (l *LogzCoreImpl) FatalCtx(msg string, ctx map[string]interface{}) { l.log(FATAL, msg, ctx) }

func (l *LogzCoreImpl) SetLevel(level interface{}) {
	l.Mu.Lock()
	defer l.Mu.Unlock()
	if lvl, ok := level.(LogLevel); ok {
		l.VLevel = lvl
	} else if lvlStr, ok := level.(string); ok {
		l.VLevel = LogLevel(lvlStr)
	} else {
		log.Println("Invalid log level type")
	}
}
func (l *LogzCoreImpl) GetLevel() interface{} {
	l.Mu.RLock()
	defer l.Mu.RUnlock()

	if l.VLevel == "" {
		l.VLevel = INFO
	}
	return l.VLevel
}

func (l *LogzCoreImpl) SetWriter(writer any) {
	l.Mu.Lock()
	defer l.Mu.Unlock()
	if osFile, ok := writer.(*os.File); ok {
		l.VWriter = NewDefaultWriter[any](osFile, &TextFormatter{})
	} else if logWriter, ok := writer.(LogWriter[any]); ok {
		l.VWriter = logWriter
	} else {
		log.Println("Invalid writer type")
	}
}
func (l *LogzCoreImpl) GetWriter() interface{} {
	l.Mu.RLock()
	defer l.Mu.RUnlock()
	if l.VWriter == nil {
		l.VWriter = NewDefaultWriter[any](os.Stdout, &TextFormatter{})
	}
	return l.VWriter
}

func (l *LogzCoreImpl) GetMode() interface{} {
	l.Mu.RLock()
	defer l.Mu.RUnlock()
	if l.VMode == "" {
		l.VMode = ModeStandalone
	}
	return l.VMode
}

func (l *LogzCoreImpl) SetConfig(config interface{}) {
	l.Mu.Lock()
	defer l.Mu.Unlock()
	if cfg, ok := config.(Config); ok {
		l.VConfig = cfg
	} else {
		log.Println("Invalid config type")
	}
}
func (l *LogzCoreImpl) GetConfig() interface{} {
	l.Mu.RLock()
	defer l.Mu.RUnlock()
	if l.VConfig == nil {
		c := NewConfigManager()
		c2 := *c
		c3 := c2.GetConfig()
		l.VConfig = c3
	}
	return l.VConfig
}

// trimFilePath trims the file path to show only the last two segments.
func trimFilePath(filePath string) string {
	parts := strings.Split(filePath, "/")
	if len(parts) > 2 {
		return strings.Join(parts[len(parts)-2:], "/")
	}
	return filePath
}

// mergeContext merges global and local context maps.
func mergeContext(global, local map[string]interface{}) map[string]interface{} {
	merged := make(map[string]interface{})
	for k, v := range global {
		merged[k] = v
	}
	for k, v := range local {
		merged[k] = v
	}
	return merged
}

// mergeMetadata merges global and local context maps.
func mergeMetadata(global, local map[string]interface{}) map[string]interface{} {
	merged := make(map[string]interface{})
	for k, v := range global {
		merged[k] = v
	}
	for k, v := range local {
		merged[k] = v
	}
	return merged
}

/// internal/core/logger_test.go ///
package core

/*func TestNewLogger(t *testing.T) {
	configManager := NewConfigManager()
	if configManager == nil {
		t.Fatal("ErrorCtx initializing ConfigManager.")
	}
	cfgMgr := *configManager
	config, err := cfgMgr.LoadConfig()
	if err != nil {
		t.Fatalf("ErrorCtx loading configuration: %v", err)
	}
	logger := NewLogger(config)
	if logger == nil {
		t.Fatal("ErrorCtx creating core.")
	}
}

func TestSetMetadata(t *testing.T) {
	configManager := NewConfigManager()
	if configManager == nil {
		t.Fatal("ErrorCtx initializing ConfigManager.")
	}
	cfgMgr := *configManager
	config, err := cfgMgr.LoadConfig()
	if err != nil {
		t.Fatalf("ErrorCtx loading configuration: %v", err)
	}
	logger := NewLogger(config)
	if logger == nil {
		t.Fatal("ErrorCtx creating core.")
	}

	logger.SetMetadata("key", "value")
	if logger.metadata["key"] != "value" {
		t.Errorf("Expected VMetadata 'key' to be 'value', got '%v'", logger.metadata["key"])
	}
}

func TestLogMethods(t *testing.T) {
	configManager := NewConfigManager()
	if configManager == nil {
		t.Fatal("ErrorCtx initializing ConfigManager.")
	}
	cfgMgr := *configManager
	config, err := cfgMgr.LoadConfig()
	if err != nil {
		t.Fatalf("ErrorCtx loading configuration: %v", err)
	}
	logger := NewLogger(config)
	if logger == nil {
		t.Fatal("ErrorCtx creating core.")
	}

	var buf bytes.Buffer
	logger.SetWriter(NewDefaultWriter[any](&buf, &TextFormatter{}))

	logger.DebugCtx("debug message", nil)
	if !bytes.Contains(buf.Bytes(), []byte("DEBUG")) {
		t.Errorf("Expected 'DEBUG' log entry, got '%s'", buf.String())
	}

	logger.InfoCtx("info message", nil)
	if !bytes.Contains(buf.Bytes(), []byte("INFO")) {
		t.Errorf("Expected 'INFO' log entry, got '%s'", buf.String())
	}

	logger.WarnCtx("warn message", nil)
	if !bytes.Contains(buf.Bytes(), []byte("WARN")) {
		t.Errorf("Expected 'WARN' log entry, got '%s'", buf.String())
	}

	logger.ErrorCtx("error message", nil)
	if !bytes.Contains(buf.Bytes(), []byte("ERROR")) {
		t.Errorf("Expected 'ERROR' log entry, got '%s'", buf.String())
	}
}

func TestConcurrentAccess(t *testing.T) {
	configManager := NewConfigManager()
	if configManager == nil {
		t.Fatal("ErrorCtx initializing ConfigManager.")
	}
	cfgMgr := *configManager
	config, err := cfgMgr.LoadConfig()
	if err != nil {
		t.Fatalf("ErrorCtx loading configuration: %v", err)
	}
	logger := NewLogger(config)
	if logger == nil {
		t.Fatal("ErrorCtx creating core.")
	}

	var wg sync.WaitGroup
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			logger.SetMetadata("key", i)
			logger.DebugCtx("concurrent message", nil)
		}(i)
	}
	wg.Wait()
}

func TestLogRotation(t *testing.T) {
	configManager := NewConfigManager()
	if configManager == nil {
		t.Fatal("ErrorCtx initializing ConfigManager.")
	}
	cfgMgr := *configManager
	config, err := cfgMgr.LoadConfig()
	if err != nil {
		t.Fatalf("ErrorCtx loading configuration: %v", err)
	}
	logger := NewLogger(config)
	if logger == nil {
		t.Fatal("ErrorCtx creating core.")
	}

	logFile := config.Output()
	defer os.Remove(logFile)

	for i := 0; i < 1000; i++ {
		logger.InfoCtx("log rotation test message", nil)
	}

	err = CheckLogSize(config)
	if err != nil {
		t.Fatalf("ErrorCtx checking log size: %v", err)
	}

	_, err = os.Stat(logFile + ".tar.gz")
	if os.IsNotExist(err) {
		t.Errorf("Expected log rotation to create archive, but it did not.")
	}
}

func TestDynamicConfigChanges(t *testing.T) {
	configManager := NewConfigManager()
	if configManager == nil {
		t.Fatal("ErrorCtx initializing ConfigManager.")
	}
	cfgMgr := *configManager
	config, err := cfgMgr.LoadConfig()
	if err != nil {
		t.Fatalf("ErrorCtx loading configuration: %v", err)
	}
	logger := NewLogger(config)
	if logger == nil {
		t.Fatal("ErrorCtx creating core.")
	}

	viper.Set("logLevel", "DEBUG")
	time.Sleep(1 * time.Second)

	if logger.GetLevel() != DEBUG {
		t.Errorf("Expected log VLevel to be 'DEBUG', got '%v'", logger.GetLevel())
	}
}
*/

/// internal/core/logz_manager.go ///
package core

/*import (
	iKbxCfg "github.com/kubex-ecosystem/kubex-interfaces/config"

	"fmt"
	"sync"
)

type LogInterface interface {
	Initialize(config iKbxCfg.ConfigManager[iKbxCfg.Configurable]) error
	Log(message string)
	Stop()
}

var (
	loggerRegistry = make(map[string]*LoggerInstance)
	registryMutex  sync.Mutex
)

type LoggerInstance struct {
	LogChannel  chan string
	DoneChannel chan bool
	Config      *iKbxCfg.ConfigManager[LogzConfig]
}

func (li *LoggerInstance) Start() {
	go func() {
		for {
			select {
			case log := <-li.LogChannel:
				fmt.Println("Log:", log)
			case <-li.DoneChannel:
				fmt.Println("Logger finalizado.")
				return
			}
		}
	}()
}

func GetLoggerInstance(name string, config *iKbxCfg.ConfigManager[LogzConfig]) (*LoggerInstance, error) {
	// Validate the configuration
	if config == nil {
		return nil, fmt.Errorf("configura√ß√£o inv√°lida")
	}

	// Necessary to validate the configuration because of the pointer receiver
	cfg := config.GetConfig()

	// Validate the configuration
	if err := cfg.Validate(); err != nil {
		return nil, fmt.Errorf("configura√ß√£o inv√°lida: %v", err)
	}

	registryMutex.Lock()
	defer registryMutex.Unlock()

	if logger, exists := loggerRegistry[name]; exists {
		return logger, nil
	}

	newLogger := &LoggerInstance{
		LogChannel:  make(chan string, 100),
		DoneChannel: make(chan bool),
		Config:      config,
	}
	newLogger.Start()
	loggerRegistry[name] = newLogger
	return newLogger, nil
}
*/

/// internal/core/notifier.go ///
package core

import (
	"github.com/godbus/dbus/v5"

	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

// Notifier defines the interface for a log notifier.
type Notifier interface {
	// Notify sends a log entry notification.
	Notify(entry LogzEntry) error
	// Enable activates the notifier.
	Enable()
	// Disable deactivates the notifier.
	Disable()
	// Enabled checks if the notifier is active.
	Enabled() bool

	// WebServer returns the HTTP server instance.
	WebServer() *http.Server

	// Temporarily disabled due to external dependency on zmq4
	// Uncomment and ensure the required libraries are installed if needed in the future
	// Websocket returns the WebSocket instance.
	//Websocket() *zmq4.Socket

	// WebClient returns the HTTP client instance.
	WebClient() *http.Client
	// DBusClient returns the DBus connection instance.
	DBusClient() *dbus.Conn
}

// NotifierImpl is the implementation of the Notifier interface.
type NotifierImpl struct {
	NotifierManager NotifierManager // Manager for notifier instances.
	EnabledFlag     bool            // Flag indicating if the notifier is enabled.
	WebhookURL      string          // URL for webhook notifications.
	HttpMethod      string          // HTTP method for webhook notifications.
	AuthToken       string          // Authentication token for notifications.
	LogLevel        string          // Log VLevel for filtering notifications.
	WsEndpoint      string          // WebSocket endpoint for notifications.
	Whitelist       []string        // Whitelist of sources for notifications.
}

// NewNotifier creates a new NotifierImpl instance.
func NewNotifier(manager NotifierManager, enabled bool, webhookURL, httpMethod, authToken, logLevel, wsEndpoint string, whitelist []string) Notifier {
	if whitelist == nil {
		whitelist = []string{}
	}
	return &NotifierImpl{
		NotifierManager: manager,
		EnabledFlag:     enabled,
		WebhookURL:      webhookURL,
		HttpMethod:      httpMethod,
		AuthToken:       authToken,
		LogLevel:        logLevel,
		WsEndpoint:      wsEndpoint,
		Whitelist:       whitelist,
	}
}

// Notify sends a log entry notification based on the configured settings.
func (n *NotifierImpl) Notify(entry LogzEntry) error {
	if !n.EnabledFlag {
		return nil
	}

	// Validate log VLevel
	if n.LogLevel != "" && n.LogLevel != string(entry.GetLevel()) {
		return nil
	}

	// Validate Whitelist
	if len(n.Whitelist) > 0 && !contains(n.Whitelist, entry.GetSource()) {
		return nil
	}

	// HTTP Notification
	if n.WebhookURL != "" {
		if err := n.httpNotify(entry); err != nil {
			return err
		}
	}

	// WebSocket Notification
	if n.WsEndpoint != "" {
		if err := n.wsNotify(entry); err != nil {
			return err
		}
	}

	// DBus Notification
	if n.DBusClient() != nil {
		if err := n.dbusNotify(entry); err != nil {
			return err
		}
	}

	return nil
}

// httpNotify sends an HTTP notification.
func (n *NotifierImpl) httpNotify(entry LogzEntry) error {
	if n.HttpMethod == "POST" {
		req, err := http.NewRequest("POST", n.WebhookURL, strings.NewReader(entry.GetMessage()))
		if err != nil {
			return fmt.Errorf("HTTP request creation error: %w", err)
		}
		if n.AuthToken != "" {
			req.Header.Set("Authorization", "Bearer "+n.AuthToken)
		}
		req.Header.Set("Content-Type", "application/json")
		resp, err := n.WebClient().Do(req)
		if err != nil {
			return fmt.Errorf("HTTP request error: %w", err)
		}
		defer resp.Body.Close()
		if resp.StatusCode != http.StatusOK {
			return fmt.Errorf("HTTP request failed: %s", resp.Status)
		}
	} else {
		return fmt.Errorf("unsupported HTTP method: %s", n.HttpMethod)
	}
	return nil
}

// wsNotify sends a WebSocket notification.
func (n *NotifierImpl) wsNotify(entry LogzEntry) error {
	_ = n.AuthToken + "|" + entry.GetMessage()
	// message := n.AuthToken + "|" + entry.GetMessage()
	// Temporarily disabled due to external dependency on zmq4
	// Uncomment and ensure the required libraries are installed if needed in the future
	//if _, err := n.Websocket().Send(message, 0); err != nil {
	//	return fmt.Errorf("WebSocket error: %w", err)
	//}
	return nil
}

// dbusNotify sends a DBus notification.
func (n *NotifierImpl) dbusNotify(entry LogzEntry) error {
	output := n.AuthToken + "|" + entry.GetMessage()
	dbusObj := n.DBusClient().Object("org.freedesktop.Notifications", "/org/freedesktop/Notifications")
	if call := dbusObj.Call("org.freedesktop.Notifications.Notify", 0, "", uint32(0), "", output, []string{}, map[string]dbus.Variant{}, int32(5000)); call.Err != nil {
		return fmt.Errorf("DBus call error: %w", call.Err)
	}
	return nil
}

// Enable activates the notifier.
func (n *NotifierImpl) Enable() { n.EnabledFlag = true }

// Disable deactivates the notifier.
func (n *NotifierImpl) Disable() { n.EnabledFlag = false }

// Enabled checks if the notifier is active.
func (n *NotifierImpl) Enabled() bool { return n.EnabledFlag }

// WebServer returns the HTTP server instance.
func (n *NotifierImpl) WebServer() *http.Server { return n.NotifierManager.WebServer() }

// Temporarily disabled due to external dependency on zmq4
// Uncomment and ensure the required libraries are installed if needed in the future
// Websocket returns the WebSocket instance.
//func (n *NotifierImpl) Websocket() *zmq4.Socket { return n.NotifierManager.Websocket() }

// WebClient returns the HTTP client instance.
func (n *NotifierImpl) WebClient() *http.Client { return n.NotifierManager.WebClient() }

// DBusClient returns the DBus connection instance.
func (n *NotifierImpl) DBusClient() *dbus.Conn { return n.NotifierManager.DBusClient() }

// contains checks if a slice contains a specific value.
func contains(slice []string, value string) bool {
	for _, item := range slice {
		if item == value {
			return true
		}
	}
	return false
}

// HTTPNotifier is a notifier that sends HTTP notifications.
type HTTPNotifier struct {
	NotifierImpl
}

// NewHTTPNotifier creates a new HTTPNotifier instance.
func NewHTTPNotifier(webhookURL, authToken string) *HTTPNotifier {
	return &HTTPNotifier{
		NotifierImpl: NotifierImpl{
			WebhookURL: webhookURL,
			AuthToken:  authToken,
			HttpMethod: "POST",
		},
	}
}

// Notify sends an HTTP notification.
func (n *HTTPNotifier) Notify(entry LogzEntry) error {
	if !n.EnabledFlag {
		return nil
	}
	req, err := http.NewRequest(n.HttpMethod, n.WebhookURL, strings.NewReader(entry.GetMessage()))
	if err != nil {
		return fmt.Errorf("HTTPNotifier request creation error: %w", err)
	}
	if n.AuthToken != "" {
		req.Header.Set("Authorization", "Bearer "+n.AuthToken)
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := n.WebClient().Do(req)
	if err != nil {
		return fmt.Errorf("HTTPNotifier request error: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("HTTPNotifier request failed: %s", resp.Status)
	}
	return nil
}

// ZMQNotifier is a notifier that sends WebSocket notifications.
type ZMQNotifier struct {
	NotifierImpl
}

// NewZMQNotifier creates a new ZMQNotifier instance.
func NewZMQNotifier(endpoint string) *ZMQNotifier {
	return &ZMQNotifier{
		NotifierImpl: NotifierImpl{
			WsEndpoint: endpoint,
		},
	}
}

// Temporarily disabled due to external dependency on zmq4
// Uncomment and ensure the required libraries are installed if needed in the future
// Notify sends a WebSocket notification.
func (n *ZMQNotifier) Notify(entry LogzEntry) error {
	if !n.EnabledFlag {
		return nil
	}
	_ = n.AuthToken + "|" + entry.GetMessage()
	//message := n.AuthToken + "|" + entry.GetMessage()
	//if _, err := n.Websocket().Send(message, 0); err != nil {
	//	return fmt.Errorf("ZMQNotifier error: %w", err)
	//}
	return nil
}

// DBusNotifier is a notifier that sends DBus notifications.
type DBusNotifier struct {
	NotifierImpl
}

// NewDBusNotifier creates a new DBusNotifier instance.
func NewDBusNotifier() *DBusNotifier {
	return &DBusNotifier{
		NotifierImpl: NotifierImpl{},
	}
}

// Notify sends a DBus notification.
func (n *DBusNotifier) Notify(entry LogzEntry) error {
	if !n.EnabledFlag {
		return nil
	}
	output := n.AuthToken + "|" + entry.GetMessage()
	dbusObj := n.DBusClient().Object("org.freedesktop.Notifications", "/org/freedesktop/Notifications")
	if call := dbusObj.Call("org.freedesktop.Notifications.Notify", 0, "", uint32(0), "", output, []string{}, map[string]dbus.Variant{}, int32(5000)); call.Err != nil {
		return fmt.Errorf("DBusNotifier error: %w", call.Err)
	}
	return nil
}

func GetLogPath() string {
	home, homeErr := os.UserHomeDir()
	if homeErr != nil {
		home, homeErr = os.UserConfigDir()
		if homeErr != nil {
			home, homeErr = os.UserCacheDir()
			if homeErr != nil {
				home = "/tmp"
			}
		}
	}
	configPath := filepath.Join(home, ".kubex", "logz", "VConfig.json")
	if mkdirErr := os.MkdirAll(filepath.Dir(configPath), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
		return ""
	}
	return configPath
}

/// internal/core/notifier_manager.go ///
package core

import (
	"github.com/godbus/dbus/v5"
	"github.com/spf13/viper"

	"fmt"
	"net/http"
	"sync"
)

// NotifierManager defines the interface for managing notifiers.
type NotifierManager interface {
	// WebServer returns the HTTP server instance.
	WebServer() *http.Server
	// Temporarily disabled due to external dependency on zmq4
	// Uncomment and ensure the required libraries are installed if needed in the future
	// Websocket returns the ZMQ socket instance.
	// Websocket() *zmq4.Socket

	// WebClient returns the HTTP client instance.
	WebClient() *http.Client
	// DBusClient returns the DBus connection instance.
	DBusClient() *dbus.Conn

	// AddNotifier adds or updates a notifier with the given name.
	AddNotifier(name string, notifier Notifier)
	// RemoveNotifier removes the notifier with the given name.
	RemoveNotifier(name string)
	// GetNotifier retrieves the notifier with the given name.
	GetNotifier(name string) (Notifier, bool)
	// ListNotifiers lists all registered notifier names.
	ListNotifiers() []string

	// UpdateFromConfig updates notifiers dynamically based on the provided configuration.
	UpdateFromConfig() error
}

// NotifierManagerImpl is the implementation of the NotifierManager interface.
type NotifierManagerImpl struct {
	webServer *http.Server
	// Temporarily disabled due to external dependency on zmq4
	// Uncomment and ensure the required libraries are installed if needed in the future
	// websocket  *zmq4.Socket
	webClient  *http.Client
	dbusClient *dbus.Conn
	notifiers  map[string]Notifier
	mu         sync.RWMutex
}

// NewNotifierManager creates a new instance of NotifierManagerImpl.
func NewNotifierManager(notifiers map[string]Notifier) NotifierManager {
	if notifiers == nil {
		notifiers = make(map[string]Notifier)
	}
	return &NotifierManagerImpl{
		notifiers: notifiers,
	}
}

// AddNotifier adds or updates a notifier with the given name.
func (nm *NotifierManagerImpl) AddNotifier(name string, notifier Notifier) {
	nm.mu.Lock()
	defer nm.mu.Unlock()
	nm.notifiers[name] = notifier
	fmt.Printf("Notifier '%s' added/updated.\n", name)
}

// RemoveNotifier removes the notifier with the given name.
func (nm *NotifierManagerImpl) RemoveNotifier(name string) {
	nm.mu.Lock()
	defer nm.mu.Unlock()
	delete(nm.notifiers, name)
	fmt.Printf("Notifier '%s' removed.\n", name)
}

// GetNotifier retrieves the notifier with the given name.
func (nm *NotifierManagerImpl) GetNotifier(name string) (Notifier, bool) {
	nm.mu.RLock()
	defer nm.mu.RUnlock()
	notifier, ok := nm.notifiers[name]
	return notifier, ok
}

// ListNotifiers lists all registered notifier names.
func (nm *NotifierManagerImpl) ListNotifiers() []string {
	nm.mu.RLock()
	defer nm.mu.RUnlock()
	keys := make([]string, 0, len(nm.notifiers))
	for name := range nm.notifiers {
		keys = append(keys, name)
	}
	return keys
}

// UpdateFromConfig updates notifiers dynamically based on the provided configuration.
func (nm *NotifierManagerImpl) UpdateFromConfig() error {
	var configNotifiers map[string]map[string]interface{}
	if err := viper.UnmarshalKey("notifiers", &configNotifiers); err != nil {
		return fmt.Errorf("failed to parse notifiers VConfig: %w", err)
	}

	// Update or recreate notifiers dynamically
	for name, conf := range configNotifiers {
		typ, ok := conf["type"].(string)
		if !ok {
			fmt.Printf("Notifier '%s' does not specify a type and will be ignored.\n", name)
			continue
		}

		switch typ {
		case "http":
			webhookURL, _ := conf["webhookURL"].(string)
			authToken, _ := conf["authToken"].(string)
			notifier := NewHTTPNotifier(webhookURL, authToken)
			nm.AddNotifier(name, notifier)
		case "zmq":
			endpoint, _ := conf["endpoint"].(string)
			notifier := NewZMQNotifier(endpoint)
			nm.AddNotifier(name, notifier)
		case "dbus":
			notifier := NewDBusNotifier()
			nm.AddNotifier(name, notifier)
		default:
			fmt.Printf("Unknown notifier type '%s' for notifier '%s'.\n", typ, name)
		}
	}
	return nil
}

// WebServer returns the HTTP server instance.
func (nm *NotifierManagerImpl) WebServer() *http.Server {
	if nm.webServer == nil {
		nm.webServer = Server()
	}
	return nm.webServer
}

// Temporarily disabled due to external dependency on zmq4
// Uncomment and ensure the required libraries are installed if needed in the future
// Websocket returns the ZMQ socket instance.
//func (nm *NotifierManagerImpl) Websocket() *zmq4.Socket {
//	if nm.websocket == nil {
//		nm.websocket = Socket()
//	}
//	return nm.websocket
//}

// WebClient returns the HTTP client instance.
func (nm *NotifierManagerImpl) WebClient() *http.Client {
	if nm.webClient == nil {
		nm.webClient = Client()
	}
	return nm.webClient
}

// DBusClient returns the DBus connection instance.
func (nm *NotifierManagerImpl) DBusClient() *dbus.Conn {
	if nm.dbusClient == nil {
		nm.dbusClient = DBus()
	}
	return nm.dbusClient
}

/// internal/core/prometheus.go ///
package core

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
)

// Regular expression to validate metric names
var metricNameRegex = regexp.MustCompile(`^[a-zA-Z_:][a-zA-Z0-9_:]*$`)

// validateMetricName checks if the given metric name is valid according to the Prometheus naming conventions.
func validateMetricName(name string) error {
	if !metricNameRegex.MatchString(name) {
		return fmt.Errorf("invalid metric name '%s': must match [a-zA-Z_:][a-zA-Z0-9_:]*", name)
	}
	return nil
}

// Metric represents a single Prometheus metric with a value and optional VMetadata.
type Metric struct {
	Value    float64           `json:"value"`
	Metadata map[string]string `json:"VMetadata,omitempty"`
}

// PrometheusManager manages Prometheus metrics, including enabling/disabling the HTTP server,
// loading/saving metrics, and handling metric operations.
type PrometheusManager struct {
	enabled         bool
	metrics         map[string]Metric
	mutex           sync.RWMutex
	metricsFile     string          // path to the persistence file
	exportWhitelist map[string]bool // If not empty, only these metrics will be exported to Prometheus
	httpServer      *http.Server    // HTTP server to expose metrics
}

// Singleton instance of PrometheusManager
var prometheusManagerInstance *PrometheusManager

// getMetricsFilePath returns the path to the metrics persistence file, using an environment variable if set,
// or a default location in the user's cache directory.
func getMetricsFilePath() string {
	if envPath := os.Getenv("LOGZ_METRICS_FILE"); envPath != "" {
		return envPath
	}
	cacheDir, err := os.UserCacheDir()
	if err != nil {
		cacheDir = "/tmp"
	}
	dir := filepath.Join(cacheDir, "kubex", "logz")
	_ = os.MkdirAll(dir, 0755)
	return filepath.Join(dir, "metrics.json")
}

// GetPrometheusManager returns the singleton instance of PrometheusManager, initializing it if necessary.
func GetPrometheusManager() *PrometheusManager {
	if prometheusManagerInstance == nil {
		prometheusManagerInstance = &PrometheusManager{
			enabled:         false,
			metrics:         make(map[string]Metric),
			metricsFile:     getMetricsFilePath(),
			exportWhitelist: make(map[string]bool),
		}
		if err := prometheusManagerInstance.loadMetrics(); err != nil {
			fmt.Printf("Warning: could not load metrics: %v\n", err)
		}
	}
	return prometheusManagerInstance
}

// loadMetrics loads metrics from the persistence file into the PrometheusManager instance.
func (pm *PrometheusManager) loadMetrics() error {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	data, err := os.ReadFile(pm.metricsFile)
	if err != nil {
		if os.IsNotExist(err) {
			pm.metrics = make(map[string]Metric)
			return nil
		}
		return err
	}
	var loaded map[string]Metric
	if err := json.Unmarshal(data, &loaded); err != nil {
		return err
	}
	pm.metrics = loaded
	return nil
}

// saveMetrics saves the current metrics to the persistence file.
func (pm *PrometheusManager) saveMetrics() error {
	pm.mutex.RLock()
	defer pm.mutex.RUnlock()
	data, err := json.MarshalIndent(pm.metrics, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(pm.metricsFile, data, 0644)
}

// Enable starts the Prometheus HTTP server on the specified port to expose metrics.
func (pm *PrometheusManager) Enable(port string) {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	if pm.enabled {
		fmt.Println("Prometheus metrics are already enabled.")
		return
	}
	pm.enabled = true

	// Start the HTTP server to expose metrics
	mux := http.NewServeMux()
	mux.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) {
		metrics := pm.GetMetrics()
		w.Header().Set("Content-Type", "text/plain; version=0.0.4")
		for name, value := range metrics {
			_, fPrintFErr := fmt.Fprintf(w, "# TYPE %s gauge\n%s %f\n", name, name, value)
			if fPrintFErr != nil {
				return
			}
		}
	})
	pm.httpServer = &http.Server{
		Addr:    fmt.Sprintf(":%s", port),
		Handler: mux,
	}
	go func() {
		if err := pm.httpServer.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			fmt.Printf("ErrorCtx starting Prometheus metrics server: %v\n", err)
		}
	}()
	fmt.Println("Prometheus metrics enabled.")
}

// Disable stops the Prometheus HTTP server and disables metric exposure.
func (pm *PrometheusManager) Disable() {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	if !pm.enabled {
		fmt.Println("Prometheus metrics are already disabled.")
		return
	}
	pm.enabled = false
	if pm.httpServer != nil {
		_ = pm.httpServer.Close()
	}
	fmt.Println("Prometheus metrics disabled.")
}

// GetMetrics returns the current metrics, filtered by the export whitelist if defined.
func (pm *PrometheusManager) GetMetrics() map[string]float64 {
	pm.mutex.RLock()
	defer pm.mutex.RUnlock()
	filteredMetrics := make(map[string]float64)
	for name, metric := range pm.metrics {
		// Respect the exportWhitelist, if defined
		if len(pm.exportWhitelist) > 0 && !pm.exportWhitelist[name] {
			continue
		}
		filteredMetrics[name] = metric.Value
	}
	return filteredMetrics
}

// SetExportWhitelist sets the list of metrics that are allowed to be exported to Prometheus.
func (pm *PrometheusManager) SetExportWhitelist(metrics []string) {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	pm.exportWhitelist = make(map[string]bool)
	for _, m := range metrics {
		pm.exportWhitelist[m] = true
	}
	fmt.Println("Export whitelist updated for Prometheus metrics.")
}

// IsEnabled returns whether the Prometheus metrics exposure is enabled.
func (pm *PrometheusManager) IsEnabled() bool {
	pm.mutex.RLock()
	defer pm.mutex.RUnlock()
	return pm.enabled
}

// AddMetric adds or updates a metric with the given name, value, and VMetadata.
func (pm *PrometheusManager) AddMetric(name string, value float64, metadata map[string]string) {
	if err := validateMetricName(name); err != nil {
		fmt.Printf("ErrorCtx adding metric: %v\n", err)
		return
	}
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	pm.metrics[name] = Metric{
		Value:    value,
		Metadata: metadata,
	}
	fmt.Printf("Metric '%s' added/updated with value: %f\n", name, value)
	if err := pm.saveMetrics(); err != nil {
		fmt.Printf("ErrorCtx saving metrics: %v\n", err)
	}
}

// RemoveMetric removes a metric with the given name.
func (pm *PrometheusManager) RemoveMetric(name string) {
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	delete(pm.metrics, name)
	fmt.Printf("Metric '%s' removed.\n", name)
	if err := pm.saveMetrics(); err != nil {
		fmt.Printf("ErrorCtx saving metrics: %v\n", err)
	}
}

// IncrementMetric increments the value of a metric by the given delta.
func (pm *PrometheusManager) IncrementMetric(name string, delta float64) {
	if err := validateMetricName(name); err != nil {
		fmt.Printf("ErrorCtx incrementing metric: %v\n", err)
		return
	}
	pm.mutex.Lock()
	defer pm.mutex.Unlock()
	metric, exists := pm.metrics[name]
	if !exists {
		metric = Metric{Value: 0, Metadata: nil}
	}
	metric.Value += delta
	pm.metrics[name] = metric
	fmt.Printf("Metric '%s' incremented by %f, new value: %f\n", name, delta, metric.Value)
	if err := pm.saveMetrics(); err != nil {
		fmt.Printf("ErrorCtx saving metrics: %v\n", err)
	}
}

// ListMetrics prints all registered metrics to the console.
func (pm *PrometheusManager) ListMetrics() {
	pm.mutex.RLock()
	defer pm.mutex.RUnlock()
	if len(pm.metrics) == 0 {
		fmt.Println("No metrics registered.")
		return
	}
	fmt.Println("Registered metrics:")
	for name, metric := range pm.metrics {
		fmt.Printf("- %s: %f", name, metric.Value)
		if len(metric.Metadata) > 0 {
			metadataJSON, _ := json.Marshal(metric.Metadata)
			fmt.Printf(" (VMetadata: %s)", string(metadataJSON))
		}
		fmt.Println()
	}
}

// setPrometheusSysConfig configures the Prometheus system to scrape metrics from this application.
func (pm *PrometheusManager) setPrometheusSysConfig() error {
	// Logz specific configuration for Prometheus
	prometheusConfig := `
scrape_configs:
  - job_name: 'logz'
    static_configs:
      - targets: ['localhost:2112']
`

	configFilePath := "/etc/prometheus/prometheus.yml"

	// Check if the configuration file exists
	_, err := os.Stat(configFilePath)
	if os.IsNotExist(err) {
		// Create the configuration file if it does not exist
		if err := os.WriteFile(configFilePath, []byte(prometheusConfig), 0644); err != nil {
			return fmt.Errorf("failed to create Prometheus configuration file: %w", err)
		}
		fmt.Println("Prometheus configuration file created successfully.")
	} else if err == nil {
		// Check if there is already a configuration for 'logz'
		configContent, readErr := os.ReadFile(configFilePath)
		if readErr != nil {
			return fmt.Errorf("failed to read Prometheus configuration file: %w", readErr)
		}

		if strings.Contains(string(configContent), "job_name: 'logz'") {
			fmt.Println("Prometheus configuration for 'logz' already exists.")
		} else {
			// Add the configuration to the existing file
			f, openErr := os.OpenFile(configFilePath, os.O_APPEND|os.O_WRONLY, 0644)
			if openErr != nil {
				return fmt.Errorf("failed to open Prometheus configuration file: %w", openErr)
			}
			defer func(f *os.File) {
				_ = f.Close()
			}(f)

			if _, writeErr := f.WriteString(prometheusConfig); writeErr != nil {
				return fmt.Errorf("failed to append to Prometheus configuration file: %w", writeErr)
			}
			fmt.Println("Prometheus configuration for 'logz' added successfully.")
		}
	} else {
		return fmt.Errorf("failed to check Prometheus configuration file: %w", err)
	}

	return nil
}

// initPrometheus initializes the Prometheus metrics and system configuration.
func (pm *PrometheusManager) initPrometheus() error {
	if !pm.IsEnabled() {
		return fmt.Errorf("prometheus is not enabled")
	}

	defaultMetrics := []string{"infoCount", "warnCount", "errorCount", "debugCount", "successCount"}
	for _, metric := range defaultMetrics {
		if err := validateMetricName(metric); err != nil {
			fmt.Printf("ErrorCtx initializing metric '%s': %v\n", metric, err)
			continue
		}
		pm.AddMetric(metric, 0, nil) // Initialize with value 0 and no VMetadata
	}

	if err := pm.setPrometheusSysConfig(); err != nil {
		return fmt.Errorf("failed to configure Prometheus system: %w", err)
	}

	fmt.Println("Prometheus initialized successfully with default metrics.")
	return nil
}

/// internal/core/reader.go ///
package core

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"time"
)

// LogReader defines the contract for reading logs.
type LogReader interface {
	// Tail reads the log file in real-time and sends the new lines to the
	// provided VWriter or prints them to the terminal. The operation can be interrupted
	// by sending a signal through the stopChan channel.
	Tail(filePath string, stopChan <-chan struct{}) error
}

// FileLogReader implements the LogReader interface by reading from a file.
type FileLogReader struct {
	// pollInterval is the polling interval to check for new lines.
	pollInterval time.Duration
}

// NewFileLogReader creates a new instance of FileLogReader.
// The polling interval is read from the LOGZ_TAIL_POLL_INTERVAL environment variable (in milliseconds),
// or defaults to 500ms.
func NewFileLogReader() *FileLogReader {
	intervalMs := 500 // default in milliseconds
	if val := os.Getenv("LOGZ_TAIL_POLL_INTERVAL"); val != "" {
		if parsed, err := strconv.Atoi(val); err == nil && parsed > 0 {
			intervalMs = parsed
		} else {
			log.Printf("Invalid LOGZ_TAIL_POLL_INTERVAL value, using default 500ms: %v", err)
		}
	}
	return &FileLogReader{
		pollInterval: time.Duration(intervalMs) * time.Millisecond,
	}
}

// Tail follows the log file from the end and prints new lines as they are added.
// The stopChan channel allows interrupting the operation (e.g., via Ctrl+C).
func (fr *FileLogReader) Tail(filePath string, stopChan <-chan struct{}) error {
	// Open the log file
	f, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open log file: %w", err)
	}
	defer f.Close()

	// Position the pointer at the end of the file to read only new lines
	_, err = f.Seek(0, io.SeekEnd)
	if err != nil {
		return fmt.Errorf("failed to seek to the end of the file: %w", err)
	}

	reader := bufio.NewReader(f)

	// Main loop to read new lines
	for {
		select {
		case <-stopChan:
			log.Println("Tail operation interrupted by stop signal")
			return nil
		default:
			line, err := reader.ReadString('\n')
			if err != nil {
				if err == io.EOF {
					time.Sleep(fr.pollInterval)
					continue
				}
				return fmt.Errorf("error reading log file: %w", err)
			}
			// Print the line immediately; can be adapted to send to another channel if needed.
			fmt.Print(line)
		}
	}
}

/// internal/core/service.go ///
package core

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/godbus/dbus/v5"
	"github.com/spf13/viper"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"
)

const (
	// pidFile is the name of the PID file used to track the running service.
	pidFile = "logz_srv.pid"
)

var (
	lSrv    *http.Server
	lClient *http.Client
	// Temporarily disabled due to external dependency on zmq4
	// Uncomment and ensure the required libraries are installed if needed in the future
	//lSocket      *zmq4.Socket
	lDBus        *dbus.Conn
	globalLogger LogzLogger // Global core for the service
	startTime    = time.Now()
	mu           sync.RWMutex
)

// Run starts the logging service.
func Run() error {
	mu.Lock()
	defer mu.Unlock()

	// Check if the service is already running to avoid multiple instances
	if IsRunning() {
		if stopErr := shutdown(); stopErr != nil {
			return stopErr
		}
	}

	// Initialize the ConfigManager and load the configuration
	configManager := NewConfigManager()
	if configManager == nil {
		return errors.New("failed to initialize VConfig manager")
	}
	cfgMgr := *configManager

	config, err := cfgMgr.LoadConfig()
	if err != nil {
		return fmt.Errorf("failed to load VConfig: %w", err)
	}

	// Initialize the global core with the configuration
	initializeGlobalLogger(config)

	// Set up the HTTP server
	mux := http.NewServeMux()
	if err := registerHandlers(mux); err != nil {
		return err
	}

	lSrv = &http.Server{
		Addr:         config.Address(),
		Handler:      loggingMiddleware(mux),
		ReadTimeout:  config.ReadTimeout(),
		WriteTimeout: config.WriteTimeout(),
		IdleTimeout:  config.IdleTimeout(),
	}

	// Start the HTTP server
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
	go func() {
		globalLogger.InfoCtx(fmt.Sprintf("Service running on %s", config.Address()), nil)
		if err := lSrv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			globalLogger.ErrorCtx(fmt.Sprintf("Service encountered an error: %v", err), nil)
		}
	}()

	<-stop
	return shutdown()
}

// Start initiates the logging service on the specified port.
func Start(port string) error {
	mu.Lock()
	defer mu.Unlock()

	if IsRunning() {
		return errors.New("service already running (pid file exists: " + getPidPath() + ")")
	}

	// Use Viper to load runtime configuration
	vpr := viper.GetViper()
	if vpr == nil {
		return errors.New("viper not initialized")
	}

	cmd := exec.Command(os.Args[0], "service", "spawn", "-c", vpr.ConfigFileUsed())
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start service: %w", err)
	}

	file, err := os.OpenFile(getPidPath(), os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		return fmt.Errorf("failed to open PID file: %w", err)
	}
	defer func(file *os.File) {
		_ = file.Close()
	}(file)

	//if runtime.GOOS != "windows" {
	//	if err := syscall.Flock(int(file.Fd()), syscall.LOCK_EX|syscall.LOCK_NB); err != nil {
	//		return errors.New("another process is writing to the PID file")
	//	}
	//}

	pid := cmd.Process.Pid
	pidData := fmt.Sprintf("%d\n%s", pid, port)
	if _, writeErr := file.Write([]byte(pidData)); writeErr != nil {
		return fmt.Errorf("failed to write PID data: %w", writeErr)
	}

	globalLogger.InfoCtx(fmt.Sprintf("Service started with pid %d", pid), nil)
	return nil
}

// Stop terminates the running logging service.
func Stop() error {
	mu.Lock()
	defer mu.Unlock()

	pid, port, pidPath, err := GetServiceInfo()
	if err != nil {
		return err
	}

	process, err := os.FindProcess(pid)
	if err != nil {
		return fmt.Errorf("failed to find process: %w", err)
	}

	if err := process.Signal(syscall.SIGTERM); err != nil {
		return fmt.Errorf("failed to stop process: %w", err)
	}

	time.Sleep(1 * time.Second)
	if err := os.Remove(pidPath); err != nil {
		return err
	}

	globalLogger.InfoCtx(fmt.Sprintf("Service with pid %d and port %s stopped", pid, port), nil)
	return nil
}

// Server returns the HTTP server instance.
func Server() *http.Server {
	return lSrv
}

// Client returns the HTTP client instance.
func Client() *http.Client {
	if lClient == nil {
		lClient = &http.Client{}
	}
	return lClient
}

// Temporarily disabled due to external dependency on zmq4
// Uncomment and ensure the required libraries are installed if needed in the future
// Socket returns the ZMQ socket instance.
//func Socket() *zmq4.Socket {
//	if lSocket == nil {
//		lSocket, _ = zmq4.NewSocket(zmq4.PUB)
//	}
//	return lSocket
//}

// DBus returns the DBus connection instance.
func DBus() *dbus.Conn {
	if lDBus == nil {
		lDBus, _ = dbus.SystemBus()
	}
	return lDBus
}

// getPidPath returns the path to the PID file.
func getPidPath() string {
	if envPath := os.Getenv("LOGZ_PID_PATH"); envPath != "" {
		return envPath
	}
	cacheDir, cacheDirErr := os.UserCacheDir()
	if cacheDirErr != nil {
		cacheDir = "/tmp"
	}
	cacheDir = filepath.Join(cacheDir, "logz", pidFile)
	if mkdirErr := os.MkdirAll(filepath.Dir(cacheDir), 0755); mkdirErr != nil && !os.IsExist(mkdirErr) {
		return ""
	}
	return cacheDir
}

// IsRunning checks if the service is currently running.
func IsRunning() bool {
	_, err := os.Stat(getPidPath())
	return err == nil
}

// GetServiceInfo retrieves the PID, port, and PID file path of the running service.
func GetServiceInfo() (int, string, string, error) {
	pidPath := getPidPath()

	data, err := os.ReadFile(pidPath)
	if err != nil {
		return 0, "", "", os.ErrNotExist
	}

	lines := strings.Split(string(data), "\n")
	pid, pidErr := strconv.Atoi(lines[0])
	if pidErr != nil {
		return 0, "", "", os.ErrInvalid
	}

	port := "unknown"
	if len(lines) > 1 {
		port = lines[1]
	}

	return pid, port, pidPath, nil
}

// registerHandlers registers HTTP handlers for the service.
func registerHandlers(mux *http.ServeMux) error {
	integrations := viper.GetStringMap("integrations")
	if integrations == nil {
		return errors.New("no integrations configured")
	}

	for path := range integrations {
		if !viper.GetBool("integrations." + path + ".enabled") {
			continue
		}

		healthPath, _ := url.JoinPath("/", path, "/health")
		metricsPath, _ := url.JoinPath("/", path, "/metrics")
		callbackPath, _ := url.JoinPath("/", path, "/receive")

		mux.HandleFunc(healthPath, healthHandler)
		mux.HandleFunc(metricsPath, metricsHandler)
		mux.HandleFunc(callbackPath, callbackHandler)
	}

	return nil
}

// callbackHandler handles incoming callback requests.
func callbackHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Limit the payload size to prevent abuse
	r.Body = http.MaxBytesReader(w, r.Body, 1<<20)

	var payload map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		http.Error(w, "Invalid JSON payload", http.StatusBadRequest)
		return
	}

	if _, ok := payload["message"]; !ok {
		http.Error(w, "Missing 'message' in payload", http.StatusBadRequest)
		return
	}

	globalLogger.InfoCtx(fmt.Sprintf("Callback received: %v", payload), nil)
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte(`{"status":"success","message":"Callback processed"}`))
}

// healthHandler handles health check requests.
func healthHandler(w http.ResponseWriter, _ *http.Request) {
	uptime := time.Since(startTime).String()
	response := fmt.Sprintf("OK\nUptime: %s\n", uptime)
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte(response))
}

// metricsHandler handles metrics requests.
func metricsHandler(w http.ResponseWriter, _ *http.Request) {
	pm := GetPrometheusManager()
	if !pm.IsEnabled() {
		http.Error(w, "Prometheus integration is not enabled", http.StatusForbidden)
		return
	}

	metrics := pm.GetMetrics()
	if len(metrics) == 0 {
		w.WriteHeader(http.StatusNoContent)
		return
	}

	w.Header().Set("Content-Type", "text/plain; version=0.0.4")
	for name, value := range metrics {
		if _, err := fmt.Fprintf(w, "# HELP %s Custom metric from Logz\n# TYPE %s gauge\n%s %f\n", name, name, name, value); err != nil {
			fmt.Println(fmt.Sprintf("ErrorCtx writing metric '%s': %v", name, err))
		}
	}
}

// loggingMiddleware logs incoming HTTP requests.
func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Printf("Received %s request for %s from %s\n", r.Method, r.URL.Path, r.RemoteAddr)
		next.ServeHTTP(w, r)
	})
}

// shutdown gracefully shuts down the service.
func shutdown() error {
	globalLogger.InfoCtx("Shutting down service gracefully...", nil)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := lSrv.Shutdown(ctx); err != nil {
		globalLogger.ErrorCtx(fmt.Sprintf("Service shutdown failed: %v", err), nil)
		return fmt.Errorf("shutdown process failed: %w", err)
	}

	globalLogger.InfoCtx("Service stopped gracefully.", nil)
	return nil
}

// initializeGlobalLogger initializes the global core with the provided configuration.
func initializeGlobalLogger(config Config) {
	mu.Lock()
	defer mu.Unlock()

	if globalLogger == nil {
		globalLogger = NewLogger("Logz")
	}
}

/// internal/core/writer.go ///
package core

import (
	"golang.org/x/text/language"
	"golang.org/x/text/message"

	"encoding/json"
	"fmt"
	"io"
	"os"
	"reflect"
	"runtime"
)

// LogFormatter defines the contract for formatting log entries.
type LogFormatter interface {
	// Format converts a log entry to a formatted string.
	// Returns the formatted string and an error if formatting fails.
	Format(entry LogzEntry) (string, error)
}

// JSONFormatter formats the log in JSON format.
type JSONFormatter struct{}

// Format converts the log entry to JSON.
// Returns the JSON string and an error if marshalling fails.
func (f *JSONFormatter) Format(entry LogzEntry) (string, error) {
	data, err := json.Marshal(entry)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// TextFormatter formats the log in plain text.
type TextFormatter struct{}

// Format converts the log entry to a formatted string with colors and icons.
// Returns the formatted string and an error if formatting fails.
func (f *TextFormatter) Format(entry LogzEntry) (string, error) {

	// Check for environment variables
	noColor := os.Getenv("LOGZ_NO_COLOR") != "" || runtime.GOOS == "windows"
	noIcon := os.Getenv("LOGZ_NO_ICON") != ""

	icon, levelStr := "", ""

	if !noIcon {
		switch entry.GetLevel() {
		case NOTICE:
			icon = "\033[33müìù\033[0m "
		case TRACE:
			icon = "\033[36müîç\033[0m "
		case SUCCESS:
			icon = "\033[32m‚úÖ\033[0m "
		case DEBUG:
			icon = "\033[34müêõ\033[0m "
		case INFO:
			icon = "\033[32m‚ÑπÔ∏è\033[0m "
		case WARN:
			icon = "\033[33m‚ö†Ô∏è\033[0m "
		case ERROR:
			icon = "\033[31m‚ùå\033[0m "
		case FATAL:
			icon = "\033[35müíÄ\033[0m "
		default:
			icon = ""
		}
	} else {
		icon = ""
	}

	// Configure colors and icons by VLevel
	if !noColor {
		switch entry.GetLevel() {
		case NOTICE:
			levelStr = "\033[33mNOTICE\033[0m"
		case TRACE:
			levelStr = "\033[36mTRACE\033[0m"
		case SUCCESS:
			levelStr = "\033[32mSUCCESS\033[0m"
		case DEBUG:
			levelStr = "\033[34mDEBUG\033[0m"
		case INFO:
			levelStr = "\033[32mINFO\033[0m"
		case WARN:
			levelStr = "\033[33mWARN\033[0m"
		case ERROR:
			levelStr = "\033[31mERROR\033[0m"
		case FATAL:
			levelStr = "\033[35mFATAL\033[0m"
		default:
			levelStr = string(entry.GetLevel())
		}
	} else {
		levelStr = string(entry.GetLevel())
	}

	systemLocale := os.Getenv("LANG")
	tag, _ := language.Parse(systemLocale)
	p := message.NewPrinter(tag)

	// Context and Metadata
	context := ""
	metadata := ""
	timestamp := ""
	if len(entry.GetMetadata()) > 0 {
		if sc, exist := entry.GetMetadata()["showContext"]; exist {
			tp := reflect.TypeOf(sc)
			if tp.Kind() == reflect.Bool {
				if sc.(bool) {
					if c, exists := entry.GetMetadata()["context"]; exists {
						context = c.(string)
					}
				}
			} else if tp.Kind() == reflect.String {
				if sc.(string) == "true" {
					metadata = fmt.Sprintf("\n%s", formatMetadata(entry))
				}
			}

		} else if map[LogLevel]bool{DEBUG: true, INFO: true}[entry.GetLevel()] {
			if c, exists := entry.GetMetadata()["context"]; exists {
				context = c.(string)
			}
		}
		if smd, exist := entry.GetMetadata()["showData"]; exist {
			tp := reflect.TypeOf(smd)
			if tp.Kind() == reflect.Bool {
				if smd.(bool) {
					metadata = fmt.Sprintf("\n%s", formatMetadata(entry))
				}
			} else if tp.Kind() == reflect.String {
				if smd.(string) == "true" {
					metadata = fmt.Sprintf("\n%s", formatMetadata(entry))
				}
			}
		} else if entry.GetLevel() == DEBUG {
			metadata = fmt.Sprintf("\n%s", formatMetadata(entry))
		}
		if stp, exist := entry.GetMetadata()["showTimestamp"]; exist {
			tp := reflect.TypeOf(stp)
			if tp.Kind() == reflect.Bool {
				if stp.(bool) {
					timestamp = fmt.Sprintf("[%s]", entry.GetTimestamp().Format(p.Sprintf("%d-%m-%Y %H:%M:%S")))
				}
			} else if tp.Kind() == reflect.String {
				if stp.(string) == "true" {
					metadata = fmt.Sprintf("\n%s", formatMetadata(entry))
				}
			}
		}
	}

	// Construct the header
	header := fmt.Sprintf("%s [%s] %s %s - ", timestamp, levelStr, context, icon)

	// Return the formatted log entry
	return fmt.Sprintf("%s%s%s", header, entry.GetMessage(), metadata), nil
}

// LogWriter defines the contract for writing logs.
type LogWriter[T any] interface {
	Write(entry T) error
}

// NewDefaultWriter creates a new instance of DefaultWriter.
// Takes an io.Writer and a LogFormatter as parameters.
type DefaultWriter[T any] struct {
	out       io.Writer
	formatter LogFormatter
}

// NewDefaultWriter cria um novo VWriter usando generics.
func NewDefaultWriter[T any](out io.Writer, formatter LogFormatter) *DefaultWriter[T] {
	return &DefaultWriter[T]{
		out:       out,
		formatter: formatter,
	}
}

// Write aceita qualquer tipo de entrada T e a processa.
func (w *DefaultWriter[T]) Write(entry T) error {
	var formatted string
	var err error

	// Verifique se a entrada √© do tipo LogzEntry
	switch v := any(entry).(type) {
	case LogzEntry:
		formatted, err = w.formatter.Format(v)
	case []byte:
		// Converta o []byte em LogzEntry antes de formatar (exemplo simplificado)
		entry := NewLogEntry().WithMessage(string(v))
		formatted, err = w.formatter.Format(entry)
	default:
		return fmt.Errorf("unsupported log entry type: %T", entry)
	}

	if err != nil {
		return err
	}

	_, err = fmt.Fprintln(w.out, formatted)
	return err
}

// formatMetadata converts VMetadata to a JSON string.
// Returns the JSON string or an empty string if marshalling fails.
func formatMetadata(entry LogzEntry) string {
	metadata := entry.GetMetadata()
	if len(metadata) == 0 {
		return ""
	}
	prefix := "Context:\n"
	for k, v := range metadata {
		if k == "showContext" {
			continue
		}
		prefix += fmt.Sprintf("  - %s: %v\n", k, v)
	}
	return prefix
}

type LogMultiWriter[T any] interface {
	Write(entry T) error
	AddWriter(w LogWriter[T])
	GetWriters() []LogWriter[T]
}

type MultiWriter[T any] struct {
	writers []LogWriter[T]
}

func (mw *MultiWriter[T]) AddWriter(w LogWriter[T]) {
	mw.writers = append(mw.writers, w)
}

func (mw *MultiWriter[T]) Write(entry T) error {
	for _, w := range mw.writers {
		if err := w.Write(entry); err != nil {
			return err
		}
	}

	/* structTest := json.Marshal(entry)
	if structTest != nil {
		if strEntry, ok := entry.(string); ok {
			for _, w := range mw.writers {
				if err := w.Write(strEntry); err != nil {
					return err
				}
			}
		}
	} */

	json.NewEncoder(os.Stdout).Encode(entry)

	return nil
}

func (mw *MultiWriter[T]) GetWriters() []LogWriter[T] { return mw.writers }

/// internal/utils/logz_table.go ///
package utils

import (
	"github.com/olekukonko/tablewriter"

	"os"
	"path/filepath"
)

// Table represents a simple table.
type Table struct {
	data [][]string
}

// NewTable creates a new simple table.
func NewTable(data [][]string) Table {
	return Table{data}
}

// PrintTable prints the simple table in the shell with side and vertical borders.
func (t Table) PrintTable() {
	table := tablewriter.NewWriter(os.Stdout)
	table.SetBorder(true)  // Enables side and vertical borders
	table.SetRowLine(true) // Enables lines between rows
	for _, row := range t.data {
		table.Append(row)
	}
	table.Render()
}

// FormattedTable represents a formatted table.
type FormattedTable struct {
	data   [][]string
	header []string
}

// NewFormattedTable creates a new formatted table.
func NewFormattedTable(header []string, data [][]string) FormattedTable {
	return FormattedTable{header: header, data: data}
}

// SaveFormattedTable saves the formatted table to a file.
func (ft FormattedTable) SaveFormattedTable(filename string) error {
	file, err := os.Create(filepath.Clean(filename))
	if err != nil {
		return err
	}
	defer func(file *os.File) {
		_ = file.Close()
	}(file)

	table := tablewriter.NewWriter(file)
	table.SetHeader(ft.header)
	for _, row := range ft.data {
		table.Append(row)
	}
	table.Render()
	return nil
}

/// logger/loggz.go ///
package logger

import (
	il "github.com/kubex-ecosystem/logz/internal/core"
	"log"
	"os"
)

// LogLevel represents the level of the log entry.
type LogLevel = il.LogLevel

// LogFormat represents the format of the log entry.
type LogFormat = il.LogFormat

// LogWriter represents the writer of the log entry.
type LogWriter[T any] interface{ il.LogWriter[T] }

// Config represents the configuration of the il.
type Config interface{ il.Config }

// LogzEntry represents a single log entry with various attributes.
type LogzEntry interface{ il.LogzEntry }

// LogFormatter defines the contract for formatting log entries.
type LogFormatter interface{ il.LogFormatter }

type LogzCore interface{ il.LogzCore }

type LogzLogger interface{ il.LogzLogger }

type Logger struct {
	// il.LogzCoreImpl is the logz core logger
	log.Logger
	// il.LogzLogger is the logz logger
	LogzLogger
}

// logzLogger is the implementation of the LoggerInterface, unifying the new LogzCoreImpl and the old one.
type logzLogger struct {
	// logger is the logz logger.
	//logger LogzLogger
	*Logger

	//il.LogzLogger

	// coreLogger is the LogzCore logger.
	//LogzCore
}

// NewLogger creates a new instance of logzLogger with an optional prefix.
func NewLogger(prefix string) LogzLogger {
	lgzR := &Logger{
		*log.New(
			os.Stdout,
			prefix,
			log.LstdFlags,
		),
		il.NewLogger(prefix),
	}
	lgz := &logzLogger{
		lgzR,
	}
	lgz.SetPrefix(prefix)
	lgz.SetFlags(log.LstdFlags)
	lgz.SetOutput(os.Stdout)
	lgz.SetLevel(il.INFO)
	return lgz
}

func NewDefaultWriter(out *os.File, formatter LogFormatter) *il.DefaultWriter[any] {
	return il.NewDefaultWriter[any](out, formatter)
}

/// logz.go ///
package logz

import (
	"encoding/json"
	"fmt"
	"github.com/kubex-ecosystem/logz/internal/core"
	logz "github.com/kubex-ecosystem/logz/logger"
	vs "github.com/kubex-ecosystem/logz/version"
	"os"
	"sync"
)

var (
	pfx    = "Logz" // Default prefix
	logger Logger   // Global logger instance
	//mu             sync.RWMutex // Mutex for concurrency control
	once           sync.Once // Ensure single initialization
	versionService vs.Service
)

type LogLevel = core.LogLevel
type LogFormat = core.LogFormat

type Config interface{ core.Config }

// type ConfigManager interface{ core.LogzConfigManager }
type NotifierManager interface{ core.NotifierManager }
type Notifier interface{ core.Notifier }
type Logger interface{ logz.LogzLogger }

type JSONFormatter = core.JSONFormatter
type TextFormatter = core.TextFormatter

type Writer struct{ core.LogWriter[any] }

func (w Writer) Write(p []byte) (n int, err error) {
	var decodedMessage map[string]interface{}
	if jsonErr := json.Unmarshal(p, &decodedMessage); jsonErr == nil {
		entry := core.NewLogEntry().
			WithMessage(decodedMessage["message"].(string)).
			WithLevel(GetLogLevel()).
			AddMetadata("original", decodedMessage)

		writeErr := w.LogWriter.Write(entry)
		if writeErr != nil {
			return 0, writeErr
		}
	} else {
		entry := core.NewLogEntry().
			WithMessage(string(p)).
			WithLevel(GetLogLevel())
		writeErr := w.LogWriter.Write(entry)
		if writeErr != nil {
			return 0, writeErr
		}
	}

	return len(p), nil
}

// SetLogWriter sets the log writer for the global core.
func SetLogWriter(writer interface{}) {
	//mu.Lock()
	//defer mu.Unlock()
	if logger != nil {
		nWriter := core.NewDefaultWriter[any](writer.(Writer), &TextFormatter{})
		logger.SetWriter(nWriter)
	}
}

// GetLogWriter returns the log writer of the global core.
func GetLogWriter() *Writer {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger == nil {
		return nil
	}
	writer := logger.GetWriter().(logz.LogWriter[any])
	return &Writer{LogWriter: writer}
}

func NewWriter(out *os.File, formatter core.LogFormatter) Writer {
	if out == nil {
		out = os.Stdout
	}
	return Writer{LogWriter: core.NewDefaultWriter[any](out, formatter)}
}

// initializeLogger initializes the global logger with the given prefix.
func initializeLogger(prefix string) {
	//	once.Do(func() {
	if prefix == "" {
		prefix = pfx
	}
	if logger != nil {
		return
	}
	logger = logz.NewLogger(prefix).(Logger)
	logLevel := os.Getenv("LOG_LEVEL")
	if logLevel != "" {
		logger.SetLevel(core.LogLevel(logLevel))
	} else {
		logger.SetLevel(core.INFO)
	}
	logFormat := os.Getenv("LOG_FORMAT")
	//config := logger.GetConfig().(*core.Config)
	if logFormat != "" {
		logger.SetFormat(core.LogFormat(logFormat))
	} else {
		//logger.GetConfig().SetFormat(core.TEXT)
	}
	logOutput := os.Getenv("LOG_OUTPUT")
	if logOutput != "" {
		//logger.GetConfig().SetOutput(logOutput)
	} else {
		//logger.GetConfig().SetOutput(os.Stdout.Name())
	}
	//	})
}

// GetLogger returns the global core instance, initializing it if necessary.
func GetLogger(prefix string) Logger {
	initializeLogger(prefix)

	////mu.RLock()
	//defer mu.RUnlock()
	return logger
}

// NewLogger creates a new core instance with the given prefix.
func NewLogger(prefix string) Logger {
	return logz.NewLogger(prefix)
}

// SetLogger sets the global core instance to the provided core.
func SetLogger(newLogger Logger) {
	//mu.Lock()
	//defer mu.Unlock()
	logger = newLogger
}

// SetPrefix sets the global prefix for the core.
func SetPrefix(prefix string) {
	//mu.Lock()
	//defer mu.Unlock()
	pfx = prefix
}

// GetPrefix returns the global prefix for the core.
func GetPrefix() string {
	////mu.RLock()
	//defer mu.RUnlock()
	return pfx
}

// SetLogLevel sets the log level for the global core.
func SetLogLevel(level LogLevel) {
	//mu.Lock()
	//defer mu.Unlock()
	if logger != nil {
		logger.SetLevel(level)
	}
}

// GetLogLevel returns the log level of the global core.
func GetLogLevel() LogLevel {
	if logger == nil {
		return core.DEBUG
	}
	return LogLevel(logger.GetLevel().(string))
}

// SetLogConfig sets the configuration for the global core.
func SetLogConfig(config Config) {
	//mu.Lock()
	//defer mu.Unlock()
	if logger != nil {
		logger.SetConfig(config)
	}
}

// GetLogConfig returns the configuration of the global core.
func GetLogConfig() Config {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger == nil {
		return nil
	}
	return logger.GetConfig().(core.Config)
}

// SetMetadata sets a metadata key-value pair for the global core.
func SetMetadata(key string, value interface{}) {
	//mu.Lock()
	//defer mu.Unlock()
	if logger != nil {
		logger.SetMetadata(key, value)
	}
}

// Trace logs a trace message with the given context.
func TraceCtx(msg string, ctx map[string]interface{}) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger != nil {
		logger.TraceCtx(msg, ctx)
	}
}

// Notice logs a notice message with the given context.
func NoticeCtx(msg string, ctx map[string]interface{}) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger != nil {
		logger.NoticeCtx(msg, ctx)
	}
}

// Success logs a success message with the given context.
func SuccessCtx(msg string, ctx map[string]interface{}) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger != nil {
		logger.SuccessCtx(msg, ctx)
	}
}

// Debug logs a debug message with the given context.
func DebugCtx(msg string, ctx map[string]interface{}) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger != nil {
		logger.DebugCtx(msg, ctx)
	}
}

// InfoCtx logs an info message with the given context.
func InfoCtx(msg string, ctx map[string]interface{}) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger != nil {
		logger.InfoCtx(msg, ctx)
	}
}

// Warn logs a warning message with the given context.
func WarnCtx(msg string, ctx map[string]interface{}) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger != nil {
		logger.WarnCtx(msg, ctx)
	}
}

// Error logs an error message with the given context.
func ErrorCtx(msg string, ctx map[string]interface{}) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger != nil {
		logger.ErrorCtx(msg, ctx)
	}
}

// FatalC logs a fatal message with the given context and exits the application.
func FatalCtx(msg string, ctx map[string]interface{}) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger != nil {
		logger.FatalCtx(msg, ctx)
	}
}

// AddNotifier adds a notifier to the global core's configuration.
func AddNotifier(name string, notifier Notifier) {
	//mu.Lock()
	//defer mu.Unlock()
	if logger != nil {
		logger.
			GetConfig() /*.
			NotifierManager().
			AddNotifier(name, notifier)*/
	}
}

// GetNotifier returns the notifier with the given name from the global core's configuration.
func GetNotifier(name string) (interface{}, bool) { //(Notifier, bool) {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger == nil {
		return nil, false
	}
	return logger.GetConfig(), true
}

// ListNotifiers returns a list of all notifier names in the global core's configuration.
func ListNotifiers() []string {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger == nil {
		return nil
	}
	return nil /*logger.
	GetConfig().
	NotifierManager().
	ListNotifiers()*/
}

// SetLogFormat sets the log format for the global core.
func SetLogFormat(format LogFormat) {
	//mu.Lock()
	//defer mu.Unlock()
	if logger != nil {
		/*logger.
		GetConfig().
		SetFormat(format)*/
	}
}

// GetLogFormat returns the log format of the global core.
func GetLogFormat() string {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger == nil {
		return "text"
	}
	cfg := logger.GetConfig()
	if cfg == nil {
		return "text"
	} else {
		return "json"
	}

	//return logger.GetConfig().Format()
}

// SetLogOutput sets the log output for the global core.
func SetLogOutput(output string) {
	//mu.Lock()
	//defer mu.Unlock()
	if logger != nil {
		cfg := logger.GetConfig()
		ccc := cfg.(*core.Config)
		cc := *ccc
		cc.SetOutput(output)
		logger.SetConfig(ccc)

	}
}

// GetLogOutput returns the log output of the global core.
func GetLogOutput() string {
	//mu.RLock()
	//defer mu.RUnlock()
	if logger == nil {
		return os.Stdout.Name()
	}
	cfg := logger.GetConfig()
	if cfg == nil {
		return os.Stdout.Name()
	} else {
		return cfg.(core.Config).Output()
	}
}

// CheckVersion checks the version of the core.
func CheckVersion() string {
	if versionService == nil {
		versionService = vs.NewVersionService()
	}
	if isLatest, err := versionService.IsLatestVersion(); err != nil {
		return "error checking version"
	} else {
		if isLatest {
			return "latest version"
		}
	}
	if latestVersion, err := versionService.GetLatestVersion(); err != nil {
		return "error getting latest version"
	} else {
		return fmt.Sprintf("latest version: %s\nYou are using version: %s", latestVersion, versionService.GetCurrentVersion())
	}
}

// Version returns the current version of the core.
func Version() string {
	if versionService == nil {
		versionService = vs.NewVersionService()
	}
	return versionService.GetCurrentVersion()
}

// Info returns the log output of the global core.
func Info(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.InfoCtx(fmt.Sprint(args...), nil)
}

// Debug returns the log output of the global core.
func Debug(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.DebugCtx(fmt.Sprint(args...), nil)
}

// Warn returns the log output of the global core.
func Warn(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.WarnCtx(fmt.Sprint(args...), nil)
}

// Error returns the log output of the global core.
func Error(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.ErrorCtx(fmt.Sprint(args...), nil)
}

// Fatal returns the log output of the global core.
func Fatal(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.FatalCtx(fmt.Sprint(args...), nil)
}

// Trace returns the log output of the global core.
func Trace(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.TraceCtx(fmt.Sprint(args...), nil)
}

// Notice returns the log output of the global core.
func Notice(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.NoticeCtx(fmt.Sprint(args...), nil)
}

// Success returns the log output of the global core.
func Success(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.SuccessCtx(fmt.Sprint(args...), nil)
}

// Panic returns the log output of the global core.
func Panic(args ...any) {
	if logger == nil {
		logger = logz.NewLogger(pfx)
	}
	logger.FatalCtx(fmt.Sprint(args...), nil)
}

/// support/composer.sh ///
#!/bin/bash

# Define o diret√≥rio base
BASE_DIR="lib"

# Lista de arquivos a serem criados
FILES=(
  "config.sh"
  "utils.sh"
  "platform.sh"
  "build.sh"
  "validate.sh"
  "install_funcs.sh"
  "info.sh"
)

# Cria o diret√≥rio base, se ainda n√£o existir
mkdir -p "$BASE_DIR"

# Cria os arquivos dentro do diret√≥rio
for file in "${FILES[@]}"; do
  FILE_PATH="$BASE_DIR/$file"
  if [[ ! -f "$FILE_PATH" ]]; then
    touch "$FILE_PATH"
    printf '%s' "#!/bin/bash" | tee "$FILE_PATH" >/dev/null
    printf '%s' "# $file - script placeholder" | tee -a "$FILE_PATH" >/dev/null
    chmod +x "$FILE_PATH"
    echo "Criado: $FILE_PATH"
  else
    echo "J√° existe: $FILE_PATH"
  fi
done


/// support/config.sh ///
#!/usr/bin/env bash

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

# Define o diret√≥rio raiz (assumindo que este script est√° em lib/ no root)
_ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
_APP_NAME="${APP_NAME:-$(basename "${_ROOT_DIR}")}"
_PROJECT_NAME="$_APP_NAME"
_OWNER="${OWNER:-rafa-mori}"
# Tenta ler a vers√£o, ou define um fallback
_VERSION=$(cat "$_ROOT_DIR/version/CLI_VERSION" 2>/dev/null || echo "v0.0.0")
# Extrai a vers√£o do Go do go.mod (certifique-se de que este arquivo exista na raiz)
_VERSION_GO=$(grep '^go ' "$_ROOT_DIR/go.mod" | awk '{print $2}')

_LICENSE="MIT"faelmori

_ABOUT="################################################################################
  Este script instala o projeto ${_PROJECT_NAME}, vers√£o ${_VERSION}.
  OS suportados: Linux, MacOS, Windows
  Arquiteturas suportadas: amd64, arm64, 386
  Fonte: https://github.com/${_OWNER}/${_PROJECT_NAME}
  Binary Release: https://github.com/${_OWNER}/${_PROJECT_NAME}/releases/latest
  License: ${_LICENSE}
  Notas:
    - [version] √© opcional; se omitido, a √∫ltima vers√£o ser√° utilizada.
    - Se executado localmente, o script tentar√° resolver a vers√£o pelos tags do reposit√≥rio.
    - Instala em ~/.local/bin para usu√°rio n√£o-root ou em /usr/local/bin para root.
    - Adiciona o diret√≥rio de instala√ß√£o √† vari√°vel PATH.
    - Instala o UPX se necess√°rio, ou compila o bin√°rio (build) conforme o comando.
    - Faz download do bin√°rio via URL de release ou efetua limpeza de artefatos.
    - Verifica depend√™ncias e vers√£o do Go.
################################################################################"

_BANNER="################################################################################

               ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà     ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà     ‚ñà‚ñà
              ‚ñë‚ñà‚ñà  ‚ñà‚ñà ‚ñë‚ñà‚ñà    ‚ñë‚ñà‚ñà‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë ‚ñë‚ñë‚ñà‚ñà   ‚ñà‚ñà
              ‚ñë‚ñà‚ñà ‚ñà‚ñà  ‚ñë‚ñà‚ñà    ‚ñë‚ñà‚ñà‚ñë‚ñà   ‚ñë‚ñà‚ñà ‚ñë‚ñà‚ñà       ‚ñë‚ñë‚ñà‚ñà ‚ñà‚ñà
              ‚ñë‚ñà‚ñà‚ñà‚ñà   ‚ñë‚ñà‚ñà    ‚ñë‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñë‚ñë‚ñà‚ñà‚ñà
              ‚ñë‚ñà‚ñà‚ñë‚ñà‚ñà  ‚ñë‚ñà‚ñà    ‚ñë‚ñà‚ñà‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë ‚ñà‚ñà‚ñë‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë     ‚ñà‚ñà‚ñë‚ñà‚ñà
              ‚ñë‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà ‚ñë‚ñà‚ñà    ‚ñë‚ñà‚ñà‚ñë‚ñà    ‚ñë‚ñà‚ñà‚ñë‚ñà‚ñà        ‚ñà‚ñà ‚ñë‚ñë‚ñà‚ñà
              ‚ñë‚ñà‚ñà ‚ñë‚ñë‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñë‚ñë‚ñà‚ñà
              ‚ñë‚ñë   ‚ñë‚ñë  ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë ‚ñë‚ñë     ‚ñë‚ñë"

# Caminhos para a compila√ß√£o
_CMD_PATH="$_ROOT_DIR/cmd"
_BUILD_PATH="$(dirname "$_CMD_PATH")"
_BINARY="$_BUILD_PATH/$_APP_NAME"

# Diret√≥rios de instala√ß√£o
_LOCAL_BIN="${HOME:-"~"}/.local/bin"
_GLOBAL_BIN="/usr/local/bin"

# Caso queira, defina o OWNER (use no get_release_url)
_OWNER="faelmori"

/// support/info.sh ///
#!/usr/bin/env bash
# lib/info.sh ‚Äì Fun√ß√µes para exibir banners e resumo de instala√ß√£o

show_about() {
    printf '%s\n\n' "${_ABOUT:-}"
}

show_banner() {
    printf '\n%s\n\n' "${_BANNER:-}"
}

show_headers() {
    show_banner || return 1
    show_about || return 1
}

summary() {
    local install_dir="$_BINARY"
    log success "Build e instala√ß√£o conclu√≠dos!"
    log success "Bin√°rio: $_BINARY"
    log success "Instalado em: ${install_dir}"
    check_path "$install_dir"
}

export -f show_about
export -f show_banner
export -f show_headers
export -f summary


/// support/install.sh ///
#!/usr/bin/env bash

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix

IFS=$'\n\t'

_DEBUG=${DEBUG:-false}
_HIDE_ABOUT=${HIDE_ABOUT:-false}

# Carrega os arquivos de biblioteca
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
#shellcheck source=/dev/null
source "${SCRIPT_DIR}/config.sh"
#shellcheck source=/dev/null
source "${SCRIPT_DIR}/utils.sh"
#shellcheck source=/dev/null
source "${SCRIPT_DIR}/platform.sh"
#shellcheck source=/dev/null
source "${SCRIPT_DIR}/validate.sh"
#shellcheck source=/dev/null
source "${SCRIPT_DIR}/install_funcs.sh"
#shellcheck source=/dev/null
source "${SCRIPT_DIR}/build.sh"
#shellcheck source=/dev/null
source "${SCRIPT_DIR}/info.sh"

# Inicializa os traps
set_trap "$@"

clear_screen

main() {
  if ! what_platform; then
    log error "Plataforma n√£o suportada: ${_PLATFORM}"
    exit 1
  fi

  if [[ "${_DEBUG}" != true ]]; then
    show_headers
    if [[ -z "${_HIDE_ABOUT}" ]]; then
      show_about
    fi
  else
    log info "Modo debug ativado; banner ser√° ignorado..."
    if [[ -z "${_HIDE_ABOUT}" ]]; then
      show_about
    fi
  fi

  _ARGS=( "$@" )
  local default_label='Auto detect'
  local arrArgs=( "${_ARGS[@]:0:$#}" )
  local PLATFORM_ARG
  PLATFORM_ARG=$(_get_os_from_args "${arrArgs[1]:-${_PLATFORM}}")
  local ARCH_ARG
  ARCH_ARG=$(_get_arch_arr_from_args "${arrArgs[2]:-${_ARCH}}")

  log info "Comando: ${arrArgs[0]:-}" true
  log info "Plataforma: ${PLATFORM_ARG:-$default_label}" true
  log info "Arquitetura: ${ARCH_ARG:-$default_label}" true
  log info "Args: ${_ARGS[*]:-}" true

  case "${arrArgs[0]:-}" in
    build|BUILD|-b|-B)
      # validate_versions
      log info "Executando comando de build..."
      build_binary "${PLATFORM_ARG}" "${ARCH_ARG}" || exit 1
      ;;
    install|INSTALL|-i|-I)
      log info "Executando comando de instala√ß√£o..."
      read -r -p "Deseja baixar o bin√°rio pr√©-compilado? [y/N] (Caso contr√°rio, far√° build local): " choice </dev/tty
      log info "Escolha do usu√°rio: ${choice}"
      if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
          log info "Baixando bin√°rio pr√©-compilado..."
          install_from_release
      else
          log info "Realizando build local..."
          validate_versions
          build_binary "${PLATFORM_ARG}" "${ARCH_ARG}" || exit 1
          install_binary
      fi
      summary
      ;;
    clear|clean|CLEAN|-c|-C)
      log info "Executando comando de limpeza..."
      clean_artifacts
      log success "Clean executado com sucesso."
      ;;
    *)
      log error "Comando inv√°lido: ${arrArgs[0]:-}"
      echo "Uso: $0 {build|install|clean}"
      ;;
  esac
}

# Fun√ß√£o para limpar artefatos de build
clean_artifacts() {
    log info "Limpando artefatos de build..."
    local platforms=("windows" "darwin" "linux")
    local archs=("amd64" "386" "arm64")
    for platform in "${platforms[@]}"; do
        for arch in "${archs[@]}"; do
            local output_name
            output_name=$(printf '%s_%s_%s' "${_BINARY}" "${platform}" "${arch}")
            if [[ "${platform}" != "windows" ]]; then
                local compress_name="${output_name}.tar.gz"
            else
                output_name="${output_name}.exe"
                local compress_name="${_BINARY}_${platform}_${arch}.zip"
            fi
            rm -f "${output_name}" || true
            rm -f "${compress_name}" || true
        done
    done
    log success "Artefatos de build removidos."
}

# echo "MAKE ARGS: ${ARGS[*]:-}"
log info "Starting installation script..."
main "$@"


/// support/install_funcs.sh ///
#!/usr/bin/env bash
# lib/install_funcs.sh ‚Äì Fun√ß√µes para instala√ß√£o e manipula√ß√£o de PATH

install_upx() {
    if ! command -v upx &> /dev/null; then
        if ! sudo -v &> /dev/null; then
            log error "Voc√™ n√£o tem permiss√µes de superusu√°rio para instalar o empacotador de bin√°rios."
            log warn "Se deseja o empacotamento de bin√°rios, instale o UPX manualmente."
            log warn "Veja: https://upx.github.io/"
            return 1
        fi
        if [[ "$(uname)" == "Darwin" ]]; then
            brew install upx >/dev/null
        elif command -v apt-get &> /dev/null; then
            sudo apt-get install -y upx >/dev/null
        elif command -v yum &> /dev/null; then
            sudo yum install -y upx >/dev/null
        elif command -v dnf &> /dev/null; then
            sudo dnf install -y upx >/dev/null
        elif command -v pacman &> /dev/null; then
            sudo pacman -S --noconfirm upx >/dev/null
        elif command -v zypper &> /dev/null; then
            sudo zypper install -y upx >/dev/null
        elif command -v apk &> /dev/null; then
            sudo apk add upx >/dev/null
        elif command -v port &> /dev/null; then
            sudo port install upx >/dev/null
        elif command -v snap &> /dev/null; then
            sudo snap install upx >/dev/null
        elif command -v flatpak &> /dev/null; then
            sudo flatpak install flathub org.uptane.upx -y >/dev/null
        else
            log warn "Se deseja o empacotamento de bin√°rios, instale o UPX manualmente."
            log warn "Veja: https://upx.github.io/"
            return 1
        fi
    fi

    return 0
}

detect_shell_rc() {
    local shell_rc_file
    local user_shell
    user_shell=$(basename "$SHELL")

    case "$user_shell" in
        bash) shell_rc_file="${HOME:-~}/.bashrc" ;;
        zsh) shell_rc_file="${HOME:-~}/.zshrc" ;;
        sh) shell_rc_file="${HOME:-~}/.profile" ;;
        fish) shell_rc_file="${HOME:-~}/.config/fish/config.fish" ;;
        *)
            log warn "Shell n√£o suportado; ajuste o PATH manualmente."
            return 1
            ;;
    esac

    if [ ! -f "$shell_rc_file" ]; then
        log error "Arquivo de configura√ß√£o n√£o encontrado: ${shell_rc_file}"
        return 1
    fi

    echo "$shell_rc_file"

    return 0
}

add_to_path() {
    local target_path="${1:-}"

    local shell_rc_file=""

    local path_expression=""

    path_expression="export PATH=\"${target_path}:\$PATH\""

    shell_rc_file="$(detect_shell_rc)"


    if [ -z "$shell_rc_file" ]; then
        log error "N√£o foi poss√≠vel identificar o arquivo de configura√ß√£o do shell."
        return 1
    fi
    if grep -q "${path_expression}" "$shell_rc_file" 2>/dev/null; then
        log success "$target_path j√° est√° no PATH do $shell_rc_file."
        return 0
    fi

    if [[ -z "${target_path}" ]]; then
        log error "Caminho de destino n√£o fornecido."
        return 1
    fi

    if [[ ! -d "${target_path}" ]]; then
        log error "Caminho de destino n√£o √© um diret√≥rio v√°lido: $target_path"
        return 1
    fi

    if [[ ! -f "${shell_rc_file}" ]]; then
        log error "Arquivo de configura√ß√£o n√£o encontrado: ${shell_rc_file}"
        return 1
    fi

    # echo "export PATH=${target_path}:\$PATH" >> "$shell_rc_file"
    printf '%s\n' "${path_expression}" | tee -a "$shell_rc_file" >/dev/null || {
        log error "Falha ao adicionar $target_path ao PATH em $shell_rc_file."
        return 1
    }

    log success "Adicionado $target_path ao PATH em $shell_rc_file."

    "$SHELL" -c "source ${shell_rc_file}" || {
        log warn "Falha ao recarregar o shell. Por favor, execute 'source ${shell_rc_file}' manualmente."
    }

    return 0
}

install_binary() {
    local SUFFIX="${_PLATFORM_WITH_ARCH}"
    local BINARY_TO_INSTALL="${_BINARY}${SUFFIX:+_${SUFFIX}}"
    log info "Instalando o bin√°rio: '${BINARY_TO_INSTALL}' como '$_APP_NAME'"

    if [ "$(id -u)" -ne 0 ]; then
        log info "Usu√°rio n√£o-root detectado. Instalando em ${_LOCAL_BIN}..."
        mkdir -p "$_LOCAL_BIN"
        cp "$BINARY_TO_INSTALL" "$_LOCAL_BIN/$_APP_NAME" || exit 1
        add_to_path "$_LOCAL_BIN"
    else
        log info "Usu√°rio root detectado. Instalando em ${_GLOBAL_BIN}..."
        cp "$BINARY_TO_INSTALL" "$_GLOBAL_BIN/$_APP_NAME" || exit 1
        add_to_path "$_GLOBAL_BIN"
    fi
}

download_binary() {
    if ! what_platform; then
        log error "Falha ao detectar a plataforma."
        return 1
    fi
    if [[ -z "${_PLATFORM}" ]]; then
        log error "Plataforma n√£o suportada: ${_PLATFORM}"
        return 1
    fi
    local version
    version=$(curl -s "https://api.github.com/repos/${_OWNER}/${_PROJECT_NAME}/releases/latest" | grep "tag_name" | cut -d '"' -f 4 || echo "latest")
    if [ -z "$version" ]; then
        log error "Falha ao determinar a √∫ltima vers√£o."
        return 1
    fi

    local release_url
    release_url=$(get_release_url)
    log info "Baixando o bin√°rio ${_APP_NAME} para OS=${_PLATFORM}, ARCH=${_ARCH}, Vers√£o=${version}..."
    log info "URL de Release: ${release_url}"

    local archive_path="${_TEMP_DIR}/${_APP_NAME}.tar.gz"
    if ! curl -L -o "${archive_path}" "${release_url}"; then
        log error "Falha ao baixar o bin√°rio de: ${release_url}"
        return 1
    fi
    log success "Bin√°rio baixado com sucesso."

    log info "Extraindo o bin√°rio para: $(dirname "${_BINARY}")"
    if ! tar -xzf "${archive_path}" -C "$(dirname "${_BINARY}")"; then
        log error "Falha ao extrair o bin√°rio de: ${archive_path}"
        rm -rf "${_TEMP_DIR}"
        exit 1
    fi

    rm -rf "${_TEMP_DIR}"
    log success "Bin√°rio extra√≠do com sucesso."

    if [ ! -f "$_BINARY" ]; then
        log error "Bin√°rio n√£o encontrado ap√≥s extra√ß√£o: ${_BINARY}"
        exit 1
    fi
    log success "Download e extra√ß√£o de ${_APP_NAME} conclu√≠dos!"
}

install_from_release() {
    download_binary
    install_binary
}

check_path() {
    log info "Verificando se o diret√≥rio de instala√ß√£o est√° no PATH..."
    if ! echo "$PATH" | grep -q "$1"; then
        log warn "$1 n√£o est√° no PATH."
        log warn "Adicione: export PATH=$1:\$PATH"
    else
        log success "$1 j√° est√° no PATH."
    fi
}

export -f install_upx
export -f detect_shell_rc
export -f add_to_path
export -f install_binary
export -f download_binary
export -f install_from_release
export -f check_path

/// support/platform.sh ///
#!/usr/bin/env bash

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

get_release_url() {
    local os="${_PLATFORM%%-*}"
    local format
    if [[ "$os" == "windows" ]]; then
      format="zip"
    else
      format="tar.gz"
    fi
    echo "'https://github.com/${_OWNER}/${_PROJECT_NAME}/releases/download/${_VERSION}/${_PROJECT_NAME}_.${format}'"
}

what_platform() {
  local _os
  _os="$(uname -s)"
  local _arch
  _arch="$(uname -m)"
  local platform=""

  case "${_os}" in
  *Linux*|*Nix*)
    _os="linux"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "armv6") _arch="armv6l" ;;
      "armv8"|"aarch64") _arch="arm64" ;;
      *386*) _arch="386" ;;
    esac
    platform="linux-${_arch}"
    ;;
  *Darwin*)
    _os="darwin"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "arm64") _arch="arm64" ;;
    esac
    platform="darwin-${_arch}"
    ;;
  MINGW*|MSYS*|CYGWIN*|Win*)
    _os="windows"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "arm64") _arch="arm64" ;;
    esac
    platform="windows-${_arch}"
    ;;
  *)
    log error "Plataforma n√£o suportada: ${_os} ${_arch}"
    log error "Informe este problema aos mantenedores do projeto."
    return 1
    ;;
  esac

  export _PLATFORM_WITH_ARCH="${platform//-/_}"
  export _PLATFORM="${_os}"
  export _ARCH="${_arch}"

  return 0
}

_get_os_arr_from_args() {
  local _PLATFORM_ARG=$1
  if [[ "${_PLATFORM_ARG}" == "all" ]]; then
    echo "windows darwin linux"
  else
    echo "${_PLATFORM_ARG}"
  fi
}

_get_arch_arr_from_args() {
  local _ARCH_ARG=$1
  if [[ "${_ARCH_ARG}" == "all" ]]; then
    echo "amd64 386 arm64"
  else
    echo "${_ARCH_ARG}"
  fi
}

_get_os_from_args() {
  local arg=$1
  case "$arg" in
    all|ALL|a|A|-a|-A) echo "all" ;;
    win|WIN|windows|WINDOWS|w|W|-w|-W) echo "windows" ;;
    linux|LINUX|l|L|-l|-L) echo "linux" ;;
    darwin|DARWIN|macOS|MACOS|m|M|-m|-M) echo "darwin" ;;
    *)
      log error "Plataforma inv√°lida: '${arg}'. Op√ß√µes v√°lidas: windows, linux, darwin, all."
      exit 1
      ;;
  esac
}

_get_arch_from_args() {
  local arg=$1
  case "$arg" in
    all|ALL|a|A|-a|-A) echo "all" ;;
    amd64|AMD64|x86_64|X86_64|x64|X64) echo "amd64" ;;
    arm64|ARM64|aarch64|AARCH64) echo "arm64" ;;
    386|i386|I386) echo "386" ;;
    *)
      log error "Arquitetura inv√°lida: '${arg}'. Op√ß√µes v√°lidas: amd64, arm64, 386."
      exit 1
      ;;
  esac
}

export -f _get_os_arr_from_args
export -f _get_arch_arr_from_args
export -f _get_os_from_args
export -f _get_arch_from_args
export -f get_release_url
export -f what_platform

what_platform "${@}"

/// support/utils.sh ///
#!/usr/bin/env bash
# lib/utils.sh ‚Äì Fun√ß√µes utilit√°rias

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

# C√≥digos de cor para logs
_SUCCESS="\033[0;32m"
_WARN="\033[0;33m"
_ERROR="\033[0;31m"
_INFO="\033[0;36m"
_NC="\033[0m"

log() {
  local type=${1:-info}
  local message=${2:-}
  local debug=${3:-${DEBUG:-false}}

  case $type in
    info|_INFO|-i|-I)
      if [[ "$debug" == true ]]; then
        printf '%b[_INFO]%b ‚ÑπÔ∏è  %s\n' "$_INFO" "$_NC" "$message"
      fi
      ;;
    warn|_WARN|-w|-W)
      if [[ "$debug" == true ]]; then
        printf '%b[_WARN]%b ‚ö†Ô∏è  %s\n' "$_WARN" "$_NC" "$message"
      fi
      ;;
    error|_ERROR|-e|-E)
      printf '%b[_ERROR]%b ‚ùå  %s\n' "$_ERROR" "$_NC" "$message"
      ;;
    success|_SUCCESS|-s|-S)
      printf '%b[_SUCCESS]%b ‚úÖ  %s\n' "$_SUCCESS" "$_NC" "$message"
      ;;
    *)
      if [[ "$debug" == true ]]; then
        log "info" "$message" "$debug"
      fi
      ;;
  esac
}

clear_screen() {
  printf "\033[H\033[2J"
}

get_current_shell() {
  local shell_proc
  shell_proc=$(cat /proc/$$/comm)
  case "${0##*/}" in
    ${shell_proc}*)
      local shebang
      shebang=$(head -1 "$0")
      printf '%s\n' "${shebang##*/}"
      ;;
    *)
      printf '%s\n' "$shell_proc"
      ;;
  esac
}

# Cria um diret√≥rio tempor√°rio para cache
_TEMP_DIR="${_TEMP_DIR:-$(mktemp -d)}"
if [[ -d "${_TEMP_DIR}" ]]; then
    log info "Diret√≥rio tempor√°rio criado: ${_TEMP_DIR}"
else
    log error "Falha ao criar o diret√≥rio tempor√°rio."
fi

clear_script_cache() {
  trap - EXIT HUP INT QUIT ABRT ALRM TERM
  if [[ ! -d "${_TEMP_DIR}" ]]; then
    exit 0
  fi
  rm -rf "${_TEMP_DIR}" || true
  if [[ -d "${_TEMP_DIR}" ]] && sudo -v 2>/dev/null; then
    sudo rm -rf "${_TEMP_DIR}"
    if [[ -d "${_TEMP_DIR}" ]]; then
      printf '%b[_ERROR]%b ‚ùå  %s\n' "$_ERROR" "$_NC" "Falha ao remover o diret√≥rio tempor√°rio: ${_TEMP_DIR}"
    else
      printf '%b[_SUCCESS]%b ‚úÖ  %s\n' "$_SUCCESS" "$_NC" "Diret√≥rio tempor√°rio removido: ${_TEMP_DIR}"
    fi
  fi
  exit 0
}

set_trap() {
  local current_shell=""
  current_shell=$(get_current_shell)
  case "${current_shell}" in
    *ksh|*zsh|*bash)
      declare -a FULL_SCRIPT_ARGS=("$@")
      if [[ "${FULL_SCRIPT_ARGS[*]}" =~ -d ]]; then
          set -x
      fi
      if [[ "${current_shell}" == "bash" ]]; then
        set -o errexit
        set -o pipefail
        set -o errtrace
        set -o functrace
        shopt -s inherit_errexit
      fi
      trap 'clear_script_cache' EXIT HUP INT QUIT ABRT ALRM TERM
      ;;
  esac
}

/// support/validate.sh ///
#!/usr/bin/env bash
# lib/validate.sh ‚Äì Valida√ß√£o da vers√£o do Go e depend√™ncias

validate_versions() {
    local REQUIRED_GO_VERSION="${_VERSION_GO:-1.20.0}"
    local GO_VERSION
    GO_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
    if [[ "$(printf '%s\n' "$REQUIRED_GO_VERSION" "$GO_VERSION" | sort -V | head -n1)" != "$REQUIRED_GO_VERSION" ]]; then
        log error "A vers√£o do Go deve ser >= $REQUIRED_GO_VERSION. Detectado: $GO_VERSION"
        exit 1
    fi
    log success "Vers√£o do Go v√°lida: $GO_VERSION"
    go mod tidy || return 1
}

check_dependencies() {
    for dep in "$@"; do
        if ! command -v "$dep" > /dev/null; then
            log error "$dep n√£o est√° instalado."
            exit 1
        else
            log success "$dep est√° instalado."
        fi
    done
}

export -f validate_versions
export -f check_dependencies

/// version/semantic.go ///
package version

import (
	lgr "github.com/kubex-ecosystem/logz/logger"

	"github.com/spf13/cobra"

	_ "embed"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"
)

const moduleAlias = "Logz"
const moduleName = "logz"
const gitModelUrl = "https://github.com/kubex-ecosystem/" + moduleName + ".git"
const currentVersionFallback = "v1.2.0" // First version with the version file

type Service interface {
	GetLatestVersion() (string, error)
	GetCurrentVersion() string
	IsLatestVersion() (bool, error)
}
type ServiceImpl struct {
	gitModelUrl    string
	latestVersion  string
	currentVersion string
}
type Tag struct {
	Name string `json:"name"`
}

var l = lgr.NewLogger("Logz")

func getLatestTag(repoURL string) (string, error) {
	apiURL := fmt.Sprintf("%s/tags", repoURL)
	resp, err := http.Get(apiURL)
	if err != nil {
		return "", err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to fetch tags: %s", resp.Status)
	}

	var tags []Tag
	if err := json.NewDecoder(resp.Body).Decode(&tags); err != nil {
		return "", err
	}

	if len(tags) == 0 {
		return "", fmt.Errorf("no tags found")
	}

	return tags[0].Name, nil
}

func (v *ServiceImpl) updateLatestVersion() error {
	repoURL := "https://api.github.com/repos/faelmori/spidergo"
	tag, err := getLatestTag(repoURL)
	if err != nil {
		return err
	}
	v.latestVersion = tag
	return nil
}
func (v *ServiceImpl) vrsCompare(v1, v2 []int) (int, error) {
	if len(v1) != len(v2) {
		return 0, fmt.Errorf("version length mismatch")
	}

	for idx, v2S := range v2 {
		v1S := v1[idx]
		if v1S > v2S {
			return 1, nil
		}

		if v1S < v2S {
			return -1, nil
		}
	}
	return 0, nil
}
func (v *ServiceImpl) versionAtMost(versionAtMostArg, max []int) (bool, error) {
	if comp, err := v.vrsCompare(versionAtMostArg, max); err != nil {
		return false, err
	} else if comp == 1 {
		return false, nil
	}
	return true, nil
}
func (v *ServiceImpl) parseVersion(versionToParse string) []int {
	version := make([]int, 3)
	for idx, vStr := range strings.Split(versionToParse, ".") {
		vS, err := strconv.Atoi(vStr)
		if err != nil {
			return nil
		}
		version[idx] = vS
	}
	return version
}

func (v *ServiceImpl) IsLatestVersion() (bool, error) {
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return false, err
		}
	}

	curr := v.parseVersion(v.currentVersion)
	latest := v.parseVersion(v.latestVersion)

	if curr == nil || latest == nil {
		return false, fmt.Errorf("error parsing versions")
	}

	if isLatest, err := v.versionAtMost(curr, latest); err != nil {
		return false, err
	} else if isLatest {
		return true, nil
	}
	return false, nil
}
func (v *ServiceImpl) GetLatestVersion() (string, error) {
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return "", err
		}
	}

	return v.latestVersion, nil
}
func (v *ServiceImpl) GetCurrentVersion() string { return v.currentVersion }

func NewVersionService() Service {
	return &ServiceImpl{
		gitModelUrl:    gitModelUrl,
		currentVersion: currentVersion,
		latestVersion:  "",
	}
}

var (
	versionCmd = &cobra.Command{
		Use:   "version",
		Short: "Print the version number of " + moduleAlias,
		Long:  "Print the version number of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetVersionInfo()
		},
	}
	subLatestCmd = &cobra.Command{
		Use:   "latest",
		Short: "Print the latest version number of " + moduleAlias,
		Long:  "Print the latest version number of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetLatestVersionInfo()
		},
	}
	subCmdCheck = &cobra.Command{
		Use:   "check",
		Short: "Check if the current version is the latest version of " + moduleAlias,
		Long:  "Check if the current version is the latest version of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetVersionInfoWithLatestAndCheck()
		},
	}
)

//go:embed CLI_VERSION
var currentVersion string

func GetVersion() string {
	if currentVersion == "" {
		return currentVersionFallback
	}
	return currentVersion
}

func GetGitModelUrl() string {
	return gitModelUrl
}

func GetVersionInfo() string {
	l.InfoCtx("Version: "+GetVersion(), map[string]interface{}{})
	l.InfoCtx("Git repository: "+GetGitModelUrl(), map[string]interface{}{})
	return fmt.Sprintf("Version: %s\nGit repository: %s", GetVersion(), GetGitModelUrl())
}

func GetLatestVersionFromGit() string {
	netClient := &http.Client{
		Timeout: time.Second * 10,
	}

	gitUrlWithoutGit := strings.TrimSuffix(gitModelUrl, ".git")

	response, err := netClient.Get(gitUrlWithoutGit + "/releases/latest")
	if err != nil {
		l.ErrorCtx("ErrorCtx fetching latest version: "+err.Error(), map[string]interface{}{})
		l.ErrorCtx("Url: "+gitUrlWithoutGit+"/releases/latest", map[string]interface{}{})
		return err.Error()
	}

	if response.StatusCode != 200 {
		l.ErrorCtx("ErrorCtx fetching latest version: "+response.Status, map[string]interface{}{})
		l.ErrorCtx("Url: "+gitUrlWithoutGit+"/releases/latest", map[string]interface{}{})
		body, _ := io.ReadAll(response.Body)
		return fmt.Sprintf("ErrorCtx: %s\nResponse: %s", response.Status, string(body))
	}

	tag := strings.Split(response.Request.URL.Path, "/")

	return tag[len(tag)-1]
}

func GetLatestVersionInfo() string {
	l.InfoCtx("Latest version: "+GetLatestVersionFromGit(), map[string]interface{}{})
	return "Latest version: " + GetLatestVersionFromGit()
}

func GetVersionInfoWithLatestAndCheck() string {
	if GetVersion() == GetLatestVersionFromGit() {
		l.InfoCtx("You are using the latest version.", map[string]interface{}{})
		return fmt.Sprintf("You are using the latest version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	} else {
		l.WarnCtx("You are using an outdated version.", map[string]interface{}{})
		return fmt.Sprintf("You are using an outdated version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	}
}

func CliCommand() *cobra.Command {
	versionCmd.AddCommand(subLatestCmd)
	versionCmd.AddCommand(subCmdCheck)
	return versionCmd
}
