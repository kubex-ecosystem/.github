# LookAtni Code - Gerado automaticamente
# Data: 2025-07-13T23:17:45.068Z
# Fonte: /srv/apps/study/mini_games/
# Total de arquivos: 8

/// README.md ///
# Mini Games Canvas

A simple web project with classic mini games implemented in JavaScript using the HTML5 Canvas API.

## Games Included

- Pong
- Snake
- Tic-Tac-Toe

## How to Use

Open `index.html` in your browser. Select a game and play using your keyboard:

- Arrow keys: Move (where applicable)
- R: Restart game
- S: Stop game
- Enter: Start game
- Esc: Return to menu
- M: Switch game
- F11: Toggle fullscreen
- F5: Reload page
- H: Show/hide this menu

Enjoy!

/// assets/css/style.css ///
/* 
  * Variable Definitions
  * This section defines the CSS variables used throughout the game for colors, fonts, and other styles.
*/
:root {
  --primary-color: #007bff; /* Primary color for buttons and highlights */
  --secondary-color: #6c757d; /* Secondary color for text and backgrounds */
  --background-color: #f8f9fa; /* Background color for the game interface */
  --text-color: #333; /* Primary text color */
  --text-secondary-color: #666; /* Secondary text color */
  --border-radius: 8px; /* Border radius for buttons and containers */
  --box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Box shadow for containers */
  --font-family: 'Arial', sans-serif; /* Font family for the game */
  --font-size-base: 16px; /* Base font size for the game */
  --font-size-large: 2.5rem; /* Large font size for headings */
  --font-size-medium: 1.8rem; /* Medium font size for subheadings */
  --font-size-small: 1rem; /* Small font size for paragraphs */
  --transition-duration: 0.3s; /* Transition duration for hover effects */
  --transition-ease: ease; /* Transition easing function */
}

/*
  * General Styles
  * This section contains the general styles for the game, including body, headings, and paragraphs.
  * It sets the font, background color, and basic layout for the game interface.
*/
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  overflow: hidden; /* Impede rolagem global */
}
html {
  font-size: 16px;
}
body {
  font-family: 'Arial', sans-serif;
  background-color: #f0f0f0;
  color: #333;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
}
h1 {
  font-size: 2.5rem;
  margin: 0 0 20px;
  color: #333;
}
h2 {
  font-size: 1.8rem;
  margin: 0 0 10px;
  color: #555;
}
p {
  font-size: 1rem;
  margin: 0 0 10px;
  color: #666;
}

/*

  * Main Layout Styles
  * This section styles the main layout of the game, including the game container and sidebar.
  * It ensures a responsive and visually appealing design for the game interface.

*/
.main-layout {
  padding: 20px;
  width: 100%;
  height: 80vh; /* Garante que ocupe toda a altura da tela */
  max-width: 1200px;

  flex: 1;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  flex-direction: row;
  position: relative;

  box-sizing: border-box;
  background-color: transparent; /* Fundo transparente para permitir o fundo do body */
  overflow: hidden;
}

/* 
  * Game Container Styles
  * This section styles the game container, which holds the game canvas and sidebar.
  * It ensures a flexible layout that adapts to different screen sizes.
*/
.game-container {
  width: 90%;
  max-width: 800px;
  height: 100%;
  max-height: 80vh;

  flex: 3; /* Ajusta a proporção do container do jogo */
  display: flex;
  flex-direction: column; /* Altera para coluna para melhor responsividade */
  align-items: center;
  justify-content: center;
  box-sizing: border-box;

  overflow: hidden;
  background: transparent; /* Fundo transparente para permitir o fundo do body */

  margin: 0 20px;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

/*
  * Sidebar Styles
  * This section styles the sidebar, which contains game controls and information.
  * It ensures a clean and organized layout for user interactions and game details.
*/
.sidebar {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  position: relative;
  box-sizing: border-box;
  width: 100%;
  max-width: 300px;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  height: 100%;
  max-height: 80vh;
  overflow-y: auto; /* Sidebar pode rolar se necessário */
}


/* 
  * Placeholder Styles
  * This section contains placeholder styles for future game elements.
  * It includes styles for game elements that are not yet implemented but will be added later.
 */
.placeholder {
  display: none; /* Esconde por padrão */
  position: relative;

  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  max-height: 80vh !important; /* Garante que o placeholder não ultrapasse a altura máxima do container */
  max-width: 100%;

  background-color: transparent; /* Fundo transparente para não interferir no layout */
  z-index: 1000; /* Coloca acima dos outros elementos */

  display: flex; /* Usa flexbox para centralizar o conteúdo */
  justify-content: center; /* Centraliza horizontalmente */
  align-items: center; /* Centraliza verticalmente */
  text-align: center; /* Centraliza o texto */
  font-family: 'Arial', sans-serif; /* Fonte do texto */
  font-weight: bold; /* Texto em negrito */
  font-size: 24px; /* Tamanho do texto */
  color: white; /* Cor do texto */
  
  border-radius: var(--border-radius); /* Borda arredondada */
  box-shadow: var(--box-shadow); /* Sombra para destaque */

  transition: ease --transition-duration 1s;
  opacity: 0.8; /* Opacidade para suavizar o visual */
  background: rgba(0, 0, 0, 0.5); /* Fundo semi-transparente para destaque */
}
.placeholder.active {
  display: flex; /* Exibe o placeholder quando ativo */
  flex-direction: column; /* Alinha o conteúdo em coluna */
  align-content: center; /* Alinha o conteúdo */
  justify-content: center; /* Centraliza verticalmente */
  width: 100%; /* Ocupa toda a largura disponível */
  height: 100%; /* Ocupa toda a altura disponível */
}

/* 
  * Game Canvas Styles
  * This section styles the game canvas, ensuring it is responsive and visually appealing.
  * It includes styles for the canvas element, including dimensions, borders, and shadows.
*/
.game-canvas {
  display: none;
  position: relative;
  width: 100%;
  height: 100%;
  max-width: 800px;
  max-height: 600px;
  margin: 0 auto;
}
.game-canvas.active {
  display:  flex !important; /* Exibe o canvas quando ativo */
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border: 2px solid #007bff;
  border-radius: 8px;
  width: 90%;
  height: 100%;
}
.game-canvas canvas {
  position: absolute;
  top: 0;
  left: 0;
  display: none; /* Esconde o canvas por padrão */
}
.game-canvas canvas:focus {
  outline: none;
  box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
}
.game-canvas canvas:hover {
  transform: scale(1.05);
}
.game-canvas canvas:active {
  transform: scale(0.95);
}
.game-canvas canvas:focus-visible {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}
.game-canvas canvas:focus:not(:focus-visible) {
  outline: none;
}
.active {
  display: flex !important; /* Exibe o sidebar quando ativo */
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
  background: #f8f9fa;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 800px;
  height: 100%; /* Sempre ocupa toda a altura disponível */
  margin: 0 auto;
}

/*
  * Game Controls Styles
  * This section styles the game controls, including buttons and layout.
  * It ensures a clean and user-friendly interface for game interactions.
*/
.game-controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
}
.game-controls h2 {
  margin-bottom: 10px;
  font-size: 1.5rem;
  color: #333;
}
.game-controls p {
  margin: 0 0 10px;
  font-size: 1rem;
  color: #666;
}
.game-controls .btns {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 10px;
}
.game-controls .btns button {
  padding: 10px 20px;
  font-size: 1rem;
  cursor: pointer;
  background: #007bff;
  color: #fff;
  border: none;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}
.game-controls .btns button:hover {
  background: #0056b3;
}
.game-controls .btns button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
.game-controls .btns button:disabled:hover {
  background: #ccc;
}
.game-controls .btns button:focus {
  outline: none;
  box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
}

/* 
  * Responsive Styles
  * This section contains media queries to ensure the game layout is responsive and adapts to different screen sizes.
  * It adjusts the layout for smaller screens, ensuring a user-friendly experience on mobile devices.
*/
@media screen and (max-width: 768px) {
  body, html {
    overflow: auto;
  }
  .main-layout {
    flex-direction: column;
    height: auto;
    overflow: visible;
  }
  .game-container {
    height: auto;
    max-height: 400px;
  }
  .sidebar {
    max-height: 300px;
    height: auto;
  }
  .game-canvas {
    max-width: 100%;
    max-height: 400px;
  }
  .game-canvas canvas {
    width: 100%;
    height: auto;
  }
  .game-controls {
    width: 100%;
    max-width: 100%;
    margin-bottom: 20px;
  }
  .game-controls .btns {
    flex-direction: column;
    align-items: center;
  }
  .game-controls .btns button {
    width: 100%;
    max-width: 200px;
    margin-bottom: 10px;
  }
  .game-controls .btns button:last-child {
    margin-bottom: 0;
  }
  .sidebar h2 {
    font-size: 1.5rem;
  }
  .sidebar p {
    font-size: 0.9rem;
  }
  .game-controls h2 {
    font-size: 1.5rem;
  }
  .game-controls p {
    font-size: 0.9rem;
  }
  .game-canvas canvas:focus-visible {
    outline: 2px solid #007bff;
    outline-offset: 2px;
  }
  .game-canvas canvas:focus:not(:focus-visible) {
    outline: none;
  }
  .game-controls .btns button:focus {
    outline: none;
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
  }
  .game-controls .btns button:focus-visible {
    outline: 2px solid #007bff;
    outline-offset: 2px;
  }
  .game-controls .btns button:focus:not(:focus-visible) {
    outline: none;
  }
  .game-controls .btns button:hover {
    background: #0056b3;
  }
  .game-controls .btns button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
  .game-controls .btns button:disabled:hover {
    background: #ccc;
  }
  .game-controls .btns button:active {
    transform: scale(0.95);
  }
}

/* 
  * Accessibility Styles
  * This section ensures that the game is accessible to all users, including those with disabilities.
  * It includes styles for focus states, contrast, and readability.
*/
:focus {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}
:focus:not(:focus-visible) {
  outline: none;
}
:focus-visible {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}
:focus:not(:focus-visible) {
  outline: none;
}

/* 
  * Print Styles
  * This section contains styles for printing the game interface.
  * It ensures that the game is printed in a clean and readable format.
*/
@media print {
  body {
    background-color: #fff;
    color: #000;
  }
  .game-canvas, .sidebar, .game-controls {
    box-shadow: none;
    border: none;
  }
  .game-canvas canvas {
    border: none;
  }
  .game-controls .btns button {
    display: none;
  }
  h1, h2, p {
    page-break-inside: avoid;
  }
}

/* 
  * Scrollbar Styles
  * This section styles the scrollbar for a consistent look across browsers.
 */
 ::-webkit-scrollbar {
  width: 12px;
}

::-webkit-scrollbar-thumb {
  background: #007bff;
  border-radius: 6px;
}

::-webkit-scrollbar-thumb:hover {
  background: #0056b3;
}
::-webkit-scrollbar-track {
  background: #f0f0f0;
}
/* Scrollbar styles for Firefox */
@-moz-document url-prefix() {
  ::-moz-scrollbar {
    width: 12px;
  }
  ::-moz-scrollbar-thumb {
    background: #007bff;
    border-radius: 6px;
  }
  ::-moz-scrollbar-thumb:hover {
    background: #0056b3;
  }
  ::-moz-scrollbar-track {
    background: #f0f0f0;
  }
}
/* Scrollbar styles for Edge and IE */
@supports (-ms-ime-align: auto) {
  ::-ms-scrollbar {
    width: 12px;
  }
  ::-ms-scrollbar-thumb {
    background: #007bff;
    border-radius: 6px;
  }
  ::-ms-scrollbar-thumb:hover {
    background: #0056b3;
  }
  ::-ms-scrollbar-track {
    background: #f0f0f0;
  }
}

/* End of CSS Styles */
/* 
  * Additional Styles
  * This section contains any additional styles that may be needed for specific game features or components.
  * It can include styles for modals, notifications, or other UI elements.
*/
.additional-styles {
  /* Placeholder for additional styles */
}

/// assets/js/games.js ///
var game = null;

window.addEventListener('load', () => {
    const placeholderCanvas = document.getElementById('placeholder');
    const pongCanvas = document.getElementById('pong');
    const snakeCanvas = document.getElementById('snake');
    const tttCanvas = document.getElementById('tictactoe');
    
    const gamesMap = {
        initGame: () => {
            document.getElementById('record').textContent = game.record.load();
            canvasCtl.resizeCanvas(pongCanvas);
            canvasCtl.resizeCanvas(snakeCanvas);
            canvasCtl.resizeCanvas(tttCanvas);
            document.getElementById('restart').onclick = () => {
                document.getElementById('score').textContent = '0';
                game.reset();
            };
            document.getElementById('start').onclick = () => {
                game.start('pong');
            };
            document.getElementById('stop').onclick = () => {
                game.stop();
            };
        },
        pong: () => {
            game = new PongGame();
            game.start('pong');
            game.initGame();
            // Dificuldade
            const diffSelect = document.getElementById('pong-difficulty');
            if (diffSelect) {
                diffSelect.onchange = (e) => {
                    game.setDifficulty(e.target.value);
                };
                // Aplica a dificuldade inicial
                game.setDifficulty(diffSelect.value);
            }
        },
        snake: () => {
            game = new SnakeGame();
            game.start('snake');
            game.initGame();
        },
        tictactoe: () => {
            game = new TicTacToe(document.getElementById('tictactoe'));
            game.initGame();
        }
    };
    const gamesCtl = {
        stopGame: () => {
            if (game && typeof game.stop === 'function') {
                game.stop();
                game = null;
            }
            // Esconde todos os canvases
            canvasCtl.showOnlyCanvas(null);
        },
        showGame: (gameType) => {
            gamesCtl.stopGame();
            buttonsCtl.resetButtonStyles();
            // Mostra apenas o canvas do jogo selecionado
            canvasCtl.showOnlyCanvas(gameType);
            gamesMap[gameType]?.();
            buttonsCtl.highlightSelectedButton(gameType);
        }
    };
    const buttonsCtl = {
        resetButtonStyles: () => {
            const buttons = document.querySelectorAll('.btns button');
            buttons.forEach(button => {
                buttonsCtl.unhighlightButton(button);
            });
        },
        highlightButton: (button) => {
            button.style.backgroundColor = '#4CAF50';
            button.style.color = 'white';
        },
        unhighlightButton: (button) => {
            button.style.backgroundColor = '';
            button.style.color = '';
        },
        resetButtonStyles: () => {
            const buttons = document.querySelectorAll('.btns button');
            buttons.forEach(button => {
                buttonsCtl.unhighlightButton(button);
            });
        },
        highlightSelectedButton: (gameType) => {
            const buttons = document.querySelectorAll('.btns button');
            buttons.forEach(button => {
                if (button.textContent.toLowerCase() === gameType.toLowerCase()) {
                    buttonsCtl.highlightButton(button);
                } else {
                    buttonsCtl.unhighlightButton(button);
                }
            });
        }
    };
    const canvasCtl = {
        showOnlyCanvas: (canvasId) => {
            const canvases = document.querySelectorAll('.game-canvas');
            let showPlaceholder = true;
            canvases.forEach(canvas => {
                if (canvasId && canvas.id === canvasId) {
                    canvas.classList.add('active');
                    showPlaceholder = false;
                } else {
                    canvas.style.display = 'none'; // Esconde novamente se não for o ativo
                    canvas.classList.remove('active');
                }
            });
            if (showPlaceholder) {
                placeholderCtl.showPlaceholder(); // Mostra o placeholder se nenhum jogo estiver ativo
            } else {
                placeholderCtl.hidePlaceholder(); // Esconde o placeholder se um jogo estiver ativo
            }
        },
        resizeCanvas: (canvas) => {
            if (!canvas) return;
            const aspectRatio = 4 / 3;
            let width = Math.min(window.innerWidth * 0.7, 800);
            let height = width / aspectRatio;
            if (height > window.innerHeight * 0.8) {
                height = window.innerHeight * 0.8;
                width = height * aspectRatio;
            }
            canvas.width = width;
            canvas.height = height;
        }
    };
    const placeholderCtl = {
        initPlaceholder: () => {
            if (!placeholderCanvas) {
                console.warn('Placeholder canvas não encontrado, criando um novo.');
                throw new Error('Placeholder canvas não encontrado.');
            }
            
            document.body.appendChild(placeholderCanvas);
        },
        drawPlaceholder: () => {
            if (!placeholderCanvas) return;

            const ctx = placeholderCanvas.getContext('2d');
            ctx.clearRect(0, 0, placeholderCanvas.width, placeholderCanvas.height);

            // Fundo igual ao body
            ctx.fillStyle = getComputedStyle(document.body).backgroundColor || '#f0f0f0';
            ctx.fillRect(0, 0, placeholderCanvas.width, placeholderCanvas.height);

            // Caixa centralizada
            const boxWidth = Math.min(400, placeholderCanvas.width);
            const boxHeight = 180;

            const boxX = (placeholderCanvas.width - boxWidth) / 2;
            const boxY = (placeholderCanvas.height - boxHeight) / 2;

            // Borda arredondada
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(boxX + 16, boxY);

            ctx.lineTo(boxX + boxWidth - 16, boxY);
            ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + 16);

            ctx.lineTo(boxX + boxWidth, boxY + boxHeight - 16);
            ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - 16, boxY + boxHeight);

            ctx.lineTo(boxX + 16, boxY + boxHeight);
            ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - 16);

            ctx.lineTo(boxX, boxY + 16);
            ctx.quadraticCurveTo(boxX, boxY, boxX + 16, boxY);

            ctx.closePath();
            ctx.fillStyle = getComputedStyle(document.body).backgroundColor || '#f0f0f0';
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#007bff';
            ctx.stroke();
            ctx.restore();
            // Texto centralizado
            ctx.fillStyle = '#333';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Selecione um jogo', placeholderCanvas.width / 2, boxY + 75);
            ctx.font = '18px Arial';
            ctx.fillText('ou pressione ESC para sair', placeholderCanvas.width / 2, boxY + 100);
        },
        showPlaceholder: () => {
            const placeholderCanvas = document.getElementById('placeholder');
            if (placeholderCanvas) {
                placeholderCanvas.style.display = 'block'; // Mostra o canvas placeholder
                placeholderCtl.drawPlaceholder();
            }
        },
        hidePlaceholder: () => {
            const placeholderCanvas = document.getElementById('placeholder');
            if (placeholderCanvas) {
                placeholderCanvas.style.display = 'none'; // Esconde o canvas placeholder
            }
        }
    };

    const setEventListeners = () => {
        document.querySelectorAll('.btns button').forEach(button => {
            button.addEventListener('click', (event) => {
                const gameType = event.target.dataset.game;
                gamesCtl.showGame(gameType);
                buttonsCtl.highlightSelectedButton(gameType);
            });
        });
        window.addEventListener('resize', () => {
            // Redimensiona todos os canvases ao redimensionar a janela
            canvasCtl.resizeCanvas(placeholderCanvas);
            canvasCtl.resizeCanvas(pongCanvas);
            canvasCtl.resizeCanvas(snakeCanvas);
            canvasCtl.resizeCanvas(tttCanvas);
        });
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                gamesCtl.stopGame();
                buttonsCtl.resetButtonStyles();
            }
        });
        window.addEventListener('resize', resizeAllCanvases);
    };
    const resizeAllCanvases = () => {
        [pongCanvas, snakeCanvas, tttCanvas].forEach(canvas => {
            if (canvas) {
                canvasCtl.resizeCanvas(canvas);
            }
        });
    };
    
    // Observa redimensionamento do body para ajustar todos os canvases
    if (!('ResizeObserver' in window)) {
        console.warn('ResizeObserver não suportado, usando fallback de resize.');
        window.addEventListener('resize', resizeAllCanvases);
    } else {
        const resizeObserver = new ResizeObserver(resizeAllCanvases);
        resizeObserver.observe(document.body);
    }

    // Redimensiona todos os canvases ao carregar e ao redimensionar a janela
    resizeAllCanvases();
    // Mostra nada por padrão
    canvasCtl.showOnlyCanvas(null);
    // Registra os event listeners
    setEventListeners();
});

// Função utilitária para aplicar dificuldade se suportado
function applyDifficulty(gameInstance, difficulty) {
    if (typeof gameInstance.setDifficulty === 'function' && difficulty) {
        gameInstance.setDifficulty(difficulty);
    }
}

// Novo método centralizado para iniciar qualquer jogo
function startGame(gameName, options = {}) {
    if (game && typeof game.stop === 'function') game.stop();
    let instance;
    switch (gameName) {
        case 'pong':
            instance = new PongGame();
            instance.start('pong');
            applyDifficulty(instance, options.difficulty || (document.getElementById('pong-difficulty')?.value));
            break;
        case 'snake':
            instance = new SnakeGame();
            instance.start('snake');
            applyDifficulty(instance, options.difficulty);
            break;
        case 'tictactoe':
            instance = new TicTacToe(document.getElementById('tictactoe'));
            applyDifficulty(instance, options.difficulty);
            break;
        default:
            return;
    }
    // Atualiza painel de record
    if (instance.record && typeof instance.record.load === 'function') {
        instance.record.load();
    }
    // Atualiza painel de score
    document.getElementById('score').textContent = '0';
    // Liga botões
    document.getElementById('restart').onclick = () => instance.reset();
    document.getElementById('start').onclick = () => instance.start(gameName);
    document.getElementById('stop').onclick = () => instance.stop();
    // Liga dificuldade se existir
    const diffSelect = document.getElementById('pong-difficulty');
    if (diffSelect && gameName === 'pong') {
        diffSelect.onchange = (e) => {
            instance.setDifficulty(e.target.value);
        };
    }
    game = instance;
}


/// assets/js/pong.js ///
/**
   * PongGame class represents a simple Pong game implementation.
   * It handles the game state, rendering, and user controls.
   * The game can be started, stopped, and reset.
   * 
   * @class
   */
class PongGame {
  #paddle = { width: 12, height: 90 };
  #ball = { size: 16, x: 0, y: 0, speedX: 0, speedY: 0 };
  #player = { x: 20, y: 0 };
  #computer = { x: 0, y: 0 };

  #tileSize = 0; // Tile size, not used in this implementation
  #grid = { count: 20 }; // Grid count for the game, not used in this implementation
  #score = { player: 0, computer: 0 }; // Score tracking, not used in this implementation
  #alive = true; // Game state, not used in this implementation
  #lastFrameTime = 0; // Last frame time, not used in this implementation
  #ballSpeed = 6; // Ball speed, not used in this implementation
  #aiSpeed = 4; // AI speed, not used in this implementation
  
  #ctx;
  #canvas;
  #boundGameLoop;
  #boundHandleMouseMove;
  #boundHandleTouchMove;
  #animFrameId = null;

  #record = {
    save : () => {
      const currentRecord = localStorage.getItem(this.#recordKey) || '0';
      if (this.#score.player > parseInt(currentRecord, 10)) {
          localStorage.setItem(this.#recordKey, this.#score.player);
          this.#recordElement.textContent = this.#score.player;
      }
    },
    load : () => {
      const record = localStorage.getItem(this.#recordKey);
      this.#recordElement.textContent = record || '0';
    }
  }; // Record score, not used in this implementation
  #recordKey =  'pongRecord'; // Key for storing the record score in localStorage
  #recordElement = document.getElementById('record'); // Element to display the record score
  #restartButton = document.getElementById('restart'); // Button to restart the game

  constructor(){
    this.#restartButton.addEventListener('click', () => this.#init());
  }

  // Private method to initialize the game state
  #init() {
      this.#player.y = this.#canvas.height / 2 - this.#paddle.height / 2;
      this.#computer.y = this.#canvas.height / 2 - this.#paddle.height / 2;

      this.#player.x = 20; // Player paddle position
      this.#computer.x = this.#canvas.width - 20 - this.#paddle.width; // AI paddle position

      this.#ball.x = this.#canvas.width / 2 - this.#ball.size / 2; // Ball initial position
      this.#ball.y = this.#canvas.height / 2 - this.#ball.size / 2; // Ball initial position

      this.#ball.speedX = this.#ballSpeed * (Math.random() > 0.5 ? 1 : -1); // Random initial speed
      this.#ball.speedY = (this.#ballSpeed - 2) * (Math.random() * 2 - 1); // Random initial speed

      this.#ctx = this.#canvas.getContext('2d'); // Get canvas context
      this.#ctx.fillStyle = '#fff'; // Set default fill style
      this.#ctx.strokeStyle = '#fff'; // Set default stroke style
      this.#ctx.lineWidth = 2; // Set default line width

      this.#boundGameLoop = this.#gameLoop.bind(this); // Bind game loop
      this.#boundHandleMouseMove = this.#handleMouseMove.bind(this); // Bind mouse move handler
      this.#boundHandleTouchMove = this.#handleTouchMove.bind(this); // Bind touch move handler

      this.#canvas.addEventListener('mousemove', this.#boundHandleMouseMove); // Add mouse move event listener
      this.#canvas.addEventListener('touchmove', this.#boundHandleTouchMove); // Add touch move event listener
      this.#canvas.addEventListener('touchstart', (e) => e.preventDefault()); // Prevent default touch behavior
      this.#canvas.addEventListener('touchend', (e) => e.preventDefault()); // Prevent default touch behavior
      this.#canvas.addEventListener('touchcancel', (e) => e.preventDefault()); // Prevent default touch behavior

      this.#score = { player: 0, computer: 0 }; // Reset score
      this.#alive = true; // Game is alive
      this.#lastFrameTime = performance.now(); // Initialize frame time
      this.#tileSize = Math.floor(this.#canvas.height / this.#grid.count); // Responsive tile size
      
      this.#resetBall();
      this.#animFrameId = null; // Reset animation frame ID
  }

  // Private method to start the game loop
  // This method is called internally to start the game loop using requestAnimationFrame.
  // It ensures that the game loop is only running once at a time.
  /**
   * Starts the game loop using requestAnimationFrame.
   * This method is private and should not be called directly.
   */
  /*
   * @private
   */
  #startGameLoop() {
      if (this.#animFrameId) {
          cancelAnimationFrame(this.#animFrameId);
      }
      this.#animFrameId = requestAnimationFrame(this.#boundGameLoop);
  }

  // Private method to reset the ball position and speed
  /**
   * Resets the ball position and speed to the center of the canvas.
   * This method is private and should not be called directly.
   */
  /*
   * @private
   */
  #resetBall() {
      this.#ball.x = this.#canvas.width / 2 - this.#ball.size / 2;
      this.#ball.y = this.#canvas.height / 2 - this.#ball.size / 2;
      this.#ball.speedX = this.#ballSpeed * (Math.random() > 0.5 ? 1 : -1); // Use #ballSpeed
      this.#ball.speedY = (this.#ballSpeed - 2) * (Math.random() * 2 - 1);
  }

  // Private method to update the game state
  /**
   * Updates the game state, including player and AI paddle positions,
   * ball position and speed, and collision detection.
   * This method is private and should not be called directly.
   */
  /*
   * @private
   */
  #update() {
      if (!this.#alive) return; // Only update if game is alive
      // Frame delta for smoothness
      const now = performance.now();
      const delta = (now - this.#lastFrameTime) / 16.67; // Normalize to 60fps

      this.#lastFrameTime = now;

      this.#ball.x += this.#ball.speedX * delta;
      this.#ball.y += this.#ball.speedY * delta;

      if (this.#ball.y <= 0 || this.#ball.y + this.#ball.size >= this.#canvas.height) {
          this.#ball.speedY *= -1;
      }

      // Player collision
      if (
          this.#ball.x <= this.#player.x + this.#paddle.width &&
          this.#ball.y + this.#ball.size >= this.#player.y &&
          this.#ball.y <= this.#player.y + this.#paddle.height
      ) {
          this.#ball.x = this.#player.x + this.#paddle.width;
          this.#ball.speedX *= -1;
          const impact = ((this.#ball.y + this.#ball.size / 2) - (this.#player.y + this.#paddle.height / 2)) / (this.#paddle.height / 2);
          this.#ball.speedY += impact * 2;
      }

      // AI collision
      if (
          this.#ball.x + this.#ball.size >= this.#computer.x &&
          this.#ball.y + this.#ball.size >= this.#computer.y &&
          this.#ball.y <= this.#computer.y + this.#paddle.height
      ) {
          this.#ball.x = this.#computer.x - this.#ball.size;
          this.#ball.speedX *= -1;
          const impact = ((this.#ball.y + this.#ball.size / 2) - (this.#computer.y + this.#paddle.height / 2)) / (this.#paddle.height / 2);
          this.#ball.speedY += impact * 2;
      }

      // Score logic
      if (this.#ball.x < 0) {
          this.#score.computer++;
          this.#resetBall();
      } else if (this.#ball.x > this.#canvas.width) {
          this.#score.player++;
          this.#resetBall();
      }

      // AI movement
      const aiCenter = this.#computer.y + this.#paddle.height / 2;
      if (aiCenter < this.#ball.y + this.#ball.size / 2 - 10) {
          this.#computer.y += this.#aiSpeed * delta;
      } else if (aiCenter > this.#ball.y + this.#ball.size / 2 + 10) {
          this.#computer.y -= this.#aiSpeed * delta;
      }
      this.#computer.y = Math.max(0, Math.min(this.#canvas.height - this.#paddle.height, this.#computer.y));
  }

  // Private method to draw the game state on the canvas
  /**
   * Draws the current game state on the canvas, including paddles, ball, and center line.
   * This method is private and should not be called directly.
   */
  /*
   * @private
   */
  #draw() {
      this.#ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height);
      this.#drawRect(this.#player.x, this.#player.y, this.#paddle.width, this.#paddle.height);
      this.#drawRect(this.#computer.x, this.#computer.y, this.#paddle.width, this.#paddle.height);
      for (let i = 0; i < this.#canvas.height; i += 30) {
          this.#drawRect(this.#canvas.width / 2 - 2, i, 4, 20, '#888');
      }
      this.#drawBall(this.#ball.x, this.#ball.y, this.#ball.size);

      // Draw score
      this.#ctx.font = '32px Arial';
      this.#ctx.fillStyle = '#fff';
      this.#ctx.fillText(this.#score.player, this.#canvas.width / 2 - 60, 50);
      this.#ctx.fillText(this.#score.computer, this.#canvas.width / 2 + 40, 50);

      // Draw paused overlay
      if (!this.#alive) {
          this.#ctx.fillStyle = 'rgba(0,0,0,0.5)';
          this.#ctx.fillRect(0, 0, this.#canvas.width, this.#canvas.height);
          this.#ctx.fillStyle = '#fff';
          this.#ctx.font = '48px Arial';
          this.#ctx.fillText('Pausado', this.#canvas.width / 2 - 90, this.#canvas.height / 2);
      }
  }

  // Private method to run the game loop
  /**
   * The main game loop that updates the game state and draws it on the canvas.
   * This method is private and should not be called directly.
   */
  /*
   * @private
   */
  #gameLoop() {
      this.#update();
      this.#draw();
      this.#animFrameId = requestAnimationFrame(this.#boundGameLoop);
  }

  // Private methods to draw shapes on the canvas

  // Private method to draw a rectangle on the canvas
  /**
   * Draws a rectangle on the canvas.
   * This method is private and should not be called directly.
   * @param {number} x - The x-coordinate of the rectangle.
   * @param {number} y - The y-coordinate of the rectangle.
   * @param {number} w - The width of the rectangle.
   * @param {number} h - The height of the rectangle.
   * @param {string} color - The retangle background color. (default is white).
   * */
  /*
   * @private
   */
  #drawRect(x, y, w, h, color = '#000') {
      this.#ctx.fillStyle = color;
      this.#ctx.fillRect(x, y, w, h);
  }

  // Private method to draw a ball on the canvas
  /**
   * Draws a ball on the canvas.
   * This method is private and should not be called directly.
   * @param {number} x - The x-coordinate of the ball.
   * @param {number} y - The y-coordinate of the ball.
   * @param {number} size - The diameter of the ball.
   * @param {string} color - The ball color (default is white).
   */
  /*
   * @private
   */
  #drawBall(x, y, size, color = '#000') {
      this.#ctx.fillStyle = color;
      this.#ctx.beginPath();
      this.#ctx.arc(x + size / 2, y + size / 2, size / 2, 0, Math.PI * 2);
      this.#ctx.fill();
  }

  // Event handlers for mouse and touch controls

  // Mouse event handler for desktop devices
  /**
   * Handles mouse move events to update the player's paddle position.
   * This method is private and should not be called directly.
   * @param {MouseEvent} e - The mouse event object.
   */
  /*
   * @private
   */
  #handleMouseMove(e) {
      if (!this.#canvas) return; // Ensure canvas is initialized
      if (!this.#canvas.getBoundingClientRect) return; // Ensure getBoundingClientRect is available
      if (!this.#paddle) return; // Ensure paddle is initialized
      if (!this.#player) return; // Ensure player is initialized
      if (!this.#player.y) this.#player.y = 0; // Ensure player.y is initialized
      if (!this.#paddle.height) this.#paddle.height = 90; // Ensure paddle height is initialized
      if (!this.#canvas.height) this.#canvas.height = 600; // Ensure canvas height is initialized
      if (!this.#canvas.width) this.#canvas.width = 800; // Ensure canvas width is initialized
      if (!this.#ctx) this.#ctx = this.#canvas.getContext('2d'); // Ensure context is initialized
      if (!this.#ctx.fillStyle) this.#ctx.fillStyle = '#fff'; // Ensure fill style is initialized
      if (!this.#ctx.strokeStyle) this.#ctx.strokeStyle = '#fff'; // Ensure stroke style is initialized
      if (!this.#ctx.lineWidth) this.#ctx.lineWidth = 2; // Ensure line width is initialized
      if (!this.#ctx.arc) return; // Ensure arc method is available
      if (!this.#ctx.fillRect) return; // Ensure fillRect method is available
      if (!this.#ctx.fill) return; // Ensure fill method is available
      if (!this.#ctx.beginPath) return; // Ensure beginPath method is available
      if (!this.#ctx.clearRect) return; // Ensure clearRect method is available
      if (!this.#ctx.font) this.#ctx.font = '32px Arial'; // Ensure font is initialized
      if (!this.#ctx.fillText) return; // Ensure fillText method is available

      const rect = this.#canvas.getBoundingClientRect();
      const mouseY =  e.clientY - rect.top;

      this.#player.y = Math.max(
        this.#paddle.height, 
        Math.min(
          this.#canvas.height - this.#paddle.height, 
          mouseY - this.#paddle.height / 2
        )
      );

      // Verifica se o paddle do jogador está dentro dos limites do canvas
      if (this.#player.y < 0) {
          this.#player.y = 0; // Limita o paddle ao topo do canvas
      } else if (this.#player.y + this.#paddle.height > this.#canvas.height) {
          this.#player.y = this.#canvas.height - this.#paddle.height; // Limita o paddle à parte inferior do canvas
      } else {
          // Paddle está dentro dos limites do canvas
          this.#player.y = Math.max(0, Math.min(this.#canvas.height - this.#paddle.height, mouseY - this.#paddle.height / 2));
      }
  }

  // Touch event handler for mobile devices
  /**
   * Handles touch move events to update the player's paddle position.
   * This method is private and should not be called directly.
   * @param {TouchEvent} e - The touch event object.
   */
  /*
   * @private
   */
  #handleTouchMove(e) {
      e.preventDefault();
      // movePaddle Isso seria usado onde?
      if (e.touches.length === 0) return; // No touch points
      if (e.touches.length > 1) {
          // If there are multiple touches, ignore them
          return;
      }
      // Get the first touch point
      if (!this.#canvas) return; // Ensure canvas is initialized
      if (!this.#canvas.getBoundingClientRect) return; // Ensure getBoundingClientRect is available
      if (!this.#paddle) return; // Ensure paddle is initialized
      if (!this.#player) return; // Ensure player is initialized
      if (!this.#player.y) this.#player.y = 0; // Ensure player.y is initialized
      if (!this.#paddle.height) this.#paddle.height = 90; // Ensure paddle height is initialized
      if (!this.#canvas.height) this.#canvas.height = 600; // Ensure canvas height is initialized
      if (!this.#canvas.width) this.#canvas.width = 800; // Ensure canvas width is initialized
      if (!this.#ctx) this.#ctx = this.#canvas.getContext('2d'); // Ensure context is initialized
      if (!this.#ctx.fillStyle) this.#ctx.fillStyle = '#fff'; // Ensure fill style is initialized
      if (!this.#ctx.strokeStyle) this.#ctx.strokeStyle = '#fff'; // Ensure stroke style is initialized
      if (!this.#ctx.lineWidth) this.#ctx.lineWidth = 2; // Ensure line width is initialized
      if (!this.#ctx.arc) return; // Ensure arc method is available
      if (!this.#ctx.fillRect) return; // Ensure fillRect method is available
      if (!this.#ctx.fill) return; // Ensure fill method is available
      if (!this.#ctx.beginPath) return; // Ensure beginPath method is available
      if (!this.#ctx.clearRect) return; // Ensure clearRect method is available
      if (!this.#ctx.font) this.#ctx.font = '32px Arial'; // Ensure font is initialized
      if (!this.#ctx.fillText) return; // Ensure fillText method is available

      const rect = this.#canvas.getBoundingClientRect();
      const touchY = e.touches[0].clientY - rect.top;

      this.#player.y = Math.max(0, Math.min(this.#canvas.height - this.#paddle.height, touchY - this.#paddle.height / 2));
  }

  // Public method to start the game
  // This method initializes the game with a canvas and grid count,
  // and sets up the game loop and controls. Allows lazy initialization
  // of the game state, so it can be called multiple times without
  // needing to reset the game. If the game is already running, it will reset the game state.
  /**
   * Initializes the game with the specified canvas and grid count.
   * @param {string} canvasId - The ID of the canvas element to render the game.
   * @param {number} gridCount - The number of tiles in the grid (default is 20).
   */
  start(canvasId, gridCount = 20) {
    this.#canvas = document.getElementById(canvasId);
    if (!this.#canvas) {
        throw new Error(`Canvas with id ${canvasId} not found`);
    }
    this.#canvas.classList.add('active'); // Ensure the canvas is visible
    this.#ctx = this.#canvas.getContext("2d");
    this.#grid.count = gridCount;
    this.#boundGameLoop = this.#gameLoop.bind(this);
    this.#boundHandleMouseMove = this.#handleMouseMove.bind(this);
    this.#boundHandleTouchMove = this.#handleTouchMove.bind(this);
    this.#canvas.removeEventListener('mousemove', this.#boundHandleMouseMove);
    this.#canvas.removeEventListener('touchmove', this.#boundHandleTouchMove);
    this.#canvas.addEventListener('mousemove', this.#boundHandleMouseMove);
    this.#canvas.addEventListener('touchmove', this.#boundHandleTouchMove);
    this.reset();
    this.#alive = true; // Garante que o jogo está ativo
    if (this.#ctx && this.#canvas.width > 0 && this.#canvas.height > 0) {
      if (this.#animFrameId) {
        cancelAnimationFrame(this.#animFrameId);
      }
      this.#animFrameId = requestAnimationFrame(this.#boundGameLoop);
    }
  }

  // Public methods to control the game
  stop() {
      this.#alive = false;
      this.#canvas.removeEventListener('mousemove', this.#boundHandleMouseMove);
      this.#canvas.removeEventListener('touchmove', this.#boundHandleTouchMove);
      if (this.#animFrameId) {
          cancelAnimationFrame(this.#animFrameId);
          this.#animFrameId = null;
      }
  }

  // Public method to reset the game state
  // This method resets the game state, including the player and AI positions,
  // the ball position and speed, and the animation frame ID. It can be called
  // externally to reset the game without needing to restart it.
  /**
   * Resets the game state, including player and AI positions, ball position and speed.
   * This method can be called externally to reset the game without needing to restart it.
   */
  reset() {
      this.#init();
      this.#alive = true;
      if (this.#ctx && this.#canvas.width > 0 && this.#canvas.height > 0) {
        if (this.#animFrameId) {
          cancelAnimationFrame(this.#animFrameId);
        }
        this.#animFrameId = requestAnimationFrame(this.#boundGameLoop);
      }
  }

  // Public method to move the player's paddle
  /**
   * Moves the player's paddle by a specified distance.
   * This method can be called externally to move the paddle up or down.
   * @param {number} dy - The distance to move the paddle (positive for down, negative for up).
   */
  /*
   * @public
   */
  movePaddle(dy) {
    // Supondo que this.paddle1.y é a posição Y do paddle
    // this.paddleHeight é a altura do paddle
    // this.canvas.height é a altura total do canvas
    const newY = this.#player.y + dy;
    // Corrige para não ultrapassar os limites do canvas
    this.#player.y = Math.max(
        0,
        Math.min(this.#canvas.height - this.#paddle.height, newY)
    );
  }

  // Public method to get the current game state
  // This method returns the current state of the game, including the player,
  // AI, and ball positions and speeds. It can be called externally to get
  // the current game state without needing to access the private properties directly.
  /**
   * Gets the current game state, including player, AI, and ball positions and speeds.
   * @returns {Object} The current game state.
   */
  getState() {
      return {
          player: { ...this.#player },
          ai: { ...this.#computer },
          ball: { ...this.#ball }
      };
  }

  // Public method to check if the game is running
  // This method returns true if the game is currently running, and false otherwise.
  /**
   * Checks if the game is currently running.
   * @returns {boolean} True if the game is running, false otherwise.
   */
  isRunning() {
      return this.#animFrameId !== null;
  }

  // Public method to get the canvas element
  /**
   * Gets the canvas element used for rendering the game.
   * @returns {HTMLCanvasElement} The canvas element.
   */
  getCanvas() {
      return this.#canvas;
  }

  // Public method to get the canvas context
  /**
   * Gets the canvas context used for rendering the game.
   * @returns {CanvasRenderingContext2D} The canvas context.
   */
  getContext() {
      return this.#ctx;
  }

  // Public method to get the paddle dimensions
  /**
   * Gets the dimensions of the paddles used in the game.
   * @returns {Object} An object containing the width and height of the paddles.
   */
  getPaddleDimensions() {
      return { width: this.#paddle.width, height: this.#paddle.height };
  }

  // Public method to get the ball dimensions
  /**
   * Gets the dimensions of the ball used in the game.
   * @returns {Object} An object containing the size of the ball.
   */
  getBallDimensions() {
      return { size: this.#ball.size }; 
  }

  get recordKey() {
    return this.#recordKey;
  }

  record = {
    save: this.#record.save,
    load: this.#record.load
  };

  // Dificuldade: easy, medium, hard
  setDifficulty(level) {
    switch(level) {
      case 'easy':
        this.#ballSpeed = 4;
        this.#aiSpeed = 2.5;
        break;
      case 'hard':
        this.#ballSpeed = 8;
        this.#aiSpeed = 6;
        break;
      case 'medium':
      default:
        this.#ballSpeed = 6;
        this.#aiSpeed = 4;
        break;
    }
    // Reinicia o jogo com a nova dificuldade
    this.reset();
  }
}

/// assets/js/snake.js ///
class SnakeGame {
  #dirMap = {
    ArrowUp: { x: 0, y: -1 },
    ArrowDown: { x: 0, y: 1 },
    ArrowLeft: { x: -1, y: 0 },
    ArrowRight: { x: 1, y: 0 }
  }
  #canvas
  #ctx
  #grid
  #snake
  #apple
  #dir
  #nextDir
  #score = {
    player: 0,
    computer: 0
  };
  #recordElement = document.getElementById('record');
  #recordKey = 'snakeRecord';
  #record = {
    save : () => {
      const currentRecord = localStorage.getItem(this.#recordKey) || '0';
      if (this.#score.player > parseInt(currentRecord, 10)) {
        localStorage.setItem(this.#recordKey, this.#score.player);
        this.#recordElement.textContent = this.#score.player;
      }
    },
    load : () => {
      const record = localStorage.getItem(this.#recordKey);
      this.#recordElement.textContent = record || '0';
    }
  }; // Record score, not used in this implementation
  #alive
  #boundLoop
  #startX = 0
  #startY = 0
  #tileSize = 20
  #lastFrameTime = 0
  #animFrameId = null
  #removeControls = null
  #recordKey = 'snakeRecord'
  #speed = 120

  constructor(){}

  // Public method to start the game
  // This method initializes the game with a canvas and grid count,
  // and sets up the game loop and controls. Allows lazy initialization
  // of the game state, so it can be called multiple times without
  // needing to reset the game. If the game is already running, it will reset the game state.
  /**
   * Initializes the game with the specified canvas and grid count.
   * @param {string} canvasId - The ID of the canvas element to render the game.
   * @param {number} gridCount - The number of tiles in the grid (default is 20).
   */
  start(canvasId, gridCount = 20) {
    this.#canvas = document.getElementById(canvasId);
    if (!this.#canvas) {
      throw new Error(`Canvas with id ${canvasId} not found`);
    }
    this.#canvas.classList.add('active');
    this.#ctx = this.#canvas.getContext("2d");
    this.#grid = { count: gridCount };
    this.#tileSize = Math.floor(this.#canvas.width / gridCount);
    // Atualiza painel
    this.#score = 0;
    this.#record = parseInt(localStorage.getItem('snakeRecord') || '0', 10);
    document.getElementById('score').textContent = this.#score;
    document.getElementById('record').textContent = this.#record;
    // Remove listeners antigos
    this.#removeControls && this.#removeControls();
    // Initialize game state
    this.reset();
    // Bind the game loop
    this.#boundLoop = this.#loop.bind(this);
    // Setup controls
    this.#removeControls = this.#setupControls();
    // Start the game loop
    if (this.#alive) {
      if (this.#animFrameId) cancelAnimationFrame(this.#animFrameId);
      this.#animFrameId = requestAnimationFrame(this.#boundLoop);
    }
  }

  reset() {
    this.#snake = [{ x: 5, y: 5 }]
    this.#dir = { x: 1, y: 0 }
    this.#nextDir = { x: 1, y: 0 }
    this.#score = 0
    this.#alive = true
    this.#spawnApple()
    this.#draw()
    this.#lastFrameTime = 0
    requestAnimationFrame(this.#boundLoop)
  }

  // Public method to spawn an apple
  // This can be called externally to reset the apple position
  spawnApple() {
    if (!this.#alive) return
    if (this.#apple) {
      this.#apple = null
    }
    this.#spawnApple()
  }

  // Private method to handle apple spawning logic
  #spawnApple() {
    // Ensure apple is not already spawned
    if (this.#apple && this.#alive) {
      return
    }

    // Reset apple if the game is not alive
    if (!this.#apple) {
      this.#apple = { x: 0, y: 0 }
    }

    // Ensure apple does not spawn on the snake
    this.#apple = null
    if (!this.#alive) return
    if (!this.#apple) {
      this.#apple = { x: 0, y: 0 }
    }

    // Randomly place apple on the grid
    this.#apple = {
      x: Math.floor(Math.random() * this.#grid.count),
      y: Math.floor(Math.random() * this.#grid.count)
    }

    // Ensure apple does not spawn on the snake
    if (this.#snake.some(s => s.x === this.#apple.x && s.y === this.#apple.y)) {
      this.#spawnApple()
    }

    // Ensure apple is not placed outside the grid
    if (this.#apple.x < 0 || this.#apple.y < 0 || 
        this.#apple.x >= this.#grid.count || this.#apple.y >= this.#grid.count) {
      this.#spawnApple()
    }

    do {
      this.#apple = {
        x: Math.floor(Math.random() * (this.#grid.count - 1)),
        y: Math.floor(Math.random() * (this.#grid.count - 1))
      }
    } while (this.#snake.some(s => s.x === this.#apple.x && s.y === this.#apple.y))

    // Ensure apple is not placed outside the grid
    if (this.#apple.x < 0 || this.#apple.y < 0 || 
        this.#apple.x >= this.#grid.count || this.#apple.y >= this.#grid.count) {
      this.#spawnApple()
    }
    this.#ctx.fillStyle = "#f00"
    this.#ctx.fillRect(this.#apple.x * this.#tileSize, this.#apple.y * this.#tileSize, this.#tileSize, this.#tileSize)
  }

  #loop(time) {
    if (!this.#alive) return;
    if (!this.#speed) this.#speed = 120;
    if (time - this.#lastFrameTime >= this.#speed) {
      this.#lastFrameTime = time;
      this.#update();
      this.#draw();
    }
    this.#animFrameId = requestAnimationFrame(this.#boundLoop);
  }

  #update() {
    this.#dir = this.#nextDir
    const head = {
      x: this.#snake[0].x + this.#dir.x,
      y: this.#snake[0].y + this.#dir.y
    }

    // collision
    if (
      head.x < 0 || head.y < 0 ||
      head.x >= this.#grid.count || head.y >= this.#grid.count ||
      this.#snake.some(s => s.x === head.x && s.y === head.y)
    ) {
      this.#alive = false
      this.#ctx.fillStyle = "#f00"
      this.#ctx.font = "bold 30px sans-serif"
      this.#ctx.fillText("💀 GAME OVER", 60, this.#canvas.height / 2)
      return
    }

    this.#snake.unshift(head)

    if (head.x === this.#apple.x && head.y === this.#apple.y) {
      this.#score++
      document.getElementById("score").textContent = this.#score
      if (this.#score > this.#record) {
        this.#record = this.#score
        localStorage.setItem("snakeRecord", this.#record)
        document.getElementById("record").textContent = this.#record
      }
      new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg").play()
      this.#spawnApple()
    } else {
      this.#snake.pop()
    }
  }

  #draw() {
    this.#ctx.fillStyle = "#000"
    this.#ctx.fillRect(0, 0, this.#canvas.width, this.#canvas.height)

    this.#ctx.fillStyle = "#0f0"
    for (const s of this.#snake) {
      this.#ctx.fillRect(s.x * this.#tileSize, s.y * this.#tileSize, this.#tileSize, this.#tileSize)
    }

    this.#ctx.fillStyle = "#f00"
    this.#ctx.fillRect(this.#apple.x * this.#tileSize, this.#apple.y * this.#tileSize, this.#tileSize, this.#tileSize)
  }

  #arrowKeyHandler(e) {
    if (this.#alive && this.#dirMap[e.key]) {
      const newDir = this.#dirMap[e.key]
      // Prevent 180-degree turn
      if (newDir.x !== -this.#dir.x || newDir.y !== -this.#dir.y) {
        this.#nextDir = newDir
      }
    }
  }

  #touchHandler(e) {
    const touch = e.touches[0]
    const dx = touch.clientX - this.#canvas.offsetLeft
    const dy = touch.clientY - this.#canvas.offsetTop
    const gridX = Math.floor(dx / this.#tileSize)
    const gridY = Math.floor(dy / this.#tileSize)

    if (gridX < 0 || gridY < 0 || gridX >= this.#grid.count || gridY >= this.#grid.count) return

    // Determine direction based on touch position
    if (Math.abs(dx) > Math.abs(dy)) {
      this.#nextDir = dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 }
    } else {
      this.#nextDir = dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 }
    }
  }

  #touchStartHandler(e) {
    const touch = e.touches[0]
    this.#startX = touch.clientX
    this.#startY = touch.clientY
  }

  #setupControls() {
    const keyHandler = this.#arrowKeyHandler.bind(this);
    const touchStartHandler = e => {
      this.#startX = e.touches[0].clientX;
      this.#startY = e.touches[0].clientY;
    };
    const touchMoveHandler = e => {
      const dx = e.touches[0].clientX - this.#startX;
      const dy = e.touches[0].clientY - this.#startY;
      if (Math.abs(dx) > Math.abs(dy)) {
        this.#nextDir = dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 };
      } else {
        this.#nextDir = dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 };
      }
      this.#startX = this.#startY = 0;
    };
    window.addEventListener("keydown", keyHandler);
    window.addEventListener("touchstart", touchStartHandler);
    window.addEventListener("touchmove", touchMoveHandler);
    // Função para remover listeners
    return () => {
      window.removeEventListener("keydown", keyHandler);
      window.removeEventListener("touchstart", touchStartHandler);
      window.removeEventListener("touchmove", touchMoveHandler);
    };
  }

  stop() {
    this.#alive = false;
    if (this.#removeControls) this.#removeControls();
    if (this.#animFrameId) cancelAnimationFrame(this.#animFrameId);
  }
  start() {
    if (!this.#alive) {
      this.reset()
    }
  }
  getState() {
    return {
      snake: this.#snake,
      apple: this.#apple,
      score: this.#score,
      record: this.#record,
      alive: this.#alive
    }
  }
  setState(state) {
    this.#snake = state.snake
    this.#apple = state.apple
    this.#score = state.score
    this.#record = state.record
    this.#alive = state.alive
    document.getElementById("score").textContent = this.#score
    document.getElementById("record").textContent = this.#record
    this.#draw()
  }
  isRunning() {
    return this.#alive;
  }

  get recordKey() {
    return this.#recordKey;
  }
  
  record = {
    save: this.#record.save,
    load: this.#record.load
  };

  // Dificuldade: easy, medium, hard
  setDifficulty(level) {
    switch(level) {
      case 'easy':
        this.#speed = 180; // maior valor = mais lento
        break;
      case 'hard':
        this.#speed = 70; // menor valor = mais rápido
        break;
      case 'medium':
      default:
        this.#speed = 120;
        break;
    }
    // Reinicia o jogo com a nova dificuldade
    this.reset();
  }
}

/// assets/js/tic_tac_toe.js ///
class TicTacToe {
    #canvas;
    #ctx;
    #size;
    #cellSize;
    #board;
    #current;
    #winner;
    #boundHandleClick;
    #score = {
        player: 0,
        computer: 0
    };
    #recordElement = document.getElementById('record');
    #recordKey = 'tttRecord';
    #record = {
        save : () => {
        const currentRecord = localStorage.getItem(this.#recordKey) || '0';
        if (this.#score.player > parseInt(currentRecord, 10)) {
            localStorage.setItem(this.#recordKey, this.#score.player);
            this.#recordElement.textContent = this.#score.player;
        }
        },
        load : () => {
        const record = localStorage.getItem(this.#recordKey);
        this.#recordElement.textContent = record || '0';
        }
    }; // Record score, not used in this implementation

    constructor(canvas) {
        if (!(canvas instanceof HTMLCanvasElement)) {
            throw new Error('Canvas inválido ou não encontrado.');
        }
        this.#canvas = canvas;
        this.#ctx = canvas.getContext('2d');
        this.#size = Math.min(canvas.width, canvas.height);
        this.#cellSize = this.#size / 3;
        this.#boundHandleClick = this.#handleClick.bind(this);
        this.#canvas.addEventListener('click', this.#boundHandleClick);
        this.#init();
        // Atualiza painel
        this.#recordElement = document.getElementById('record');
        this.#score = { player: 0, computer: 0 };
        this.#updatePanel();
    }

    #init() {
        this.#board = Array.from({ length: 3 }, () => ['', '', '']);
        this.#current = 'X';
        this.#winner = null;
        this.#draw();
        this.#updatePanel();
    }

    #handleClick(e) {
        if (this.#winner) return;
        const rect = this.#canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const row = Math.floor(y / this.#cellSize);
        const col = Math.floor(x / this.#cellSize);
        if (this.#board[row][col] === '') {
            this.#board[row][col] = this.#current;
            if (this.#checkWinner()) {
                this.#winner = this.#current;
                if (this.#current === 'X') {
                    this.#score.player++;
                } else {
                    this.#score.computer++;
                }
                this.#record.save();
            } else if (this.#isDraw()) {
                this.#winner = 'draw';
            } else {
                this.#current = this.#current === 'X' ? 'O' : 'X';
            }
            this.#draw();
            this.#updatePanel();
        }
    }

    #checkWinner() {
        const b = this.#board;
        for (let i = 0; i < 3; i++) {
            if (b[i][0] && b[i][0] === b[i][1] && b[i][1] === b[i][2]) return true;
            if (b[0][i] && b[0][i] === b[1][i] && b[1][i] === b[2][i]) return true;
        }
        if (b[0][0] && b[0][0] === b[1][1] && b[1][1] === b[2][2]) return true;
        if (b[0][2] && b[0][2] === b[1][1] && b[1][1] === b[2][0]) return true;
        return false;
    }

    #isDraw() {
        return this.#board.flat().every(cell => cell !== '');
    }

    #draw() {
        this.#ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height);
        // Grade
        this.#ctx.strokeStyle = '#fff';
        this.#ctx.lineWidth = 4;
        for (let i = 1; i < 3; i++) {
            this.#ctx.beginPath();
            this.#ctx.moveTo(i * this.#cellSize, 0);
            this.#ctx.lineTo(i * this.#cellSize, this.#size);
            this.#ctx.stroke();
            this.#ctx.beginPath();
            this.#ctx.moveTo(0, i * this.#cellSize);
            this.#ctx.lineTo(this.#size, i * this.#cellSize);
            this.#ctx.stroke();
        }
        // X e O
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                const val = this.#board[r][c];
                if (val) {
                    this.#ctx.font = `${this.#cellSize * 0.7}px Arial`;
                    this.#ctx.textAlign = 'center';
                    this.#ctx.textBaseline = 'middle';
                    this.#ctx.fillStyle = val === 'X' ? '#0ff' : '#ff0';
                    this.#ctx.fillText(val, c * this.#cellSize + this.#cellSize / 2, r * this.#cellSize + this.#cellSize / 2);
                }
            }
        }
        // Mensagem de vitória
        if (this.#winner) {
            this.#ctx.fillStyle = '#0f0';
            this.#ctx.font = '28px Arial';
            this.#ctx.textAlign = 'center';
            const msg = this.#winner === 'draw' ? 'Empate!' : `Vencedor: ${this.#winner}`;
            this.#ctx.fillText(msg, this.#size / 2, this.#size - 20);
        }
    }

    #updatePanel() {
        document.getElementById('score').textContent = this.#score.player;
        this.#record.load();
    }

    start() {
        this.#init();
    }

    stop() {
        this.#canvas.removeEventListener('click', this.#boundHandleClick);
        this.#ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height);
    }

    isRunning() {
        return this.#winner === null;
    }

    reset() {
        this.#init();
        this.#updatePanel();
    }

    get recordKey() {
        return this.#recordKey;
    }

    record = {
        save: this.#record.save,
        load: this.#record.load
    };
}

/// docs/ORGANIZATION.txt ///
.
├── games.js
├── index.html
├── pong.js
├── snake.js
├── style.css
└── tic_tac_toe.js

/// index.html ///
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A collection of mini games built with HTML5 Canvas">
    <meta name="keywords" content="mini games, canvas, HTML5, JavaScript">
    <meta name="author" content="Rafael Mori">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <title>Mini Games Canvas</title>
    <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>
  <h1>Mini Games Canvas</h1>

  <div class="game-controls btns">
    <button data-game="pong" class="game-btn">Pong</button>
    <button data-game="snake" class="game-btn">Snake</button>
    <button data-game="tictactoe" class="game-btn">Tic-Tac-Toe</button>
  </div>

  <div class="main-layout">
    <div class="game-container">
      <canvas id="placeholder" class="game-canvas placeholder active"></canvas>
      <canvas id="pong" class="game-canvas"></canvas>
      <canvas id="snake" class="game-canvas"></canvas>
      <canvas id="tictactoe" class="game-canvas"></canvas>
    </div>

    <aside class="sidebar">
      <div class="game-controls">
        <div id="record">High Score: 0</div>
        <div id="score">Score: 0</div>
        <label for="pong-difficulty">Dificuldade:</label>
        <select id="pong-difficulty">
          <option value="easy">Fácil</option>
          <option value="medium" selected>Médio</option>
          <option value="hard">Difícil</option>
        </select>
        <button id="restart">Restart</button>
        <button id="stop">Stop</button>
        <button id="start">Start</button>
      </div>
      <div class="game-info">
        <p>Use the arrow keys to play.</p>
        <p>Press "R" to restart the game.</p>
        <p>Press "S" to stop the game.</p>
        <p>Press "Enter" to start the game.</p>
        <p>Press "Esc" to return to the menu.</p>
        <p>Press "M" to switch games.</p>
        <p>Press "F11" to enter/exit fullscreen mode.</p>
        <p>Press "F5" to reload the page.</p>
        <p>Press "H" to hide/show this menu.</p>
      </div>
    </aside>
  </div>

  <script src="assets/js/pong.js"></script>
  <script src="assets/js/snake.js"></script>
  <script src="assets/js/tic_tac_toe.js"></script>
  <script src="assets/js/games.js"></script>
</body>
</html>
