# LookAtni Code - Gerado automaticamente
# Data: 2025-07-13T23:15:53.194Z
# Fonte: /srv/apps/KUBEX/xtui/
# Total de arquivos: 50

/// CODE_OF_CONDUCT.md ///
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
<https://discord.gg/CCBJsFHT>.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
<https://www.contributor-covenant.org/version/2/0/code_of_conduct.html>.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
<https://www.contributor-covenant.org/faq>. Translations are available at
<https://www.contributor-covenant.org/translations>.

/// CONTRIBUTING.md ///
# **Contributing to XTui**

Thank you for your interest in contributing to **XTui**! We are excited to have you as part of our community. This guide will help you get started and contribute effectively to the project.

---

## **How to Contribute**

There are several ways to contribute to XTui:

1. **Report Issues**
    - Found bugs or issues in the code? Open an issue detailing the problem.
    - Include as much information as possible: steps to reproduce the problem, logs, Go version used, etc.

2. **Suggest Improvements**
    - Have an idea to improve the project? Share your suggestion by opening an issue with the `enhancement` tag.

3. **Submit Pull Requests**
    - Want to fix a bug or implement something new? Submit a pull request with your changes.

4. **Test and Review Code**
    - Help review pull requests from other contributors.
    - Run existing tests and validate if the proposed changes keep the system functional.

---

## **Getting Started**

### 1. **Clone the Repository**
```bash
git clone https://github.com/<your-username>/xtui.git
cd xtui
```

### 2. **Set Up the Environment**
Make sure you have Go installed:
- [Download Go](https://go.dev/dl/)

### 3. **Install Dependencies**
```bash
# Download the necessary packages
go mod download
```

### 4. **Run Tests**
Before making changes, run the existing tests:
```bash
go test ./...
```

---

## **Creating a Pull Request**

### **1. Fork the Repository**
Create a fork of the project to your own GitHub.

### **2. Create a New Branch**
```bash
git checkout -b your-feature
```

### **3. Make Changes**
Make sure to follow the project's code conventions and best practices.

### **4. Add Tests (if applicable)**
Include test cases to validate the added functionality.

### **5. Run Tests**
Ensure all changes and tests are working:
```bash
go test ./...
```

### **6. Commit and Push**
```bash
git add .
git commit -m "Brief description of the change"
git push origin your-feature
```

### **7. Open the Pull Request**
Go to the original repository on GitHub and open a pull request explaining your changes.

---

## **Code Standards**

### **Code Style**
This project follows Go's code conventions. Some recommendations:
- Use `gofmt` to format the code:
```bash
gofmt -w .
```

- Name variables and functions clearly and descriptively.
- Break long functions into smaller parts whenever possible.

### **Commits**
Commits should be clear and descriptive. Examples:
- `fix: fix bug in notification logic`
- `feat: add support for notifier via Slack`

---

## **Best Practices**

1. **Be Respectful and Welcoming**
   This is an open-source project for everyone. Respect other contributors and collaborate constructively.

2. **Document Your Changes**
   Update the `README.md` or documentation, if necessary, to include your changes.

3. **Add Tests When Possible**
   Ensure any new functionality is accompanied by tests.

4. **Be Clear in Issue Reports**
   When opening an issue, be detailed and provide as much context as possible.

---

## **Where to Get Help**

If you need assistance, feel free to:
- Open an issue with the `question` tag.
- Contact me via the email or LinkedIn listed in the `README.md`.

---

## **Our Commitment**

We commit to reviewing pull requests and issues as quickly as possible. We value your contribution and appreciate the time dedicated to the project!

/// NOTICE.md ///
# NOTICE

This software is licensed under the MIT License. Below are additional notes on usage and attribution:

## Attribution Requirement (Optional):
- When distributing or using this software, please provide credit to the original author(s) in one or more of the following ways:
    - Retain the copyright notice: `Copyright (c) 2025 Rafael Mori`.
    - Include a link to the original project repository or website.

## Acknowledgment:
This project was developed with the goal of enhancing usability and providing open access to its features.

For further information about the license and terms of use, please refer to the `LICENSE` file included with this project.

/// README.md ///
[//]: # (![XTui Banner]&#40;./assets/banner.png&#41;)

# XTui

---

**A high-performance, easy-to-use terminal user interface (TUI) library for Go, enabling developers to build interactive and visually appealing terminal applications with minimal effort.**

---

![Go Version](https://img.shields.io/github/go-mod/go-version/faelmori/xtui)
![License](https://img.shields.io/github/license/faelmori/xtui)
![Build Status](https://img.shields.io/github/actions/workflow/status/faelmori/xtui/build.yml)

## Table of Contents

- [Introduction](#introduction)
- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
- [CLI Examples](#cli-examples)
- [Module Examples](#module-examples)
- [Hotkeys](#hotkeys)
- [Form Handling](#form-handling)
- [Data Export](#data-export)
- [Command Navigation Functionalities](#command-navigation-functionalities)
- [Testing](#testing)
- [Contributing](#contributing)
- [License](#license)

## Introduction

**xtui** is a high-performance, easy-to-use terminal user interface (TUI) library for Go. It enables developers to build interactive and visually appealing terminal applications with minimal effort while maintaining flexibility and performance.

## Features

- **Intuitive API** – Simplifies the creation of rich terminal interfaces.
- **Customizable Styles** – Tailor UI components to your specific needs with custom styles and configurations.
- **Interactive Form Handling** – Manage form inputs with validation, password protection, and navigation.
- **Data Filtering, Sorting, and Navigation** – Built-in support for table operations.
- **Keyboard Shortcuts** – Provides an efficient user experience with predefined hotkeys.
- **Paginated Views** – Allows smooth navigation through large datasets.
- **Multi-format Export** – Export data to CSV, YAML, JSON, and XML formats.
- **Error Logging** – Integrated with the **logz** library for error tracking and debugging.

## Installation

To install **xtui**, run the following command:

```sh
go get github.com/kubex-ecosystem/xtui
```

## Usage

Here’s a quick example demonstrating how to use **xtui** for displaying tables:

```go
package main

import (
	"github.com/kubex-ecosystem/xtui"
	"github.com/kubex-ecosystem/xtui/types"
    "github.com/charmbracelet/lipgloss"
)

func main() {
    config := types.FormConfig{
        Fields: []types.Field{
            {Name: "ID", Placeholder: "Unique ID"},
            {Name: "Name", Placeholder: "User Name"},
        },
    }

    customStyles := map[string]lipgloss.Color{
        "Info":    lipgloss.Color("#75FBAB"),
        "Warning": lipgloss.Color("#FDFF90"),
    }

    if err := xtui.StartTableScreen(config, customStyles); err != nil {
        panic(err)
    }
}
```

For form-based interactions:

```go
package main

import (
	"github.com/kubex-ecosystem/xtui"
	"github.com/kubex-ecosystem/xtui/types"
)

func main() {
    config := types.Config{
        Title: "User Registration",
        Fields: types.FormFields{
            Inputs: []types.InputField{
                {Ph: "Name", Tp: "text", Req: true, Err: "Name is required!"},
                {Ph: "Password", Tp: "password", Req: true, Err: "Password is required!"},
            },
        },
    }

    result, err := xtui.ShowForm(config)
    if err != nil {
        panic(err)
    }
    println("Form submitted:", result)
}
```

### Command Navigation Functionalities

The `xtui` module provides several command navigation functionalities to enhance the user experience. These functionalities include `NavigateAndExecuteCommand`, `NavigateAndExecuteFormCommand`, and `NavigateAndExecuteViewCommand`.

#### NavigateAndExecuteCommand

The `NavigateAndExecuteCommand` function handles command navigation and execution. It detects commands and their flags, displays command selection and flag definition in a form, sets flag values based on form input, and executes the command.

Example:

```go
package main

import (
	"github.com/kubex-ecosystem/xtui/cmd/cli"
    "github.com/spf13/cobra"
)

func main() {
    cmd := &cobra.Command{
        Use: "example-command",
        RunE: func(cmd *cobra.Command, args []string) error {
            return cli.NavigateAndExecuteCommand(cmd, args)
        },
    }

    if err := cmd.Execute(); err != nil {
        panic(err)
    }
}
```

#### NavigateAndExecuteFormCommand

The `NavigateAndExecuteFormCommand` function handles form-based navigation and execution. It detects commands and their flags, displays command selection and flag definition in a form, sets flag values based on form input, and executes the command.

Example:

```go
package main

import (
	"github.com/kubex-ecosystem/xtui/cmd/cli"
    "github.com/spf13/cobra"
)

func main() {
    cmd := &cobra.Command{
        Use: "example-form-command",
        RunE: func(cmd *cobra.Command, args []string) error {
            return cli.NavigateAndExecuteFormCommand(cmd, args)
        },
    }

    if err := cmd.Execute(); err != nil {
        panic(err)
    }
}
```

#### NavigateAndExecuteViewCommand

The `NavigateAndExecuteViewCommand` function handles table-based navigation and execution. It detects commands and their flags, displays command selection and flag definition in a table view, sets flag values based on table input, and executes the command.

Example:

```go
package main

import (
	"github.com/kubex-ecosystem/xtui/cmd/cli"
    "github.com/spf13/cobra"
)

func main() {
    cmd := &cobra.Command{
        Use: "example-view-command",
        RunE: func(cmd *cobra.Command, args []string) error {
            return cli.NavigateAndExecuteViewCommand(cmd, args)
        },
    }

    if err := cmd.Execute(); err != nil {
        panic(err)
    }
}
```

## CLI Examples

### Install Applications Command

```sh
go run main.go app-install --application app1 --application app2 --path /usr/local/bin --yes --quiet
```

### Table View Command

```sh
go run main.go table-view
```

### Input Form Command

```sh
go run main.go input-form
```

### Loader Form Command

```sh
go run main.go loader-form
```

## Module Examples

### Log Viewer

```go
package main

import (
	"github.com/kubex-ecosystem/xtui/wrappers"
)

func main() {
    if err := wrappers.LogViewer(); err != nil {
        panic(err)
    }
}
```

### Application Manager

```go
package main

import (
	"github.com/kubex-ecosystem/xtui/wrappers"
)

func main() {
    args := []string{"app1", "app2", "/usr/local/bin", "true", "true"}
    if err := wrappers.InstallDependenciesWithUI(args...); err != nil {
        panic(err)
    }
}
```

## Hotkeys

The following keyboard shortcuts are supported out of the box:

- **q, Ctrl+C:** Exit the application.
- **Enter:** Copy selected row or submit form.
- **Ctrl+R:** Change cursor mode.
- **Tab/Shift+Tab, Up/Down Arrows:** Navigate between form fields or table rows.
- **Ctrl+E:** Export data to CSV.
- **Ctrl+Y:** Export data to YAML.
- **Ctrl+J:** Export data to JSON.
- **Ctrl+X:** Export data to XML.

## Form Handling

**xtui** provides an intuitive API for managing forms with validations:
- **Field Validation:** Enforce required fields, minimum/maximum length, and custom validators.
- **Password Input:** Securely handle password fields with hidden characters.
- **Dynamic Properties:** Automatically adapt form inputs based on external configurations.

### Example

```go
field := types.InputField{
    Ph:  "Email",
    Tp:  "text",
    Req: true,
    Err: "Valid email is required!",
    Vld: func(value string) error {
        if !strings.Contains(value, "@") {
            return fmt.Errorf("Invalid email format")
        }
        return nil
    },
}
```

## Data Export

**xtui** supports exporting table data in multiple formats:
- **CSV:** Saves data as a comma-separated values file.
- **YAML:** Outputs data in a structured YAML format.
- **JSON:** Encodes data into a compact JSON format.
- **XML:** Exports data as XML for interoperability.

### Example

To export data to a file, simply use the respective hotkey (e.g., `Ctrl+E` for CSV). Files will be saved with predefined names, such as `exported_data.csv`.

## Testing

To test the new navigation functionalities in the `xtui` module, you can follow these steps:

* Run the unit tests provided in the repository. For example, you can run the tests in `cmd/cli/form_commands.go` and `cmd/cli/views_commands.go` using the `go test` command.
* Use the `NavigateAndExecuteCommand` function in `cmd/cli/app_commands.go` to test command navigation and execution. You can create a new command and call this function with the command and arguments.
* Test the form-based navigation by running the `input-form` command defined in `cmd/cli/form_commands.go`. This command uses the `NavigateAndExecuteFormCommand` function to handle form inputs and execute the command.
* Test the table-based navigation by running the `table-view` command defined in `cmd/cli/views_commands.go`. This command uses the `NavigateAndExecuteViewCommand` function to handle table views and execute the command.
* Test the loader-based navigation by running the `loader-form` command defined in `cmd/cli/form_commands.go`. This command uses the `wrappers.StartLoader` function to display a loader screen and execute the command.

## Contributing

We welcome contributions of all kinds! Whether it’s reporting issues, improving documentation, or submitting new features, your help is appreciated. Please check out our [contributing guidelines](CONTRIBUTING.md) for more details.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for more details.

/// cmd/cli/app_commands.go ///
package cli

import (
	"fmt"
	"strings"

	. "github.com/kubex-ecosystem/xtui/components"
	gl "github.com/kubex-ecosystem/xtui/logger"
	. "github.com/kubex-ecosystem/xtui/wrappers"
	"github.com/spf13/cobra"
)

func AppsCmdsList() []*cobra.Command {
	return []*cobra.Command{
		InstallApplicationsCommand(),
	}
}

func InstallApplicationsCommand() *cobra.Command {
	var depList []string
	var path string
	var yes, quiet bool

	cmd := &cobra.Command{
		Use:     "install",
		Aliases: []string{"i", "ins", "add"},
		Annotations: GetDescriptions(
			[]string{
				"Install applications and dependencies",
				"Install applications from a file or a repository and add, them to the system"},
			false,
		),
		RunE: func(cmd *cobra.Command, args []string) error {
			if len(depList) == 0 && len(args) == 0 {
				gl.Log("error", "Empty applications list: no applications to install")
				return fmt.Errorf("no applications to install")

			}
			newArgs := []string{strings.Join(depList, " "), path, fmt.Sprintf("%t", yes), fmt.Sprintf("%t", quiet)}
			args = append(args, newArgs...)

			availableProperties := getAvailableProperties()
			if len(availableProperties) > 0 {
				adaptedArgs := adaptArgsToProperties(args, availableProperties)
				return InstallDependenciesWithUI(adaptedArgs...)
			}

			// Notification: Starting installation
			DisplayNotification("Starting installation of applications", "info")

			err := InstallDependenciesWithUI(args...)

			if err != nil {
				// Notification: Error during installation
				DisplayNotification(fmt.Sprintf("Error during installation: %s", err.Error()), "error")
				return err
			}

			// Notification: Successful installation
			DisplayNotification("Applications installed successfully", "info")

			return nil
		},
	}

	cmd.Flags().StringArrayVarP(&depList, "application", "a", []string{}, "Applications list to install")
	cmd.Flags().StringVarP(&path, "path", "p", "", "Apps installation path")
	cmd.Flags().BoolVarP(&yes, "yes", "y", false, "Automatic yes to prompts")
	cmd.Flags().BoolVarP(&quiet, "quiet", "q", false, "Quiet mode")

	return cmd
}

func NavigateAndExecuteCommand(cmd *cobra.Command, args []string) error {
	// Detect command and its flags
	commandName := cmd.Name()
	flags := cmd.Flags()

	// Display command selection and flag definition in a form
	formConfig := createFormConfig(commandName, flags)
	formResult, err := ShowFormWithNotification(formConfig)
	if err != nil {
		return err
	}

	// Set flag values based on form input
	for key, value := range formResult {
		if err := cmd.Flags().Set(key, value); err != nil {
			return err
		}
	}

	// Execute the command
	return cmd.Execute()
}

/// cmd/cli/common.go ///
package cli

import (
	"fmt"
	"math/rand"
	"os"
	"reflect"
	"strings"

	t "github.com/kubex-ecosystem/xtui/types"
	"github.com/spf13/pflag"
)

var (
	banners = []string{`
 __    __ ________          ______
|  \  |  \        \        |      \
| ▓▓  | ▓▓\▓▓▓▓▓▓▓▓__    __ \▓▓▓▓▓▓
 \▓▓\/  ▓▓  | ▓▓  |  \  |  \ | ▓▓
  >▓▓  ▓▓   | ▓▓  | ▓▓  | ▓▓ | ▓▓
 /  ▓▓▓▓\   | ▓▓  | ▓▓  | ▓▓ | ▓▓
|  ▓▓ \▓▓\  | ▓▓  | ▓▓__/ ▓▓_| ▓▓_
| ▓▓  | ▓▓  | ▓▓   \▓▓    ▓▓   ▓▓ \
 \▓▓   \▓▓   \▓▓    \▓▓▓▓▓▓ \▓▓▓▓▓▓`}
)

func GetDescriptions(descriptionArg []string, _ bool) map[string]string {
	var description, banner string
	if descriptionArg != nil {
		if strings.Contains(strings.Join(os.Args[0:], ""), "-h") {
			description = descriptionArg[0]
		} else {
			description = descriptionArg[1]
		}
	} else {
		description = ""
	}
	bannerRandLen := len(banners)
	bannerRandIndex := rand.Intn(bannerRandLen)
	banner = banners[bannerRandIndex]
	return map[string]string{"banner": banner, "description": description}
}

func getAvailableProperties() map[string]string {
	return map[string]string{
		"property1": "value1",
		"property2": "value2",
	}
}

func adaptArgsToProperties(args []string, properties map[string]string) []string {
	adaptedArgs := args
	for key, value := range properties {
		adaptedArgs = append(adaptedArgs, fmt.Sprintf("--%s=%s", key, value))
	}
	return adaptedArgs
}

func createFormConfig(commandName string, flags *pflag.FlagSet) t.FormConfig {
	var formFields []t.FormInputObject[any]

	flags.VisitAll(func(flag *pflag.Flag) {
		val := reflect.ValueOf(flag.Value).Interface()
		formFields = append(formFields, &t.Input[any]{
			Ph:                 flag.Name,
			Tp:                 reflect.TypeOf(flag.Value),
			Val:                &val,
			Req:                false,
			Min:                0,
			Max:                100,
			Err:                "",
			ValidationRulesVal: nil,
		})
	})

	return t.FormConfig{
		Title: fmt.Sprintf("Configure %s Command", commandName),
		FormFields: t.FormFields{
			Title:  fmt.Sprintf("Configure %s Command", commandName),
			Fields: formFields,
		},
	}
}

/// cmd/cli/form_commands.go ///
package cli

import (
	"testing"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/kubex-ecosystem/xtui/components"
	"github.com/kubex-ecosystem/xtui/wrappers"
	"github.com/spf13/cobra"
)

func FormsCmdsList() []*cobra.Command {
	inputCmd := InputFormCommand()
	loaderCmd := LoaderFormCommand()

	return []*cobra.Command{
		inputCmd,
		loaderCmd,
	}
}

func InputFormCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "input-form",
		Aliases: []string{"input", "formInput", "inputForm", "formInput", "form-input"},
		Short:   "Form inputs for any command",
		Long:    "Form inputs screen, interactive mode, for any command with flags",
		RunE: func(cmd *cobra.Command, args []string) error {
			return NavigateAndExecuteFormCommand(cmd, args)
		},
	}

	return cmd
}

func LoaderFormCommand() *cobra.Command {
	// Configuration file path. This file can be used to load dynamic properties.
	var configFile string
	// Loader settings and properties map. This map can be used to load dynamic properties.
	// Example: {"Loading dynamic properties...": 2, "Dynamic properties loaded successfully.": 1, "Closing loader...": 1}
	var sequenceWithDelay map[string]int
	// Loader icon sequence map. This map can be used to load dynamic properties
	// with sequenceWithDelay to set icons for each message in the loader.
	var sequenceWithIcon map[string]string
	// Loader color sequence map. This map can be used to load dynamic properties with other sequencies
	// to set colors for each message in the loader.
	var sequenceWithColor map[string]string

	cmd := &cobra.Command{
		Use:     "loader-form",
		Aliases: []string{"loader", "formLoader", "loaderForm", "formLoader", "form-loader"},
		Short:   "Form loader for any command",
		Long:    "Form loader screen, interactive mode, for any command with flags",
		RunE: func(cmd *cobra.Command, args []string) error {

			messages := make(chan tea.Msg)
			go func() {
				messages <- wrappers.LoaderMsg{Message: "Loading dynamic properties..."}
				time.Sleep(2 * time.Second)
				messages <- wrappers.LoaderMsg{Message: "Dynamic properties loaded successfully."}
				time.Sleep(1 * time.Second)
				messages <- wrappers.LoaderCloseMsg{}
			}()
			return wrappers.StartLoader(messages)
		},
	}

	cmd.Flags().StringToIntVarP(&sequenceWithDelay, "loader-delay", "l", nil, "Loader messages and delays")
	cmd.Flags().StringToStringVarP(&sequenceWithIcon, "loader-icon", "i", nil, "Loader messages and icons")
	cmd.Flags().StringToStringVarP(&sequenceWithColor, "loader-color", "r", nil, "Loader messages and colors")
	cmd.Flags().StringVarP(&configFile, "loader-config", "L", "", "Loader configuration file for dynamic properties and settings")

	return cmd
}

// Unit tests for InputFormCommand
func TestInputFormCommand(t *testing.T) {
	cmd := InputFormCommand()
	if cmd.Use != "input-form" {
		t.Errorf("expected 'input-form', got '%s'", cmd.Use)
	}
	if cmd.Short != "Form inputs for any command" {
		t.Errorf("expected 'Form inputs for any command', got '%s'", cmd.Short)
	}
	if cmd.Long != "Form inputs screen, interactive mode, for any command with flags" {
		t.Errorf("expected 'Form inputs screen, interactive mode, for any command with flags', got '%s'", cmd.Long)
	}
}

// Unit tests for LoaderFormCommand
func TestLoaderFormCommand(t *testing.T) {
	cmd := LoaderFormCommand()
	if cmd.Use != "loader-form" {
		t.Errorf("expected 'loader-form', got '%s'", cmd.Use)
	}
	if cmd.Short != "Form loader for any command" {
		t.Errorf("expected 'Form loader for any command', got '%s'", cmd.Short)
	}
	if cmd.Long != "Form loader screen, interactive mode, for any command with flags" {
		t.Errorf("expected 'Form loader screen, interactive mode, for any command with flags', got '%s'", cmd.Long)
	}
}

func NavigateAndExecuteFormCommand(cmd *cobra.Command, args []string) error {
	// Detect command and its flags
	commandName := cmd.Name()
	flags := cmd.Flags()

	// Display command selection and flag definition in a form
	formConfig := createFormConfig(commandName, flags)
	formResult, err := components.ShowFormWithNotification(formConfig)
	if err != nil {
		return err
	}

	// Set flag values based on form input
	for key, value := range formResult {
		if err := cmd.Flags().Set(key, value); err != nil {
			return err
		}
	}

	// Execute the command
	return cmd.Execute()
}

/// cmd/cli/pkg_commands.go ///
package cli

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"time"

	gl "github.com/kubex-ecosystem/xtui/logger"
	p "github.com/kubex-ecosystem/xtui/packages"
	"github.com/spf13/cobra"
)

// appsCmdsList retorna uma lista de comandos Cobra relacionados a aplicativos.
// Retorna um slice de ponteiros para comandos Cobra e um erro, se houver.
func PkgCmdsList() []*cobra.Command {
	return []*cobra.Command{
		appsCmdAdd(),
		appsCmdList(),
		checkDepsCmd(),
		appsCmdAddShell(),
		appsCmdGenInstScript(),
	}
}

// appsCmdAdd cria um comando Cobra para instalar um aplicativo.
// Retorna um ponteiro para o comando Cobra configurado.
func appsCmdAdd() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "install",
		Aliases: []string{"i", "ins", "add"},
		Annotations: GetDescriptions(
			[]string{
				"Install an application",
				"Install an application from a file or a repository and add it to the system",
			},
			false,
		),
		RunE: func(cmd *cobra.Command, args []string) error {
			nameFlagValue, _ := cmd.Flags().GetStringArray("name")
			pathFlagValue, _ := cmd.Flags().GetString("path")
			yesFlagValue, _ := cmd.Flags().GetBool("yes")
			quietFlagValue, _ := cmd.Flags().GetBool("quiet")
			newArgs := []string{strings.Join(nameFlagValue, " "), pathFlagValue, fmt.Sprintf("%t", yesFlagValue), fmt.Sprintf("%t", quietFlagValue)}
			args = append(args, newArgs...)

			availableProperties := getAvailableProperties()
			if len(availableProperties) > 0 {
				adaptedArgs := adaptArgsToProperties(args, availableProperties)
				return p.InstallApps(adaptedArgs...)
			}

			return p.InstallApps(args...)
		},
	}

	cmd.Flags().StringArrayP("name", "n", []string{}, "App name")
	cmd.Flags().StringP("path", "p", "", "App path")
	cmd.Flags().BoolP("yes", "y", false, "Automatic yes to prompts")
	cmd.Flags().BoolP("quiet", "q", false, "Quiet mode")

	return cmd
}

// appsCmdGenInstScript cria um comando Cobra para gerar um script de dependências.
// Retorna um ponteiro para o comando Cobra configurado.
func appsCmdGenInstScript() *cobra.Command {
	genInstScriptCmd := &cobra.Command{
		Use:    "genDepsScript",
		Hidden: true,
		Annotations: GetDescriptions(
			[]string{
				"Gera script de dependências",
				"Gera um script para verificar e instalar dependências",
			},
			false,
		),
		RunE: func(cmd *cobra.Command, args []string) error {
			depsList, depsListErr := getDepsList()
			if depsListErr != nil {
				gl.Log("error", "Error getting dependencies list: "+depsListErr.Error())
				return depsListErr
			}
			return GenDepsScriptHandler(depsList, args...)
		},
	}

	return genInstScriptCmd
}

// appsCmdAddShell cria um comando Cobra para instalar dependências.
// Retorna um ponteiro para o comando Cobra configurado.
func appsCmdAddShell() *cobra.Command {
	addAppsShell := &cobra.Command{
		Use: "ins-deps",
		Annotations: GetDescriptions(
			[]string{
				"Install dependencies",
				"Install all dependencies provided on the system",
			},
			false,
		),
		RunE: func(cmd *cobra.Command, args []string) error {
			return InstallDepsHandler(args...)
		},
	}

	return addAppsShell
}

// appsCmdList cria um comando Cobra para listar aplicativos.
// Retorna um ponteiro para o comando Cobra configurado.
func appsCmdList() *cobra.Command {
	var name, status, method string

	cmd := &cobra.Command{
		Use: "list",
		Annotations: GetDescriptions(
			[]string{
				"List system installed apps",
				"List all installed apps on the system in a interactive table with filters, export options and more",
			},
			false,
		),
		Run: func(cmd *cobra.Command, args []string) {
			startTime := time.Now()
			if err := p.ShowInstalledAppsTable(name, status, method); err != nil {
				gl.Log("error", "Error listing installed apps: "+err.Error())
			} else {
				gl.Log("success", "Apps listed successfully")
				if os.Getenv("XTUI_QUIET") == "" || os.Getenv("NON_INTERACTIVE") == "" {
					timeSpent := time.Since(startTime).Seconds()
					fmt.Println(fmt.Sprintf("----------------------------------------------------------%s", "\n"))
					gl.Log("success", "Everything was fine and work as expected!")
					gl.Log("success", fmt.Sprintf("You spent %.2f seconds on running the XTuI module", timeSpent))
					gl.Log("success", "Hope you have enjoyed it! See you soon!!!\n")
					fmt.Println("----------------------------------------------------------")
				}
			}
		},
	}

	cmd.Flags().StringArrayP("name", "n", []string{}, "App name")
	cmd.Flags().StringP("status", "s", "", "App status")
	cmd.Flags().StringP("method", "m", "", "App method")

	return cmd
}

// checkDepsCmd cria um comando Cobra para verificar dependências.
// Retorna um ponteiro para o comando Cobra configurado.
func checkDepsCmd() *cobra.Command {
	depsCmd := &cobra.Command{
		Use: "checkDeps",
		Annotations: GetDescriptions(
			[]string{
				"Ensure dependencies",
				"Ensure that all dependencies are installed",
			},
			false,
		),
		RunE: func(cmd *cobra.Command, args []string) error {
			return CheckDepsHandler(args...)
		},
	}

	return depsCmd
}

func getDepsList() ([]string, error) {
	if len(os.Args) == 0 {
		return nil, fmt.Errorf("nenhuma dependência informada")
	}
	for i, dep := range os.Args {
		// Verifica se é um slice de strings
		if reflect.TypeOf(dep).String() == "[]string" {
			return os.Args[i+1:], nil
		}
	}
	return nil, fmt.Errorf("nenhuma dependência informada")
}

// CheckDepsHandler verifica as dependências a partir dos argumentos fornecidos.
// Recebe um slice de strings com os argumentos.
// Retorna um erro, se houver.
func CheckDepsHandler(args ...string) error {
	var validationFilePath, version string
	if len(args) == 0 {
		return fmt.Errorf("caminho do arquivo de validação não informado")
	}
	validationFilePath = args[0]
	if len(args) > 1 {
		version = args[1]
	} else {
		version = "latest"
	}
	p.CheckDeps(validationFilePath, version)
	return nil
}

// GenDepsScriptHandler gera um script para verificar e instalar dependências a partir dos argumentos fornecidos.
// Recebe um slice de strings com a lista de dependências e um slice de strings com os argumentos.
// Retorna um erro, se houver.
func GenDepsScriptHandler(depsList []string, args ...string) error {
	var scriptPath, validationFilePath, version string
	if len(args) < 4 {
		return fmt.Errorf("erro ao ler argumentos")
	}
	scriptPath = args[len(args)-3]
	validationFilePath = args[len(args)-2]
	version = args[len(args)-1]
	return p.GenDepsScript(depsList, scriptPath, validationFilePath, version)
}

// InstallDepsHandler instala dependências a partir dos argumentos fornecidos.
// Recebe um slice de strings com os argumentos.
// Retorna um erro, se houver.
func InstallDepsHandler(args ...string) error {
	var scriptPath string
	if len(args) == 0 {
		return fmt.Errorf("caminho do script de instalação não informado")
	}
	scriptPath = args[0]
	return p.InstallApps(scriptPath)
}

/// cmd/cli/views_commands.go ///
package cli

import (
	"bytes"
	"encoding/csv"
	"encoding/xml"
	"fmt"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/charmbracelet/lipgloss"
	c "github.com/kubex-ecosystem/xtui/components"
	gl "github.com/kubex-ecosystem/xtui/logger"
	t "github.com/kubex-ecosystem/xtui/types"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"gopkg.in/yaml.v3"
)

func ViewsCmdsList() []*cobra.Command {
	tableCmd := tableViewCmd()

	return []*cobra.Command{
		tableCmd,
	}
}

func tableViewCmd() *cobra.Command {
	var jsonFile, xmlFile, yamlFile, csvFile string
	var delimiter, quote, comment string

	cmd := &cobra.Command{
		Use:     "table",
		Aliases: []string{"tb", "t"},
		Annotations: GetDescriptions(
			[]string{
				"Table view for any command",
				"Table view screen, interactive mode, for any command with flags",
			},
			false,
		),
		RunE: func(cmd *cobra.Command, args []string) error {
			var inputData [][]string
			var inputDataErr error

			// Check if input is from a pipe
			stat, _ := os.Stdin.Stat()
			if (stat.Mode() & os.ModeCharDevice) == 0 {
				pipeInput, err := io.ReadAll(os.Stdin)
				if err != nil {
					return err
				}
				inputData, inputDataErr = parseCSV(pipeInput, delimiter, quote, comment)
				if inputDataErr != nil {
					return inputDataErr
				}
			} else {
				// Process file inputs
				if csvFile != "" {
					data, err := os.ReadFile(csvFile)
					if err != nil {
						return err
					}
					inputData, inputDataErr = parseCSV(data, delimiter, quote, comment)
					if inputDataErr != nil {
						return inputDataErr
					}
				} else if jsonFile != "" {
					data, err := os.ReadFile(jsonFile)
					if err != nil {
						return err
					}
					mapper := t.NewMapperTypeWithObject[[][]string](&inputData, "/tmp")
					resB, err := mapper.Deserialize(data, "json")
					if err != nil {
						return err
					}
					inputData = resB
				} else if xmlFile != "" {
					data, err := os.ReadFile(xmlFile)
					if err != nil {
						return err
					}
					inputData, inputDataErr = parseXML(data)
					if inputDataErr != nil {
						return inputDataErr
					}
				} else if yamlFile != "" {
					data, err := os.ReadFile(yamlFile)
					if err != nil {
						return err
					}
					inputData, inputDataErr = parseYAML(data)
					if inputDataErr != nil {
						return inputDataErr
					}
				} else if len(args) > 0 {
					inputData, inputDataErr = parseArgs(args)
					if inputDataErr != nil {
						return inputDataErr
					}
				}
			}

			customStyles := map[string]lipgloss.Color{
				"Info":    lipgloss.Color("#75FBAB"),
				"Warning": lipgloss.Color("#FDFF90"),
				"Error":   lipgloss.Color("#FF7698"),
				"Debug":   lipgloss.Color("#929292"),
			}

			headers := inputData[0]
			rows := inputData[1:]

			tbC := c.NewTableRenderer(&t.TableHandler{Headers: headers, Rows: rows}, customStyles, nil)

			return c.StartTableScreenFromRenderer(tbC)
		},
	}

	cmd.Flags().StringVarP(&jsonFile, "json", "j", "", "Input JSON file")
	cmd.Flags().StringVarP(&xmlFile, "xml", "x", "", "Input XML file")
	cmd.Flags().StringVarP(&yamlFile, "yaml", "y", "", "Input YAML file")
	cmd.Flags().StringVarP(&csvFile, "csv", "c", "", "Input CSV file")
	cmd.Flags().StringVarP(&delimiter, "delimiter", "d", ",", "CSV delimiter")
	cmd.Flags().StringVarP(&quote, "quote", "q", "\"", "CSV quote")
	cmd.Flags().StringVarP(&comment, "comment", "m", "#", "CSV comment")

	return cmd
}

func parseCSV(data []byte, delimiter, quote, comment string) ([][]string, error) {
	reader := csv.NewReader(bytes.NewReader(data))
	reader.Comma = []rune(delimiter)[0]
	reader.LazyQuotes = true
	reader.Comment = []rune(comment)[0]
	reader.TrimLeadingSpace = true
	reader.FieldsPerRecord = -1
	records, err := reader.ReadAll()
	if err != nil {
		return nil, err
	}
	return records, nil
}

func parseXML(data []byte) ([][]string, error) {
	var result map[string]string
	err := xml.Unmarshal(data, &result)
	if err != nil {
		return nil, err
	}
	var records [][]string
	for key, value := range result {
		records = append(records, []string{key, value})
	}
	return records, nil
}

func parseYAML(data []byte) ([][]string, error) {
	var result map[string]string
	err := yaml.Unmarshal(data, &result)
	if err != nil {
		return nil, err
	}
	var records [][]string
	for key, value := range result {
		records = append(records, []string{key, value})
	}
	return records, nil
}

func parseArgs(args []string) ([][]string, error) {
	var records [][]string
	for _, arg := range args {
		parts := strings.Split(arg, "=")
		if len(parts) < 2 {
			return nil, fmt.Errorf("invalid argument: %s", arg)
		}
		records = append(records, parts)
	}
	return records, nil
}

func TestTableViewCmd(t *testing.T) {
	cmd := tableViewCmd()
	if cmd.Use != "table" {
		t.Errorf("expected 'table', got '%s'", cmd.Use)
	}
	if cmd.Short != "Table view for any command" {
		t.Errorf("expected 'Table view for any command', got '%s'", cmd.Short)
	}
	if cmd.Long != "Table view screen, interactive mode, for any command with flags" {
		t.Errorf("expected 'Table view screen, interactive mode, for any command with flags', got '%s'", cmd.Long)
	}
}

func NavigateAndExecuteViewCommand(cmd *cobra.Command, args []string) error {
	// Detect command and its flags
	commandName := cmd.Name()
	flags := cmd.Flags()

	// Display command selection and flag definition in a table view
	tableConfig := createTableConfig(commandName, flags)
	customStyles := map[string]lipgloss.Color{
		"Info":    lipgloss.Color("#75FBAB"),
		"Warning": lipgloss.Color("#FDFF90"),
		"Error":   lipgloss.Color("#FF7698"),
		"Debug":   lipgloss.Color("#929292"),
	}
	if err := c.StartTableScreen(tableConfig, customStyles); err != nil {
		return err
	}

	var tableValues = make(map[string]string)
	for _, header := range tableConfig.GetHeaders() {
		tableValues[header] = ""
	}
	for _, row := range tableConfig.GetRows() {
		var i = 0
		for key, _ := range tableValues {
			tableValues[key] = row[i]
			i++
		}
	}
	// Set flag values based on table input
	flags.VisitAll(func(flag *pflag.Flag) {
		if value, ok := tableValues[flag.Name]; ok {
			if err := flag.Value.Set(value); err != nil {
				gl.Log("fatal", err.Error())
				return
			}
		}
	})

	// Execute the command
	return cmd.Execute()
}

func createTableConfig(commandName string, flags *pflag.FlagSet) *c.TableRenderer {
	var tableFields *c.TableRenderer
	var tableHeaders []string
	var tableRows [][]string

	flags.VisitAll(func(flag *pflag.Flag) {
		tableHeaders = append(tableHeaders, flag.Name)
		tableRows = append(tableRows, []string{flag.Name, flag.Usage})
	})

	tableFields = c.NewTableRenderer(&t.TableHandler{
		Headers: tableHeaders,
		Rows:    tableRows,
	}, make(map[string]lipgloss.Color), nil)

	return tableFields
}

/// cmd/main.go ///
package main

import (
	"os"
)

func main() {
	if err := RegX().Execute(); err != nil {
		os.Exit(1)
	}
}

/// cmd/usage.go ///
package main

import (
	"fmt"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

func colorYellow(s string) string {
	return color.New(color.FgYellow).SprintFunc()(s)
}
func colorGreen(s string) string {
	return color.New(color.FgGreen).SprintFunc()(s)
}
func colorBlue(s string) string {
	return color.New(color.FgBlue).SprintFunc()(s)
}
func colorRed(s string) string {
	return color.New(color.FgRed).SprintFunc()(s)
}
func colorHelp(s string) string {
	return color.New(color.FgCyan).SprintFunc()(s)
}
func hasServiceCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] == "true" {
			return true
		}
	}
	return false
}
func hasModuleCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] != "true" {
			return true
		}
	}
	return false
}
func setUsageDefinition(cmd *cobra.Command) {
	cobra.AddTemplateFunc("colorYellow", colorYellow)
	cobra.AddTemplateFunc("colorGreen", colorGreen)
	cobra.AddTemplateFunc("colorRed", colorRed)
	cobra.AddTemplateFunc("colorBlue", colorBlue)
	cobra.AddTemplateFunc("colorHelp", colorHelp)
	cobra.AddTemplateFunc("hasServiceCommands", hasServiceCommands)
	cobra.AddTemplateFunc("hasModuleCommands", hasModuleCommands)

	// Altera o template de uso do cobra
	cmd.SetUsageTemplate(cliUsageTemplate)
}

var cliUsageTemplate = `{{- if index .Annotations "banner" }}{{colorBlue (index .Annotations "banner")}}{{end}}{{- if (index .Annotations "description") }}
{{index .Annotations "description"}}
{{- end }}

{{colorYellow "Usage:"}}{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command] [args]{{end}}{{if gt (len .Aliases) 0}}

{{colorYellow "Aliases:"}}
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

{{colorYellow "Example:"}}
  {{.Example}}{{end}}{{if .HasAvailableSubCommands}}
{{colorYellow "Available Commands:"}}{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{colorGreen (rpad .Name .NamePadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

{{colorYellow "Flags:"}}
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasAvailableInheritedFlags}}

{{colorYellow "Global Options:"}}
  {{.InheritedFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasHelpSubCommands}}

{{colorYellow "Additional help topics:"}}
{{range .Commands}}{{if .IsHelpCommand}}
  {{colorGreen (rpad .CommandPath .CommandPathPadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasSubCommands}}

{{colorYellow (printf "Use \"%s [command] --help\" for more information about a command." .CommandPath)}}{{end}}
`

const AppName = "xtui"

func installCheck() {
	usrEnvs := os.Environ()
	envPath := os.Getenv("PATH")
	usrEnvs = append(usrEnvs, fmt.Sprintf("PATH=%s", envPath))
	appBinPath, appBinPathErr := exec.LookPath(AppName)
	if appBinPathErr != nil {
		fmt.Printf("Error: %v\n", appBinPathErr)
		return
	}
	appBinPath = strings.Replace(appBinPath, AppName, "", 1)

}

func cacheFlagAskForInstall(action string) (bool, error) {
	cacheDir, cacheDirErr := os.UserCacheDir()
	if cacheDirErr != nil {
		cacheDir = os.TempDir()
		if cacheDir == "" {
			cacheDir = "/tmp"
		}
	}
	userName, userNameErr := os.UserHomeDir()
	if userNameErr != nil {
		userName = "user"
	}
	cacheFilePath := filepath.Join(cacheDir, AppName, userName)

	// Essa lógica será para gravar a opção do usuário de instalar o módulo ou não.
	// A opção será gravada em um arquivo na pasta de cache do usuário.
	// O arquivo só será lido/buscado se o módulo não estiver instalado.
	// Se o arquivo existir, não haverá pergunta ao usuário.
	// O parâmetro action será para definir se será criado, lido ou removido o arquivo.
	switch action {
	case "create":
		// Cria o arquivo de cache, não perguntando nada pois a pergunta será feita em outro mtodo, anterior a este.
		// O arquivo será criado sem conteúdo, somente para sinalizar que a pergunta foi feita reduzindo a leiura em
		// busca de conteúdo, somente a verificação da existência do arquivo já é o próprio valor esperacdo.
		if mkdirErr := os.MkdirAll(cacheFilePath, 0755); mkdirErr != nil {
			return false, mkdirErr
		}
	case "check":
		// Verifica se o arquivo de cache existe
		if _, statErr := os.Stat(cacheFilePath); statErr != nil {
			return false, statErr
		} else {
			return true, nil
		}
	case "remove":
		// Remove o arquivo de cache
		if removeErr := os.RemoveAll(cacheFilePath); removeErr != nil {
			return false, removeErr
		}
	}

	return false, nil
}

/// cmd/wrpr.go ///
package main

import (
	"fmt"
	"os"
	"strings"

	l "github.com/kubex-ecosystem/logz"
	"github.com/kubex-ecosystem/xtui/cmd/cli"
	gl "github.com/kubex-ecosystem/xtui/logger"
	"github.com/kubex-ecosystem/xtui/version"
	"github.com/spf13/cobra"
)

// XTui representa a estrutura do módulo ui.
type XTui struct{}

// RegX registra e retorna uma nova instância de XTui.
func RegX() *XTui {
	return &XTui{}
}

// Alias retorna o alias do módulo ui.
func (m *XTui) Alias() string {
	return ""
}

// ShortDescription retorna uma descrição curta do módulo ui.
func (m *XTui) ShortDescription() string {
	return "Terminal UI"
}

// LongDescription retorna uma descrição longa do módulo ui.
func (m *XTui) LongDescription() string {
	return "Terminal XTUI module. It allows you to interact with the terminal using a graphical interface."
}

// Usage retorna a forma de uso do módulo ui.
func (m *XTui) Usage() string {
	return "xui [command] [args]"
}

// Examples retorna exemplos de uso do módulo ui.
func (m *XTui) Examples() []string {
	return []string{"xtui [command] [args]", "xtui logz -o 'file.log'", "xtui deps -o 'install'", "xtui tcp-status '127.0.0.1:8080'"}
}

// Active verifica se o módulo ui está ativo.
func (m *XTui) Active() bool {
	return true
}

// Module retorna o nome do módulo ui.
func (m *XTui) Module() string {
	return "xtui"
}

// Execute executa o comando especificado para o módulo ui.
func (m *XTui) Execute() error {
	return m.Command().Execute()
}

// concatenateExamples concatena os exemplos de uso do módulo.
func (m *XTui) concatenateExamples() string {
	examples := ""
	for _, example := range m.Examples() {
		examples += string(example) + "\n  "
	}
	return examples
}

// Command retorna o comando cobra para o módulo.
func (m *XTui) Command() *cobra.Command {
	l.GetLogger("XTuI")

	gl.Log("debug", fmt.Sprintf("Creating command for XTuI with flags: %v", os.Args))

	c := &cobra.Command{
		Use:         m.Module(),
		Aliases:     []string{m.Alias()},
		Example:     m.concatenateExamples(),
		Annotations: cli.GetDescriptions([]string{m.ShortDescription(), m.LongDescription()}, false),
	}

	// Adiciona os comandos relacionados ao módulo

	pkgCmdRoot := &cobra.Command{
		Use:     "pkg",
		Aliases: []string{"package", "packages"},
		Annotations: cli.GetDescriptions(
			[]string{
				"Package management",
				"Package installation, removal, and management with friendly UI and much more",
			}, false,
		),
		RunE: func(cmd *cobra.Command, args []string) error { return cmd.Help() },
	}
	pkgCmdRoot.AddCommand(cli.PkgCmdsList()...)
	c.AddCommand(pkgCmdRoot)

	appCmdRoot := &cobra.Command{
		Use:     "deps",
		Aliases: []string{"dep", "dependencies"},
		Annotations: cli.GetDescriptions(
			[]string{
				"Dependencies management",
				"Install, remove, and manage dependencies with friendly UI and much more",
			}, false,
		),
		RunE: func(cmd *cobra.Command, args []string) error { return cmd.Help() },
	}
	appCmdRoot.AddCommand(cli.AppsCmdsList()...)
	c.AddCommand(appCmdRoot)

	formCmdRoot := &cobra.Command{
		Use:     "forms",
		Aliases: []string{"frm", "form"},
		Annotations: cli.GetDescriptions(
			[]string{
				"Terminal forms builder",
				"Build terminal forms with validation, input types, and much more",
			}, false,
		),
		RunE: func(cmd *cobra.Command, args []string) error { return cmd.Help() },
	}
	formCmdRoot.AddCommand(cli.FormsCmdsList()...)
	c.AddCommand(formCmdRoot)

	dataCmdRoot := &cobra.Command{
		Use:     "viewer",
		Aliases: []string{"view", "v"},
		Annotations: cli.GetDescriptions(
			[]string{
				"Terminal features viewer",
				"View terminal features like logs, network status, and much more",
			}, false,
		),
		RunE: func(cmd *cobra.Command, args []string) error { return cmd.Help() },
	}
	dataCmdRoot.AddCommand(cli.ViewsCmdsList()...)
	c.AddCommand(dataCmdRoot)

	c.AddCommand(version.CliCommand())

	// Set usage definitions for the command and its subcommands
	setUsageDefinition(c)
	for _, subCmd := range c.Commands() {
		setUsageDefinition(c)
		if !strings.Contains(strings.Join(os.Args, " "), subCmd.Use) {
			if subCmd.Short == "" {
				subCmd.Short = subCmd.Annotations["description"]
			}
		}
	}

	return c
}

/// components/form_screen.go ///
package components

import (
	"fmt"
	"reflect"
	"strings"

	gl "github.com/kubex-ecosystem/xtui/logger"

	"github.com/charmbracelet/bubbles/cursor"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	. "github.com/kubex-ecosystem/xtui/types"
)

var (
	focusedStyle        = lipgloss.NewStyle().Foreground(lipgloss.Color("208"))
	blurredStyle        = lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
	cursorStyle         = focusedStyle
	noStyle             = lipgloss.NewStyle()
	helpStyle           = blurredStyle
	cursorModeHelpStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("244"))
	errorStyle          = lipgloss.NewStyle().Foreground(lipgloss.Color("160"))

	focusedButton = focusedStyle.Render("[ Proceed ]")
	blurredButton = fmt.Sprintf("[ %s ]", blurredStyle.Render("Proceed"))
)

var inputResult map[string]string

type FormModel struct {
	Title        string
	FocusIndex   int
	Inputs       []textinput.Model
	CursorMode   cursor.Mode
	Fields       []FormInputObject[any]
	ErrorMessage string
}

func initialFormModel(config FormConfig) FormModel {
	cfg := &config
	var inputs []FormInputObject[any]

	for _, field := range cfg.Fields {
		inputs = append(inputs, field)
	}

	availableProperties := getAvailableProperties()
	if len(availableProperties) > 0 {
		inputs = adaptInputsToProperties(inputs, availableProperties)
	}

	m := FormModel{
		Title:        cfg.Title,
		FocusIndex:   0,
		CursorMode:   cursor.CursorBlink,
		Fields:       config.Fields,
		Inputs:       make([]textinput.Model, len(inputs)),
		ErrorMessage: "",
	}

	var t textinput.Model
	for i, field := range inputs {
		t = textinput.New()
		t.Cursor.Style = cursorStyle
		t.CharLimit = 32

		tField := NewFormInput(field)

		t.Placeholder = tField.Placeholder()
		t.SetValue(tField.String())

		if tField.GetType().String() == "text" {
			t.EchoMode = textinput.EchoPassword
			t.EchoCharacter = '•'
		}

		if i == 0 {
			t.Focus()
			t.PromptStyle = focusedStyle
			t.TextStyle = focusedStyle
		}

		m.Inputs[i] = t

	}

	return m
}

func (m *FormModel) Init() tea.Cmd {
	return textinput.Blink
}

func (m *FormModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "esc":
			return m, tea.Quit
		case "ctrl+r":
			m.CursorMode++
			if m.CursorMode > cursor.CursorHide {
				m.CursorMode = cursor.CursorBlink
			}
			cmds := make([]tea.Cmd, len(m.Inputs))
			for i := range m.Inputs {
				cmds[i] = m.Inputs[i].Cursor.SetMode(m.CursorMode)
			}
			return m, tea.Batch(cmds...)

		case "tab", "shift+tab", "enter", "up", "down":
			s := msg.String()

			if s == "enter" && m.FocusIndex == len(m.Inputs) {
				return m, m.submit()
			}

			if s == "up" || s == "shift+tab" {
				m.FocusIndex--
			} else {
				m.FocusIndex++
			}

			if m.FocusIndex > len(m.Inputs) {
				m.FocusIndex = 0
			} else if m.FocusIndex < 0 {
				m.FocusIndex = len(m.Inputs)
			}

			cmds := make([]tea.Cmd, len(m.Inputs))
			for i := 0; i <= len(m.Inputs)-1; i++ {
				if i == m.FocusIndex {
					cmds[i] = m.Inputs[i].Focus()
					m.Inputs[i].PromptStyle = focusedStyle
					m.Inputs[i].TextStyle = focusedStyle
					continue
				}
				m.Inputs[i].Blur()
				m.Inputs[i].PromptStyle = noStyle
				m.Inputs[i].TextStyle = noStyle
			}

			return m, tea.Batch(cmds...)
		}
	}

	cmd := m.updateInputs(msg)

	return m, cmd
}

func (m *FormModel) View() string {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("\n%s\n\n", m.Title))

	for i := range m.Inputs {
		b.WriteString(m.Inputs[i].View())
		if i < len(m.Inputs)-1 {
			b.WriteRune('\n')
		}
	}

	button := &blurredButton
	if m.FocusIndex == len(m.Inputs) {
		button = &focusedButton
	}
	_, _ = fmt.Fprintf(&b, "\n\n%s\n\n", *button)

	if m.ErrorMessage != "" {
		b.WriteString(errorStyle.Render(m.ErrorMessage))
		b.WriteString("\n\n")
	}

	b.WriteString(helpStyle.Render("cursor mode is "))
	b.WriteString(cursorModeHelpStyle.Render(m.CursorMode.String()))
	b.WriteString(helpStyle.Render(" (ctrl+r to change style)"))

	return b.String()
}

func (m *FormModel) submit() tea.Cmd {
	for i, input := range m.Inputs {
		value := input.Value()
		field := m.Fields[i].(FormInput[any])

		if field.IsRequired() && value == "" {
			m.ErrorMessage = field.Error()
			return nil
		}
		if field.MinValue() > 0 && len(value) < field.MinValue() {
			m.ErrorMessage = field.Error()
			return nil
		}
		if field.MaxValue() > 0 && len(value) > field.MaxValue() {
			m.ErrorMessage = field.Error()
			return nil
		}
		if field.Validation()(value, nil) != nil {
			if err := field.Validation()(value, nil); err != nil {
				m.ErrorMessage = err.Error()
				return nil
			}
		}

		inputResult[fmt.Sprintf("field%d", i)] = value
	}

	m.ErrorMessage = ""
	DisplayNotification("Form submitted successfully", "info")
	return tea.Quit
}

func ShowForm(config FormConfig) (map[string]string, error) {
	inputResult = make(map[string]string)
	var newConfig FormConfig
	var newFields = config.Fields
	if newFields == nil {
		iNewConfig := FormConfig{
			Title: config.Title,
			FormFields: FormFields{
				Title:  config.Title,
				Fields: config.GetFields(),
			},
		}
		newConfig = FormConfig{
			Title: iNewConfig.Title,
			FormFields: FormFields{
				Title:  iNewConfig.Title,
				Fields: config.GetFields(),
			},
		}
	}
	initialModel := initialFormModel(newConfig)
	_, resultModelErr := tea.NewProgram(&initialModel).Run()
	if resultModelErr != nil {
		gl.Log("error", "Error running form model:"+resultModelErr.Error())
		return nil, resultModelErr
	}
	return inputResult, nil
}

func (m *FormModel) updateInputs(msg tea.Msg) tea.Cmd {
	cmds := make([]tea.Cmd, len(m.Inputs))

	for i := range m.Inputs {
		m.Inputs[i], cmds[i] = m.Inputs[i].Update(msg)
	}

	return tea.Batch(cmds...)
}

func getAvailableProperties() map[string]string {
	return map[string]string{
		"property1": "value1",
		"property2": "value2",
	}
}

func adaptInputsToProperties(inputs []FormInputObject[any], properties map[string]string) []FormInputObject[any] {
	adaptedInputs := inputs
	for _, value := range properties {
		vl := reflect.ValueOf(value)
		v := NewInput(vl.Interface().(FormInputObject[any]))
		adaptedInputs = append(adaptedInputs, v.GetValue())
	}
	return adaptedInputs
}

func NavigateAndExecuteForm(config FormConfig) (map[string]string, error) {
	inputResult = make(map[string]string)
	initialModel := initialFormModel(config)
	_, resultModelErr := tea.NewProgram(&initialModel).Run()
	if resultModelErr != nil {
		gl.Log("error", "Error running form model:"+resultModelErr.Error())
		return nil, resultModelErr
	}
	DisplayNotification("Form submitted successfully", "info")
	return inputResult, nil
}

func ShowFormWithNotification(config FormConfig) (map[string]string, error) {
	inputResult = make(map[string]string)
	initialModel := initialFormModel(config)
	_, resultModelErr := tea.NewProgram(&initialModel).Run()
	if resultModelErr != nil {
		gl.Log("error", "Error running form model:"+resultModelErr.Error())
		return nil, resultModelErr
	}
	// Display notification
	DisplayNotification("Form submitted successfully", "info")
	return inputResult, nil
}

func DisplayNotification(message, messageType string) {
	// Implement the notification system logic here
	// Use different styles and colors to differentiate between information, warnings, and errors
	switch messageType {
	case "info":
		fmt.Println(lipgloss.NewStyle().Foreground(lipgloss.Color("#75FBAB")).Render(message))
	case "warning":
		fmt.Println(lipgloss.NewStyle().Foreground(lipgloss.Color("#FDFF90")).Render(message))
	case "error":
		fmt.Println(lipgloss.NewStyle().Foreground(lipgloss.Color("#FF7698")).Render(message))
	default:
		fmt.Println(message)
	}
}

/// components/notification_system.go ///
package components

import (
	"fmt"
	"github.com/charmbracelet/lipgloss"
)

type NotificationType string

const (
	Info    NotificationType = "info"
	Warning NotificationType = "warning"
	Error   NotificationType = "error"
)

type Notification struct {
	Message string
	Type    NotificationType
}

func ShowNotification(notification Notification) {
	var style lipgloss.Style

	switch notification.Type {
	case Info:
		style = lipgloss.NewStyle().Foreground(lipgloss.Color("#75FBAB"))
	case Warning:
		style = lipgloss.NewStyle().Foreground(lipgloss.Color("#FDFF90"))
	case Error:
		style = lipgloss.NewStyle().Foreground(lipgloss.Color("#FF7698"))
	default:
		style = lipgloss.NewStyle()
	}

	fmt.Println(style.Render(notification.Message))
}

func DisplayInfoNotification(message string) {
	ShowNotification(Notification{Message: message, Type: Info})
}

func DisplayWarningNotification(message string) {
	ShowNotification(Notification{Message: message, Type: Warning})
}

func DisplayErrorNotification(message string) {
	ShowNotification(Notification{Message: message, Type: Error})
}

/// components/table_screen.go ///
package components

import (
	"encoding/csv"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"

	"github.com/atotto/clipboard"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/charmbracelet/lipgloss/table"
	"github.com/johnfercher/maroto/pkg/consts"
	p "github.com/johnfercher/maroto/pkg/pdf"
	"github.com/johnfercher/maroto/pkg/props"
	gl "github.com/kubex-ecosystem/xtui/logger"
	. "github.com/kubex-ecosystem/xtui/types"
	"gopkg.in/yaml.v2"
)

// TableRenderer is responsible for rendering tables in the terminal with customizable styles and dynamic behavior.
type TableRenderer struct {
	tbHandler    TableDataHandler
	kTb          *table.Table
	headers      []string
	rows         [][]string
	filter       string
	filteredRows [][]string
	sortColumn   int
	sortAsc      bool
	page         int
	pageSize     int
	search       string
	selectedRow  int
	showHelp     bool
	visibleCols  map[string]bool
}

// StyleFunc defines a function that returns a lipgloss.Style based on row, column, and cell value.
type StyleFunc func(row, col int, cellValue string) lipgloss.Style

// NewTableRenderer creates a new TableRenderer with custom styles and an optional style function.
func NewTableRenderer(tbHandler TableDataHandler, customStyles map[string]lipgloss.Color, styleFunc StyleFunc) *TableRenderer {
	headers := tbHandler.GetHeaders()
	rows := tbHandler.GetRows()
	re := lipgloss.NewRenderer(os.Stdout)
	baseStyle := re.NewStyle().Padding(0, 1)
	headerStyle := baseStyle.Foreground(lipgloss.Color("252")).Bold(true)
	selectedStyle := baseStyle.Foreground(lipgloss.Color("#01BE85")).Background(lipgloss.Color("#00432F"))

	defaultTypeColors := map[string]lipgloss.Color{
		"Info":    lipgloss.Color("#75FBAB"),
		"Warning": lipgloss.Color("#FDFF90"),
		"Error":   lipgloss.Color("#FF7698"),
		"Debug":   lipgloss.Color("#929292"),
	}

	for key, value := range customStyles {
		defaultTypeColors[key] = value
	}

	if styleFunc == nil {
		styleFunc = func(row, col int, cellValue string) lipgloss.Style {
			if row == 0 {
				return headerStyle
			}

			rowIndex := row - 1
			if rowIndex < 0 || rowIndex >= len(rows) {
				return baseStyle
			}
			if rows != nil && len(rows) < rowIndex {
				if rows[rowIndex] != nil && len(rows[rowIndex]) > 1 {
					if rows[rowIndex][1] == "Bug" {
						return selectedStyle
					}
				}
			}

			switch col {
			case 2, 3:
				c := defaultTypeColors

				if col >= len(rows[rowIndex]) {
					return baseStyle
				}

				color, ok := c[rows[rowIndex][col]]
				if !ok {
					return baseStyle
				}
				return baseStyle.Foreground(color)
			}
			return baseStyle.Foreground(lipgloss.Color("252"))
		}
	} else {
		styleFunc = func(row, col int, cellValue string) lipgloss.Style {
			if row == 0 {
				return headerStyle
			}
			rowIndex := row - 1
			if rowIndex < 0 || rowIndex >= len(rows) {
				return baseStyle
			}
			return styleFunc(rowIndex, col, rows[rowIndex][col])
		}
	}

	t := table.New().
		Headers(headers...).
		Rows(rows...).
		Border(lipgloss.NormalBorder()).
		BorderStyle(re.NewStyle().Foreground(lipgloss.Color("238"))).
		StyleFunc(func(row, col int) lipgloss.Style {
			if row == 0 {
				return headerStyle
			}
			if row == 1 {
				return selectedStyle
			}
			rowIndex := row - 1
			if rowIndex < 0 || len(rows) <= rowIndex {
				return baseStyle
			}
			if rows != nil && rowIndex < len(rows) {
				if rows[rowIndex] != nil &&
					len(rows[rowIndex]) > 1 &&
					len(rows[rowIndex]) > col &&
					len(rows[rowIndex]) > 1 {
					if rows[rowIndex][1] == "Bug" {
						return selectedStyle
					}
				}
			}
			if col >= len(rows[rowIndex]) {
				return baseStyle
			}

			return styleFunc(row, col, rows[row][col])
			//return styleFunc(row, col, rows[rowIndex][col])
		}).
		Border(lipgloss.ThickBorder())

	pageSizeLimitStr := os.Getenv("KBX_PAGE_SIZE_LIMIT")
	if pageSizeLimitStr != "" {
		pageSizeLimitStr = os.Getenv("LINES")
		if pageSizeLimitStr == "" {
			pageSizeLimitStr = "20"
		}
	}
	pageSizeLimit, pageSizeLimitErr := strconv.Atoi(pageSizeLimitStr)
	if pageSizeLimitErr == nil {
		pageSizeLimit = 20
	} else if pageSizeLimit < 1 {
		pageSizeLimit = 20
	}

	visibleCols := make(map[string]bool)
	for _, header := range headers {
		visibleCols[header] = true
	}

	return &TableRenderer{
		tbHandler:    tbHandler,
		kTb:          t,
		headers:      headers,
		rows:         rows,
		filteredRows: rows,
		sortColumn:   -1,
		sortAsc:      true,
		page:         0,
		pageSize:     pageSizeLimit,
		search:       "",
		selectedRow:  -1,
		showHelp:     false,
		visibleCols:  visibleCols,
	}
}

// Init initializes the table renderer.
func (k *TableRenderer) Init() tea.Cmd {
	return nil
}

// Update updates the table renderer based on user input.
func (k *TableRenderer) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	switch message := msg.(type) {
	case tea.WindowSizeMsg:
		k.kTb = k.kTb.Width(message.Width)
		k.kTb = k.kTb.Height(message.Height)
	case tea.KeyMsg:
		switch message.String() {
		case "q", "ctrl+c":
			return k, tea.Quit
		case "enter":
			k.ApplyFilter()
			if k.selectedRow >= 0 && k.selectedRow < len(k.filteredRows) {
				row := k.filteredRows[k.selectedRow]
				_ = clipboard.WriteAll(strings.Join(row, "\t"))
			}
		case "backspace":
			if len(k.filter) > 0 {
				k.filter = k.filter[:len(k.filter)-1]
			}
		case "esc":
			k.selectedRow = -1
		case "ctrl+o":
			k.sortColumn = (k.sortColumn + 1) % len(k.headers)
			k.sortAsc = !k.sortAsc
			k.SortRows()
		case "right":
			if (k.page+1)*k.pageSize < len(k.filteredRows) {
				k.page++
			}
		case "left":
			if k.page > 0 {
				k.page--
			}
		case "down":
			_ = k.RowsNavigate("down")
		case "up":
			_ = k.RowsNavigate("up")
		case "ctrl+e":
			k.ExportToCSV("exported_data.csv")
		case "ctrl+h":
			k.showHelp = !k.showHelp
		case "ctrl+y":
			k.ExportToYAML("exported_data.yaml")
		case "ctrl+j":
			k.ExportToJSON("exported_data.json")
		case "ctrl+x":
			k.ExportToXML("exported_data.xml")
		case "ctrl+l":
			k.ExportToExcel("exported_data.xlsx")
		case "ctrl+p":
			k.ExportToPDF("exported_data.pdf")
		case "ctrl+m":
			k.ExportToMarkdown("exported_data.md")
		case "ctrl+k":
			k.ToggleColumnVisibility()
		default:
			k.filter += message.String()
		}
	}
	k.kTb.ClearRows()                             // Clear the table rows before adding new ones
	k.kTb = k.kTb.Rows(k.GetCurrentPageRows()...) // Update the table with the current rows
	return k, cmd
}

// View returns the string representation of the table for rendering.
func (k *TableRenderer) View() string {
	helpText := "\nShortcuts:\n" +
		"  - q, ctrl+c: Quit\n" +
		"  - enter: Copy selected row to clipboard\n" +
		"  - esc: Exit selection mode\n" +
		"  - backspace: Remove last character from filter\n" +
		"  - ctrl+o: Toggle sorting\n" +
		"  - right: Next page\n" +
		"  - left: Previous page\n" +
		"  - down: Select next row\n" +
		"  - up: Select previous row\n" +
		"  - ctrl+e: Export to CSV\n" +
		"  - ctrl+y: Export to YAML\n" +
		"  - ctrl+j: Export to JSON\n" +
		"  - ctrl+x: Export to XML\n" +
		"  - ctrl+l: Export to Excel\n" +
		"  - ctrl+p: Export to PDF\n" +
		"  - ctrl+m: Export to Markdown\n" +
		"  - ctrl+k: Toggle column visibility\n"

	toggleHelpText := "\nPress ctrl+h to show/hide shortcuts."

	if k.showHelp {
		return fmt.Sprintf("\nFilter: %s\n\n%s\nPage: %d/%d\n%s%s", k.filter, k.kTb.String(), k.page+1, (len(k.filteredRows)+k.pageSize-1)/k.pageSize, helpText, toggleHelpText)
	}
	return fmt.Sprintf("\nFilter: %s\n\n%s\nPage: %d/%d\n%s", k.filter, k.kTb.String(), k.page+1, (len(k.filteredRows)+k.pageSize-1)/k.pageSize, toggleHelpText)
}

// GetHeaders returns the table headers.
func (k *TableRenderer) GetHeaders() []string { return k.headers }

// GetRows returns the table rows.
func (k *TableRenderer) GetRows() [][]string { return k.rows }

// GetArrayMap returns the table data as a map of arrays.
func (k *TableRenderer) GetArrayMap() map[string][]string {
	m := make(map[string][]string)
	for _, row := range k.rows {
		m[row[0]] = row[1:]
	}
	return m
}

// GetHashMap returns the table data as a hash map.
func (k *TableRenderer) GetHashMap() map[string]string {
	m := make(map[string]string)
	for _, row := range k.rows {
		m[row[0]] = row[1]
	}
	return m
}

// GetObjectMap returns the table data as a slice of maps.
func (k *TableRenderer) GetObjectMap() []map[string]string {
	var m []map[string]string
	for _, row := range k.rows {
		m = append(m, map[string]string{row[0]: row[1]})
	}
	return m
}

// GetByteMap returns the table data as a map of byte slices.
func (k *TableRenderer) GetByteMap() map[string][]byte {
	m := make(map[string][]byte)
	for _, row := range k.rows {
		m[row[0]] = []byte(row[1])
	}
	return m
}

// RowsNavigate navigates through the table rows.
func (k *TableRenderer) RowsNavigate(direction string) error {
	if direction == "down" {
		k.selectedRow++
	} else {
		k.selectedRow--
	}

	if k.selectedRow < 0 {
		k.selectedRow = 0
	}
	if k.selectedRow >= len(k.filteredRows) {
		k.selectedRow = len(k.filteredRows) - 1
	}

	if k.selectedRow >= 0 && len(k.filteredRows) > 0 {
		k.kTb.StyleFunc(func(row, col int) lipgloss.Style {
			if row == k.selectedRow {
				return lipgloss.NewStyle().Foreground(lipgloss.Color("#01BE85")).Background(lipgloss.Color("#00432F"))
			}
			return lipgloss.NewStyle().Foreground(lipgloss.Color("252"))
		})
	} else if k.selectedRow == 0 {
		k.kTb.StyleFunc(func(row, col int) lipgloss.Style {
			if row == 1 {
				return lipgloss.NewStyle().Foreground(lipgloss.Color("#01BE85")).Background(lipgloss.Color("#00432F"))
			}
			return lipgloss.NewStyle().Foreground(lipgloss.Color("252"))
		})
	} else {
		k.kTb.StyleFunc(func(row, col int) lipgloss.Style {
			return lipgloss.NewStyle().Foreground(lipgloss.Color("252"))
		})
	}
	return nil
}

// ApplyFilter applies a filter to the table rows.
func (k *TableRenderer) ApplyFilter() {
	if k.filter == "" {
		k.filteredRows = k.rows
	} else {
		var filtered [][]string
		for _, row := range k.rows {
			for _, cell := range row {
				if strings.Contains(strings.ToLower(cell), strings.ToLower(k.filter)) {
					filtered = append(filtered, row)
					break
				}
			}
		}
		k.filteredRows = filtered
	}
	k.kTb = k.kTb.Rows(k.GetCurrentPageRows()...)
}

// SortRows sorts the table rows.
func (k *TableRenderer) SortRows() {
	sort.SliceStable(k.filteredRows, func(i, j int) bool {
		if k.sortAsc {
			return k.filteredRows[i][k.sortColumn] < k.filteredRows[j][k.sortColumn]
		}
		return k.filteredRows[i][k.sortColumn] > k.filteredRows[j][k.sortColumn]
	})
	k.kTb = k.kTb.Rows(k.GetCurrentPageRows()...)
}

// GetCurrentPageRows returns the rows for the current page.
func (k *TableRenderer) GetCurrentPageRows() [][]string {
	start := k.page * k.pageSize
	end := start + k.pageSize
	if end > len(k.filteredRows) {
		end = len(k.filteredRows)
	}
	return k.filteredRows[start:end]
}

// ExportToCSV exports the table data to a CSV file.
func (k *TableRenderer) ExportToCSV(filename string) {
	file, err := os.Create(filename)
	if err != nil {
		gl.Log("error", "Error creating file: "+err.Error())
		return
	}
	defer func(file *os.File) {
		_ = file.Close()
	}(file)

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Write headers
	if writerErr := writer.Write(k.headers); writerErr != nil {
		gl.Log("error", "Error writing headers to CSV:"+writerErr.Error())
		return
	}

	// Write rows
	for _, row := range k.filteredRows {
		if writerRowsErr := writer.Write(row); writerRowsErr != nil {
			gl.Log("error", "Error writing row to CSV: "+writerRowsErr.Error())
			return
		}
	}

	gl.Log("info", "Data exported to CSV:"+filename)
}

// ExportToYAML exports the table data to a YAML file.
func (k *TableRenderer) ExportToYAML(filename string) {
	file, err := os.Create(filename)
	if err != nil {
		gl.Log("error", "Error creating file:"+err.Error())
		return
	}
	defer func(file *os.File) {
		_ = file.Close()
	}(file)
	data := k.GetObjectMap()
	encoder := yaml.NewEncoder(file)
	defer func(encoder *yaml.Encoder) {
		_ = encoder.Close()
	}(encoder)

	if err := encoder.Encode(data); err != nil {
		gl.Log("error", "Error writing data to YAML:"+err.Error())
		return
	}

	gl.Log("info", "Data exported to YAML:"+filename)
}

// ExportToJSON exports the table data to a JSON file.
func (k *TableRenderer) ExportToJSON(filename string) {
	file, err := os.Create(filename)
	if err != nil {
		gl.Log("error", "Error creating file:"+err.Error())
		return
	}
	defer func(file *os.File) {
		_ = file.Close()
	}(file)
	data := k.GetObjectMap()
	encoder := json.NewEncoder(file)
	if err := encoder.Encode(data); err != nil {
		gl.Log("error", "Error writing data to JSON:"+err.Error())
		return
	}
	gl.Log("info", "Data exported to JSON:"+filename)
}

// ExportToXML exports the table data to an XML file.
func (k *TableRenderer) ExportToXML(filename string) {
	file, err := os.Create(filename)
	if err != nil {
		gl.Log("error", "Error creating file:"+err.Error())
		return
	}
	defer func(file *os.File) {
		_ = file.Close()
	}(file)
	encoder := xml.NewEncoder(file)
	encoder.Indent("", "  ") // Indent for better readability
	vstr := xml.StartElement{Name: xml.Name{Local: "table"}}
	defer func(encoder *xml.Encoder) {
		if err := encoder.EncodeToken(xml.EndElement{Name: vstr.Name}); err != nil {
			gl.Log("error", "Error writing end token to XML:"+err.Error())
		}
	}(encoder)
	if err := encoder.EncodeToken(vstr); err != nil {
		gl.Log("error", "Error writing start token to XML:"+err.Error())
		return
	}
	gl.Log("info", "Data exported to XML:"+filename)
}

// ExportToExcel is a placeholder for exporting the table data to an Excel file.
func (k *TableRenderer) ExportToExcel(filename string) {
	// Implementation for exporting to Excel
}

// ExportToPDF exports the table data to a PDF file.
func (k *TableRenderer) ExportToPDF(filename string) {
	m := p.NewMaroto(consts.Landscape, consts.Letter)
	m.SetBorder(true)

	// Add headers
	m.Row(10, func() {
		for _, header := range k.headers {
			w := uint(12 / len(k.headers))
			m.Col(w, func() {
				m.Text(header, props.Text{Align: consts.Center, Style: consts.Bold})
			})
		}
	})

	// Add rows
	for _, row := range k.filteredRows {
		m.Row(10, func() {
			for _, cell := range row {
				w := uint(12 / len(row))
				m.Col(w, func() {
					m.Text(cell, props.Text{Align: consts.Left})
				})
			}
		})
	}

	// Save the PDF
	err := m.OutputFileAndClose(filename)
	if err != nil {
		gl.Log("error", "Could not save PDF: "+err.Error())
	}
}

// ExportToMarkdown exports the table data to a Markdown file.
func (k *TableRenderer) ExportToMarkdown(filename string) {
	// Implementation for exporting to Markdown
}

// ToggleColumnVisibility toggles the visibility of the columns in the table.
func (k *TableRenderer) ToggleColumnVisibility() {
	for header := range k.visibleCols {
		k.visibleCols[header] = !k.visibleCols[header]
	}
	k.kTb = k.kTb.Rows(k.GetCurrentPageRows()...)
}

// Execution functions

// GetTableScreenCustom returns the string representation of the table with custom styles and an optional style function.
func GetTableScreenCustom(tbHandler TableDataHandler, customStyles map[string]lipgloss.Color, styleFunc StyleFunc) string {
	k := NewTableRenderer(tbHandler, customStyles, styleFunc)
	return k.View()
}

// NavigateAndExecuteTableCustom navigates and executes the table screen with custom styles and an optional style function.
func NavigateAndExecuteTableCustom(tbHandler TableDataHandler, customStyles map[string]lipgloss.Color, styleFunc StyleFunc) error {
	k := NewTableRenderer(tbHandler, customStyles, styleFunc)

	prog := tea.NewProgram(k, tea.WithAltScreen())
	if _, err := prog.Run(); err != nil {
		gl.Log("error", "Error running table screen: "+err.Error())
		return nil
	}
	return nil
}

// StartTableScreenCustom starts the table screen with custom styles and an optional style function.
func StartTableScreenCustom(tbHandler TableDataHandler, customStyles map[string]lipgloss.Color, styleFunc StyleFunc) error {
	k := NewTableRenderer(tbHandler, customStyles, styleFunc)

	prog := tea.NewProgram(k, tea.WithAltScreen())
	if _, err := prog.Run(); err != nil {
		gl.Log("error", "Error running table screen: "+err.Error())
		return nil
	}
	return nil
}

// GetTableScreen returns the string representation of the table with custom styles.
func GetTableScreen(tbHandler TableDataHandler, customStyles map[string]lipgloss.Color) string {
	return GetTableScreenCustom(tbHandler, customStyles, nil)
}

// NavigateAndExecuteTable navigates and executes the table screen with custom styles.
func NavigateAndExecuteTable(tbHandler TableDataHandler, customStyles map[string]lipgloss.Color) error {
	return NavigateAndExecuteTableCustom(tbHandler, customStyles, nil)
}

// StartTableScreen starts the table screen with custom styles.
func StartTableScreen(tbHandler TableDataHandler, customStyles map[string]lipgloss.Color) error {
	return StartTableScreenCustom(tbHandler, customStyles, nil)
}

// StartTableScreenFromRenderer starts the table screen from a given TableRenderer.
func StartTableScreenFromRenderer(k *TableRenderer) error {
	prog := tea.NewProgram(k, tea.WithAltScreen())
	if _, err := prog.Run(); err != nil {
		gl.Log("error", "Error running table screen: "+err.Error())
		return err
	}
	return nil
}

/// docs/README.pt-BR.md ///
[//]: # (![XTui Banner](./assets/banner.png))

# XTui

---

**Uma biblioteca de interface de usuário de terminal (TUI) para Go, de alto desempenho e fácil de usar, permitindo que
desenvolvedores criem aplicações de terminal interativas e visualmente atraentes com o mínimo de esforço.**

---

![Versão Go](https://img.shields.io/github/go-mod/go-version/faelmori/xtui)
![Licença](https://img.shields.io/github/license/faelmori/xtui)
![Status do Build](https://img.shields.io/github/actions/workflow/status/faelmori/xtui/build.yml)

## Índice

- [Introdução](#introducao)
- [Recursos](#recursos)
- [Instalação](#instalacao)
- [Uso](#uso)
- [Exemplos CLI](#exemplos-cli)
- [Exemplos de Módulo](#exemplos-de-modulo)
- [Atalhos de Teclado](#atalhos-de-teclado)
- [Manipulação de Formulários](#manipulacao-de-formularios)
- [Exportação de Dados](#exportacao-de-dados)
- [Funcionalidades de Navegação de Comando](#funcionalidades-de-navegacao-de-comando)
- [Testes](#testes)
- [Contribuindo](#contribuindo)
- [Licença](#licenca)

## Introducao

**xtui** é uma biblioteca TUI para Go, de alto desempenho e fácil de usar. Permite que desenvolvedores criem aplicações
de terminal interativas e visualmente atraentes com o mínimo de esforço, mantendo flexibilidade e performance.

## Recursos

- **API Intuitiva** – Simplifica a criação de interfaces ricas para terminal.
- **Estilos Personalizáveis** – Personalize componentes de UI conforme suas necessidades com estilos e configurações
  customizadas.
- **Manipulação Interativa de Formulários** – Gerencie entradas de formulário com validação, proteção de senha e
  navegação.
- **Filtragem, Ordenação e Navegação de Dados** – Suporte embutido para operações em tabelas.
- **Atalhos de Teclado** – Proporciona uma experiência eficiente com teclas de atalho pré-definidas.
- **Visualizações Paginadas** – Permite navegação fluida em grandes volumes de dados.
- **Exportação Multi-formato** – Exporte dados para CSV, YAML, JSON e XML.
- **Registro de Erros** – Integrado com a biblioteca **logz** para rastreamento e depuração de erros.

## Instalacao

Para instalar o **xtui**, execute o comando:

```sh
go get github.com/kubex-ecosystem/xtui
```

## Uso

Aqui está um exemplo rápido demonstrando como usar o **xtui** para exibir tabelas:

```go
package main

import (
    "github.com/kubex-ecosystem/xtui"
    "github.com/kubex-ecosystem/xtui/types"
    "github.com/charmbracelet/lipgloss"
)

func main() {
    config := types.FormConfig{
        Fields: []types.Field{
            {Name: "ID", Placeholder: "ID Único"},
            {Name: "Nome", Placeholder: "Nome do Usuário"},
        },
    }

    customStyles := map[string]lipgloss.Color{
        "Info":    lipgloss.Color("#75FBAB"),
        "Warning": lipgloss.Color("#FDFF90"),
    }

    if err := xtui.StartTableScreen(config, customStyles); err != nil {
        panic(err)
    }
}
```

Para interações baseadas em formulário:

```go
package main

import (
    "github.com/kubex-ecosystem/xtui"
    "github.com/kubex-ecosystem/xtui/types"
)

func main() {
    config := types.Config{
        Title: "Cadastro de Usuário",
        Fields: types.FormFields{
            Inputs: []types.InputField{
                {Ph: "Nome", Tp: "text", Req: true, Err: "Nome é obrigatório!"},
                {Ph: "Senha", Tp: "password", Req: true, Err: "Senha é obrigatória!"},
            },
        },
    }

    result, err := xtui.ShowForm(config)
    if err != nil {
        panic(err)
    }
    println("Formulário enviado:", result)
}
```

### Funcionalidades de Navegação de Comando

O módulo `xtui` fornece várias funcionalidades de navegação de comando para aprimorar a experiência do usuário. Estas
incluem `NavigateAndExecuteCommand`, `NavigateAndExecuteFormCommand` e `NavigateAndExecuteViewCommand`.

#### NavigateAndExecuteCommand

A função `NavigateAndExecuteCommand` gerencia a navegação e execução de comandos. Ela detecta comandos e seus flags,
exibe seleção de comando e definição de flags em um formulário, define valores dos flags com base na entrada do
formulário e executa o comando.

Exemplo:

```go
package main

import (
    "github.com/kubex-ecosystem/xtui/cmd/cli"
    "github.com/spf13/cobra"
)

func main() {
    cmd := &cobra.Command{
        Use: "exemplo-comando",
        RunE: func(cmd *cobra.Command, args []string) error {
            return cli.NavigateAndExecuteCommand(cmd, args)
        },
    }

    if err := cmd.Execute(); err != nil {
        panic(err)
    }
}
```

#### NavigateAndExecuteFormCommand

A função `NavigateAndExecuteFormCommand` gerencia navegação e execução baseadas em formulário. Ela detecta comandos e
seus flags, exibe seleção de comando e definição de flags em um formulário, define valores dos flags com base na entrada
do formulário e executa o comando.

Exemplo:

```go
package main

import (
    "github.com/kubex-ecosystem/xtui/cmd/cli"
    "github.com/spf13/cobra"
)

func main() {
    cmd := &cobra.Command{
        Use: "exemplo-form-comando",
        RunE: func(cmd *cobra.Command, args []string) error {
            return cli.NavigateAndExecuteFormCommand(cmd, args)
        },
    }

    if err := cmd.Execute(); err != nil {
        panic(err)
    }
}
```

#### NavigateAndExecuteViewCommand

A função `NavigateAndExecuteViewCommand` gerencia navegação e execução baseadas em tabela. Ela detecta comandos e seus
flags, exibe seleção de comando e definição de flags em uma visualização de tabela, define valores dos flags com base na
entrada da tabela e executa o comando.

Exemplo:

```go
package main

import (
    "github.com/kubex-ecosystem/xtui/cmd/cli"
    "github.com/spf13/cobra"
)

func main() {
    cmd := &cobra.Command{
        Use: "exemplo-view-comando",
        RunE: func(cmd *cobra.Command, args []string) error {
            return cli.NavigateAndExecuteViewCommand(cmd, args)
        },
    }

    if err := cmd.Execute(); err != nil {
        panic(err)
    }
}
```

## Exemplos CLI

### Comando para Instalar Aplicações

```sh
go run main.go app-install --application app1 --application app2 --path /usr/local/bin --yes --quiet
```

### Comando de Visualização de Tabela

```sh
go run main.go table-view
```

### Comando de Formulário de Entrada

```sh
go run main.go input-form
```

### Comando de Formulário com Loader

```sh
go run main.go loader-form
```

## Exemplos de Módulo

### Visualizador de Logs

```go
package main

import (
    "github.com/kubex-ecosystem/xtui/wrappers"
)

func main() {
    if err := wrappers.LogViewer(); err != nil {
        panic(err)
    }
}
```

### Gerenciador de Aplicações

```go
package main

import (
    "github.com/kubex-ecosystem/xtui/wrappers"
)

func main() {
    args := []string{"app1", "app2", "/usr/local/bin", "true", "true"}
    if err := wrappers.InstallDependenciesWithUI(args...); err != nil {
        panic(err)
    }
}
```

## Atalhos de Teclado

Os seguintes atalhos de teclado são suportados nativamente:

- **q, Ctrl+C:** Sair da aplicação.
- **Enter:** Copiar linha selecionada ou enviar formulário.
- **Ctrl+R:** Alterar modo do cursor.
- **Tab/Shift+Tab, Setas Cima/Baixo:** Navegar entre campos do formulário ou linhas da tabela.
- **Ctrl+E:** Exportar dados para CSV.
- **Ctrl+Y:** Exportar dados para YAML.
- **Ctrl+J:** Exportar dados para JSON.
- **Ctrl+X:** Exportar dados para XML.

## Manipulacao de Formularios

O **xtui** fornece uma API intuitiva para gerenciar formulários com validações:

- **Validação de Campos:** Exige campos obrigatórios, tamanho mínimo/máximo e validadores customizados.
- **Campo de Senha:** Manipula campos de senha de forma segura, ocultando caracteres.
- **Propriedades Dinâmicas:** Adapta automaticamente os campos do formulário com base em configurações externas.

### Exemplo

```go
field := types.InputField{
Ph:  "Email",
Tp:  "text",
Req: true,
Err: "E-mail válido é obrigatório!",
Vld: func (value string) error {
if !strings.Contains(value, "@") {
return fmt.Errorf("Formato de e-mail inválido")
}
return nil
},
}
```

## Exportacao de Dados

O **xtui** suporta exportação de dados de tabela em múltiplos formatos:

- **CSV:** Salva os dados em arquivo separado por vírgulas.
- **YAML:** Exporta os dados em formato YAML estruturado.
- **JSON:** Codifica os dados em formato JSON compacto.
- **XML:** Exporta os dados como XML para interoperabilidade.

### Exemplo

Para exportar dados para um arquivo, basta usar o atalho correspondente (ex: `Ctrl+E` para CSV). Os arquivos serão
salvos com nomes predefinidos, como `exported_data.csv`.

## Testes

Para testar as novas funcionalidades de navegação do módulo `xtui`, siga os passos:

* Execute os testes unitários fornecidos no repositório. Por exemplo, rode os testes em `cmd/cli/form_commands.go` e
  `cmd/cli/views_commands.go` usando o comando `go test`.
* Use a função `NavigateAndExecuteCommand` em `cmd/cli/app_commands.go` para testar navegação e execução de comandos.
  Você pode criar um novo comando e chamar essa função com o comando e argumentos.
* Teste a navegação baseada em formulário rodando o comando `input-form` definido em `cmd/cli/form_commands.go`. Esse
  comando usa a função `NavigateAndExecuteFormCommand` para manipular entradas de formulário e executar o comando.
* Teste a navegação baseada em tabela rodando o comando `table-view` definido em `cmd/cli/views_commands.go`. Esse
  comando usa a função `NavigateAndExecuteViewCommand` para manipular visualizações de tabela e executar o comando.
* Teste a navegação baseada em loader rodando o comando `loader-form` definido em `cmd/cli/form_commands.go`. Esse
  comando usa a função `wrappers.StartLoader` para exibir uma tela de carregamento e executar o comando.

## Contribuindo

Contribuições de todos os tipos são bem-vindas! Seja reportando problemas, melhorando a documentação ou enviando novas
funcionalidades, sua ajuda é apreciada. Confira nosso [guia de contribuição](CONTRIBUTING.md) para mais detalhes.

## Licenca

Este projeto está licenciado sob a Licença MIT. Veja o arquivo [LICENSE](LICENSE) para mais detalhes.

/// docs/table_screen.md ///
### `table_screen.go` Documentation

#### Package `components`

This package provides a `TableRenderer` for rendering tables in the terminal with customizable styles and dynamic behavior.

#### Imports

- `encoding/csv`, `encoding/json`, `encoding/xml`: For parsing different file formats.
- `fmt`: For formatted I/O.
- `github.com/atotto/clipboard`: For clipboard operations.
- `tea "github.com/charmbracelet/bubbletea"`: For building terminal user interfaces.
- `github.com/charmbracelet/lipgloss`: For styling terminal output.
- `github.com/charmbracelet/lipgloss/table`: For creating tables.
- `l "github.com/kubex-ecosystem/logz"`: For logging.
- `. "github.com/kubex-ecosystem/xtui/types"`: For custom types.
- `github.com/johnfercher/maroto/pkg/consts`, `p "github.com/johnfercher/maroto/pkg/pdf"`, `props "github.com/johnfercher/maroto/pkg/props"`: For PDF generation.
- `gopkg.in/yaml.v2`: For YAML parsing.
- `os`, `sort`, `strconv`, `strings`: Standard library packages.

#### Types

- **`TableRenderer`**: Struct for rendering tables with various properties like headers, rows, filters, sorting, pagination, etc.
- **`StyleFunc`**: Type definition for a function that returns a `lipgloss.Style` based on row, column, and cell value.

#### Functions

- **`NewTableRenderer`**: Creates a new `TableRenderer` with custom styles and an optional style function.
- **`(k *TableRenderer) Init`**: Initializes the table renderer.
- **`(k *TableRenderer) Update`**: Updates the table renderer based on user input.
- **`(k *TableRenderer) View`**: Returns the string representation of the table for rendering.
- **`(k *TableRenderer) GetHeaders`**: Returns the table headers.
- **`(k *TableRenderer) GetRows`**: Returns the table rows.
- **`(k *TableRenderer) GetArrayMap`**: Returns the table data as a map of arrays.
- **`(k *TableRenderer) GetHashMap`**: Returns the table data as a hash map.
- **`(k *TableRenderer) GetObjectMap`**: Returns the table data as a slice of maps.
- **`(k *TableRenderer) GetByteMap`**: Returns the table data as a map of byte slices.
- **`(k *TableRenderer) RowsNavigate`**: Navigates through the table rows.
- **`(k *TableRenderer) ApplyFilter`**: Applies a filter to the table rows.
- **`(k *TableRenderer) SortRows`**: Sorts the table rows.
- **`(k *TableRenderer) GetCurrentPageRows`**: Returns the rows for the current page.
- **`(k *TableRenderer) ExportToCSV`**: Exports the table data to a CSV file.
- **`(k *TableRenderer) ExportToYAML`**: Exports the table data to a YAML file.
- **`(k *TableRenderer) ExportToJSON`**: Exports the table data to a JSON file.
- **`(k *TableRenderer) ExportToXML`**: Exports the table data to an XML file.
- **`(k *TableRenderer) ExportToExcel`**: Placeholder for exporting the table data to an Excel file.
- **`(k *TableRenderer) ExportToPDF`**: Exports the table data to a PDF file.
- **`(k *TableRenderer) ExportToMarkdown`**: Placeholder for exporting the table data to a Markdown file.
- **`(k *TableRenderer) ToggleColumnVisibility`**: Toggles the visibility of table columns.

#### Execution Functions

- **`GetTableScreenCustom`**: Returns the table screen view with custom styles and an optional style function.
- **`NavigateAndExecuteTableCustom`**: Navigates and executes the table screen with custom styles and an optional style function.
- **`StartTableScreenCustom`**: Starts the table screen with custom styles and an optional style function.
- **`GetTableScreen`**: Returns the table screen view with custom styles.
- **`NavigateAndExecuteTable`**: Navigates and executes the table screen with custom styles.
- **`StartTableScreen`**: Starts the table screen with custom styles.
- **`StartTableScreenFromRenderer`**: Starts the table screen from an existing `TableRenderer`.

This documentation provides an overview of the `table_screen.go` file, its types, functions, and their purposes.

/// examples/example_01.go ///
package examples

import (
	tea "github.com/charmbracelet/bubbletea"
	c "github.com/kubex-ecosystem/xtui/components"
)

type AppModel struct {
	tables       []*c.TableRenderer
	currentTable int
}

func (m *AppModel) Init() tea.Cmd {
	return nil
}

func (m *AppModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch message := msg.(type) {
	case tea.KeyMsg:
		switch message.String() {
		case "ctrl+tab":
			m.currentTable = (m.currentTable + 1) % len(m.tables)
		case "ctrl+shift+tab":
			m.currentTable = (m.currentTable - 1 + len(m.tables)) % len(m.tables)
		case "enter":
			/*config := t*/

			// Abre um formulário baseado na tabela atual e linha selecionada
			//if err := c.ShowForm(/*m.tables[m.currentTable].GetSelectedRow()*/); err != nil {
			// 	return m, err
			//}
		}
	}
	return m, nil
}

func (m *AppModel) View() string {
	return m.tables[m.currentTable].View()
}

/// internal/commands/wrappers.go ///
package commands

import (
	"fmt"
	"os"
	"os/exec"
)

type Command[T any] interface {
	Execute(args []string, callback func(T) error) (T, error)
}

type CommandExecCombinedOutput func([]string, func(interface{}) error) (string, error)
type CommandExec func([]string, func(interface{}) error) (string, error)
type CommandExecFunc func(string, ...string) (string, error)
type CommandExecFuncWithCallback func([]string, func(interface{}) error) (string, error)
type CommandExecFuncWithCallbackAndError func([]string, func(interface{}) error) (string, error)

func executeCommand(cmd string, args ...string) (string, error) {
	command := exec.Command(cmd, args...)
	command.Stdout = os.Stdout
	command.Stderr = os.Stderr
	output, err := command.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("erro ao executar comando: %w", err)
	}
	return string(output), nil
}

/// internal/filesystem/walk.go ///
package filesystem

import (
	"os"
	"path/filepath"
	"strings"
)

type ConfigFile struct {
	Path     string
	Filename string
}

func walkDirectory(root string, depth int) ([]ConfigFile, error) {
	var configFiles []ConfigFile

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Ignorar diretórios ou arquivos ocultos
		if info.IsDir() || strings.HasPrefix(info.Name(), ".") {
			return nil
		}

		// Verificar extensão do arquivo para "config" (ex.: .conf, .json, .yaml, etc.)
		if filepath.Ext(info.Name()) == ".conf" || filepath.Ext(info.Name()) == ".yaml" || filepath.Ext(info.Name()) == ".json" {
			relPath, err := filepath.Rel(root, path)
			if err == nil {
				configFiles = append(configFiles, ConfigFile{Path: relPath, Filename: info.Name()})
			}
		}
		return nil
	})

	// Limitar profundidade (remover arquivos fora do limite)
	if depth > 0 {
		configFiles = filterByDepth(configFiles, depth)
	}

	return configFiles, err
}

func filterByDepth(files []ConfigFile, maxDepth int) []ConfigFile {
	var filteredFiles []ConfigFile
	for _, file := range files {
		segments := strings.Split(filepath.Dir(file.Path), string(filepath.Separator))
		if len(segments) <= maxDepth {
			filteredFiles = append(filteredFiles, file)
		}
	}
	return filteredFiles
}

/// logger/logger.go ///
package logger

import (
	"fmt"
	"reflect"
	"runtime"
	"strings"

	l "github.com/kubex-ecosystem/logz"
)

type gLog struct {
	l.Logger
	gLogLevel LogType
}

var (
	// debug is a boolean that indicates whether to log debug messages.
	debug bool
	// g is the global logger instance.
	g *gLog = &gLog{
		Logger:    l.GetLogger("GoBE - Test"),
		gLogLevel: LogTypeInfo,
	}
)

func init() {
	// Set the debug flag to true for testing purposes.
	debug = false
	// Initialize the global logger instance with a default logger.
	if g.Logger == nil {
		g = &gLog{
			Logger:    l.GetLogger("GoBE - Test"),
			gLogLevel: LogTypeInfo,
		}
	}
}

type LogType string

const (
	LogTypeNotice  LogType = "notice"
	LogTypeInfo    LogType = "info"
	LogTypeDebug   LogType = "debug"
	LogTypeError   LogType = "error"
	LogTypeWarn    LogType = "warn"
	LogTypeFatal   LogType = "fatal"
	LogTypePanic   LogType = "panic"
	LogTypeSuccess LogType = "success"
)

// SetDebug is a function that sets the debug flag for logging.
func SetDebug(d bool) { debug = d }

// LogObjLogger is a function that logs messages with the specified log type.
func LogObjLogger[T any](obj *T, logType string, messages ...string) {
	if obj == nil {
		g.ErrorCtx(fmt.Sprintf("log object (%s) is nil", reflect.TypeFor[T]()), map[string]any{
			"context":  "Log",
			"logType":  logType,
			"object":   obj,
			"msg":      messages,
			"showData": true,
		})
		return
	}
	var lgr l.Logger
	if objValueLogger := reflect.ValueOf(obj).Elem().MethodByName("GetLogger"); !objValueLogger.IsValid() {
		if objValueLogger = reflect.ValueOf(obj).Elem().FieldByName("Logger"); !objValueLogger.IsValid() {
			g.ErrorCtx(fmt.Sprintf("log object (%s) does not have a logger field", reflect.TypeFor[T]()), map[string]any{
				"context":  "Log",
				"logType":  logType,
				"object":   obj,
				"msg":      messages,
				"showData": true,
			})
			return
		} else {
			lgrC := objValueLogger.Convert(reflect.TypeFor[l.Logger]())
			if lgrC.IsNil() {
				lgrC = reflect.ValueOf(g.Logger)
			}
			if lgr = lgrC.Interface().(l.Logger); lgr == nil {
				lgr = g.Logger
			}
		}
	} else {
		//lgrC := objValueLogger.Call(nil)[0].Convert(reflect.TypeFor[l.Logger]())
		//if lgrC.IsNil() {
		//	lgrC = reflect.ValueOf(g.Logger)
		//}
		//if lgr = lgrC.Interface().(l.Logger); lgr == nil {
		lgr = g.Logger
		//}
	}
	pc, file, line, ok := runtime.Caller(1)
	if !ok {
		lgr.ErrorCtx("Log: unable to get caller information", nil)
		return
	}
	funcName := runtime.FuncForPC(pc).Name()
	ctxMessageMap := map[string]any{
		"context":  funcName,
		"file":     file,
		"line":     line,
		"showData": debug,
	}
	fullMessage := strings.Join(messages, " ")
	logType = strings.ToLower(logType)
	if logType != "" {
		if reflect.TypeOf(logType).ConvertibleTo(reflect.TypeFor[LogType]()) {
			lType := LogType(logType)
			ctxMessageMap["logType"] = logType
			logging(lgr, lType, fullMessage, ctxMessageMap)
		} else {
			lgr.ErrorCtx(fmt.Sprintf("logType (%s) is not valid", logType), ctxMessageMap)
		}
	} else {
		lgr.InfoCtx(fullMessage, ctxMessageMap)
	}
}

// Log is a function that logs messages with the specified log type and caller information.
func Log(logType string, messages ...any) {
	pc, file, line, ok := runtime.Caller(1)
	if !ok {
		g.ErrorCtx("Log: unable to get caller information", nil)
		return
	}
	funcName := runtime.FuncForPC(pc).Name()
	ctxMessageMap := map[string]any{
		"context":  funcName,
		"file":     file,
		"line":     line,
		"showData": debug,
	}
	fullMessage := ""
	if len(messages) > 0 {
		fullMessage = fmt.Sprintf("%v", messages[0:])
	}
	logType = strings.ToLower(logType)
	if logType != "" {
		if reflect.TypeOf(logType).ConvertibleTo(reflect.TypeFor[LogType]()) {
			lType := LogType(logType)
			ctxMessageMap["logType"] = logType
			logging(g.Logger, lType, fullMessage, ctxMessageMap)
		} else {
			g.ErrorCtx(fmt.Sprintf("logType (%s) is not valid", logType), ctxMessageMap)
		}
	} else {
		g.InfoCtx(fullMessage, ctxMessageMap)
	}
}

// logging is a helper function that logs messages with the specified log type.
func logging(lgr l.Logger, lType LogType, fullMessage string, ctxMessageMap map[string]interface{}) {
	debugCtx := debug
	if !debugCtx {
		if lType == "error" || lType == "fatal" || lType == "panic" || lType == "debug" {
			// If debug is false, set the debug value based on the logType
			debugCtx = true
		} else {
			debugCtx = false
		}
	}
	ctxMessageMap["showData"] = debugCtx
	switch lType {
	case LogTypeInfo:
		lgr.InfoCtx(fullMessage, ctxMessageMap)
	case LogTypeDebug:
		lgr.DebugCtx(fullMessage, ctxMessageMap)
	case LogTypeError:
		lgr.ErrorCtx(fullMessage, ctxMessageMap)
	case LogTypeWarn:
		lgr.WarnCtx(fullMessage, ctxMessageMap)
	case LogTypeNotice:
		lgr.NoticeCtx(fullMessage, ctxMessageMap)
	case LogTypeSuccess:
		lgr.SuccessCtx(fullMessage, ctxMessageMap)
	case LogTypeFatal:
		lgr.FatalCtx(fullMessage, ctxMessageMap)
	case LogTypePanic:
		lgr.FatalCtx(fullMessage, ctxMessageMap)
	default:
		lgr.InfoCtx(fullMessage, ctxMessageMap)
	}
	debugCtx = debug
}

/// packages/pkgz_apps.go ///
package packages

import (
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/charmbracelet/lipgloss"
	cmp "github.com/kubex-ecosystem/xtui/components"
	gl "github.com/kubex-ecosystem/xtui/logger"
	t "github.com/kubex-ecosystem/xtui/types"
)

// AppInfo show information about an installed application.
type AppInfo struct {
	Name        string // Name
	Version     string // Version
	Method      string // Method
	Status      string // Status
	Description string // Description
}

// AppsTableHandler lida com a tabela de aplicativos.
type AppsTableHandler struct {
	t.TableDataHandler
	apps []AppInfo // Lista de aplicativos
}

// GetHeaders retorna os cabeçalhos da tabela de aplicativos.
// Retorna um slice de strings com os cabeçalhos.
func (h *AppsTableHandler) GetHeaders() []string {
	return []string{"Name", "Version", "Method", "Status", "Description"}
}

// GetRows retorna as linhas da tabela de aplicativos.
// Retorna um slice de slices de strings com as linhas da tabela.
func (h *AppsTableHandler) GetRows() [][]string {
	var rows [][]string //nolint:prealloc
	for _, app := range h.apps {
		rows = append(rows, []string{app.Name, app.Version, app.Method, app.Status, app.Description})
	}
	return rows
}

// CheckDeps verifica se as dependências estão instaladas.
// Recebe o caminho do arquivo de validação e a versão.
// Retorna um booleano indicando se as dependências estão instaladas.
func CheckDeps(validationFilePath string, version string) bool {
	validationFilePath = fmt.Sprintf("%s_%s", validationFilePath, version)
	_, err := os.Stat(validationFilePath)
	return err == nil
}

// GenDepsScript gera um script para verificar e instalar dependências.
// Recebe uma lista de dependências, o caminho do script, o caminho do arquivo de validação e a versão.
// Retorna um erro, se houver.
func GenDepsScript(depsList []string, scriptPath string, validationFilePath string, version string) error {
	validationFilePath = fmt.Sprintf("%s_%s", validationFilePath, version)
	scriptContent := `#!/bin/bash

	# Função para verificar se um comando está disponível
	command_exists() {
	    dpkg -l "$1" &> /dev/null
	}

	# Lista de dependências
	dependencies=(
	`
	if len(depsList) == 0 {
		gl.Log("error", "Dependencies list is empty")
		return fmt.Errorf("lista de dependências vazia")
	}
	for _, dep := range depsList {
		scriptContent += fmt.Sprintf("    \"%s\"\n", dep)
	}
	scriptContent += `)

	# Verifica e instala dependências
	for dep in "${dependencies[@]}"; do
	    if ! command_exists $dep; then
	        echo "$dep não está instalado. Deseja instalar? (s/n)"
	        read -r response
	        if [[ "$response" == "s" ]]; then
	            sudo apt-get update
	            sudo apt-get install -y $dep
	        else
	            echo "Instalação de $dep cancelada."
	        fi
	    else
	        echo "$dep já está instalado."
	    fi
	done

	# Cria arquivo de validação
	mkdir -p $(dirname ` + validationFilePath + `)
	touch ` + validationFilePath + `

	echo "Todas as dependências foram verificadas e instaladas."

	sleep 3

	printf "\033[H\033[2J"

	`
	err := os.WriteFile(scriptPath, []byte(scriptContent), 0755) //nolint:gosec
	if err != nil {
		gl.Log("error", "Error writing deps script: "+err.Error())
		return fmt.Errorf("erro ao escrever o script de dependências")
	}
	return nil
}

// InstallAppsShell executa um script de instalação de aplicativos.
// Recebe o caminho do script.
// Retorna um erro, se houver.
func InstallAppsShell(scriptPath string) error {
	if scriptPath == "" {
		return fmt.Errorf("caminho do script de instalação não informado")
	}
	cmd := exec.Command("bash", scriptPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin // Permite interação do usuário
	err := cmd.Run()
	if err != nil {
		gl.Log("error", "Error running deps script: "+err.Error())
		return err
	}
	return nil
}

// InstallApps instala aplicativos usando a interface do usuário.
// Recebe uma lista de argumentos.
// Retorna um erro, se houver.
func InstallApps(args ...string) error {
	return InstallDepsWithUI(args...)
}

// getInstalledAppsHandler obtém os aplicativos instalados filtrados por nome, status ou método de instalação.
// Recebe o nome, status e método de instalação.
// Retorna um ponteiro para AppsTableHandler e um erro, se houver.
func getInstalledAppsHandler(name string, status string, method string) (t.TableDataHandler, error) {
	// Filtra os aplicativos instalados por nome, status ou method de instalação (auto/manual) usando dpkg-query e se preciso grep
	//nameFilter := ""
	//if name != "" {
	//	nameFilter = fmt.Sprintf("| grep -i %s", name)
	//}
	//statusFilter := ""
	//if status != "" {
	//	statusFilter = fmt.Sprintf("| grep -i %s", status)
	//}
	//methodFilter := ""
	//if method != "" {
	//	methodFilter = fmt.Sprintf("| grep -i %s", method)
	//}
	cmd := exec.Command("bash", "-c", fmt.Sprintf("dpkg-query -W -f='${Package}\\t${Version}\\t${Status}\\t${Description}\\n'")) //nolint:gosec
	output, err := cmd.Output()
	if err != nil {
		gl.Log("error", "Error getting installed apps: "+err.Error())
		return nil, fmt.Errorf("erro ao obter aplicativos instalados")
	}
	var apps []AppInfo //nolint:prealloc
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if line == "" {
			continue
		}
		fields := strings.SplitN(line, "\t", 4)
		if len(fields) < 4 {
			continue
		}

		status := "installed"
		if strings.Contains(fields[2], "deinstall") {
			status = "residual"
		}

		apps = append(apps, AppInfo{
			Name:        fields[0],
			Version:     fields[1],
			Method:      "auto", // Assumindo que todos são automáticos, pode ser ajustado conforme necessário
			Status:      status,
			Description: fields[3],
		})
	}

	return &AppsTableHandler{apps: apps}, nil
}

// ShowInstalledAppsTable exibe a tabela de aplicativos instalados.
// Recebe uma lista de argumentos.
// Retorna um erro, se houver.
func ShowInstalledAppsTable(args ...string) error {
	name := ""
	if len(args) > 0 {
		name = args[0]
	}
	status := ""
	if len(args) > 1 {
		status = args[1]
	}
	method := ""
	if len(args) > 2 {
		method = args[2]
	}
	handler, err := getInstalledAppsHandler(name, status, method)
	if err != nil {
		return err
	}
	customStyles := map[string]lipgloss.Color{
		"header": lipgloss.Color("#01BE85"),
		"row":    lipgloss.Color("#252"),
	}

	return cmp.StartTableScreen(handler, customStyles)
}

// installGoogleAuthenticator instala o Google Authenticator.
// Retorna um erro, se houver.
func installGoogleAuthenticator() error {
	cmd := exec.Command("sudo", "apt-get", "install", "-y", "libpam-google-authenticator")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

/// packages/tuiz_application_mgr.go ///
package packages

import (
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/charmbracelet/bubbles/progress"
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	gl "github.com/kubex-ecosystem/xtui/logger"
)

type KbxDepsModel struct {
	apps     []string
	path     string
	yes      bool
	quiet    bool
	index    int
	width    int
	height   int
	spinner  spinner.Model
	progress progress.Model
	done     bool
}

var (
	kbxDepsCurrentPkgNameStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("202"))
	kbxDepsDoneStyle           = lipgloss.NewStyle()
	kbxDepsCheckMark           = lipgloss.NewStyle().Foreground(lipgloss.Color("42")).SetString("✓")
)

func KbxDepsNewModel(apps []string, path string, yes bool, quiet bool) KbxDepsModel {
	p := progress.New(
		progress.WithScaledGradient("#F72100", "#F66600"),
		progress.WithWidth(40),
		progress.WithoutPercentage(),
	)
	s := spinner.New()
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("202"))
	return KbxDepsModel{
		apps:     apps,
		path:     path,
		yes:      yes,
		quiet:    quiet,
		spinner:  s,
		progress: p,
	}
}

func (m *KbxDepsModel) Init() tea.Cmd {
	return tea.Batch(kbxDepsDownloadAndInstall(m.apps[m.index], m.path, m.yes, m.quiet))
}

func (m *KbxDepsModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width, m.height = msg.Width, msg.Height
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "esc", "q":
			return m, tea.Quit
		}
	case kbxDepsInstalledPkgMsg:
		if m.index >= len(m.apps)-1 {
			m.done = true
			return m, tea.Quit
		}

		m.index++
		progressCmd := m.progress.SetPercent(float64(m.index+1) / float64(len(m.apps)))

		return m, tea.Batch(
			progressCmd,
			kbxDepsDownloadAndInstall(m.apps[m.index], m.path, m.yes, m.quiet),
		)
	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		return m, cmd
	case progress.FrameMsg:
		kbxDepsNewModel, cmd := m.progress.Update(msg)
		if kbxDepsNewModel, ok := kbxDepsNewModel.(progress.Model); ok {
			m.progress = kbxDepsNewModel
		}
		return m, cmd
	}
	return m, nil
}

func (m *KbxDepsModel) View() string {
	n := len(m.apps)
	w := lipgloss.Width(fmt.Sprintf("%d", n))

	depCount := fmt.Sprintf(" %*d/%*d", w, m.index+1, w, n)

	spin := m.spinner.View() + " "
	prog := m.progress.View()
	cellsAvail := kbxDepsMax(0, m.width-lipgloss.Width(spin+prog+depCount))

	infoMsg := lipgloss.NewStyle().Foreground(lipgloss.Color("6")).Render("Installation progress: ")
	info := lipgloss.NewStyle().MaxWidth(cellsAvail).Render("[pkgz] " + infoMsg + prog + depCount)

	cellsRemaining := kbxDepsMax(0, m.width-lipgloss.Width(info+spin))
	gap := strings.Repeat(" ", cellsRemaining)

	if m.done {
		depsQty := lipgloss.NewStyle().Foreground(lipgloss.Color("6")).Render(fmt.Sprintf("%d", n))
		return info + gap + "\n" + m.renderInstalledApps() + kbxDepsDoneStyle.Render(fmt.Sprintf("[pkgz] Done! Installed %s applications.\n", depsQty))
	}

	return info + gap + "\n" + m.renderInstalledApps()
}

func (m *KbxDepsModel) renderInstalledApps() string {
	var installedApps strings.Builder
	for i := 0; i < m.index+1; i++ {
		dep := m.apps[i]
		depRendered := kbxDepsCurrentPkgNameStyle.Render(dep)
		// Insere um ícone que simbolize a instalação do pacote
		infoBadge := lipgloss.NewStyle().Inline(true).Render("[XTui] 📦 -> ")
		infoMsg := lipgloss.NewStyle().Inline(true).Foreground(lipgloss.Color("6")).Render("Installed application: ")
		installedApps.WriteString(fmt.Sprintf("%s%s%s %s\n", infoBadge, infoMsg, kbxDepsCheckMark, depRendered))
	}
	return installedApps.String()
}

type kbxDepsInstalledPkgMsg string

func kbxDepsDownloadAndInstall(dep string, path string, yes bool, quiet bool) tea.Cmd {
	return func() tea.Msg {
		pkg := dep
		if strings.Contains(dep, "/") {
			pkg = strings.Split(dep, "/")[1]
		}
		pathFlag := ""
		if path != "" {
			pathFlag = "-p " + path
		}
		yesFlag := ""
		if yes {
			yesFlag = "-y"
		}
		quietFlag := ""
		if quiet {
			quietFlag = "-qq"
		}
		cmd := exec.Command("sudo", "apt-get", "install", pkg, pathFlag, yesFlag, quietFlag)
		stdin := strings.NewReader("s\n")
		cmd.Stdout = Writer("XTui")
		cmd.Stdin = stdin
		if err := cmd.Run(); err != nil {
			log.Println("error installing application: "+dep+" "+err.Error(), "XTui")
			return tea.Quit()
		}
		return kbxDepsInstalledPkgMsg(dep)
	}
}

func kbxDepsMax(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// InstallDepsWithUI installs dependencies in a terminal UI with a progress bar
func InstallDepsWithUI(args ...string) error {
	if len(args) < 4 {
		gl.Log("error", "missing arguments")
		return nil
	}
	apps := strings.Split(args[0], " ")
	if len(apps) == 0 {
		gl.Log("error", "no applications requested")
		return nil
	}
	path := args[1]
	yes := args[2] == "true"
	quiet := args[3] == "true"
	model := KbxDepsNewModel(apps, path, yes, quiet)
	p := tea.NewProgram(&model)
	_, err := p.Run()
	defer p.Quit()
	if err != nil {
		gl.Log("error", "error running dependencies installation: "+err.Error())
		return nil
	}
	return nil
}

func Writer(module string) io.Writer {
	currentPid := os.Getpid()
	logFileName := strings.Join([]string{module, "logz_", strconv.Itoa(currentPid), ".log"}, "")
	cacheDir, cacheDirErr := os.UserCacheDir()
	if cacheDirErr != nil || cacheDir == "" {
		cacheDir = os.TempDir()
	}
	logFilePath := filepath.Join(cacheDir, logFileName)
	if logFileStatErr := os.Remove(logFilePath); logFileStatErr == nil {
		cmdRm := fmt.Sprintf("rm -f %s", logFilePath)
		if _, cmdRmErr := exec.Command("bash", "-c", cmdRm).Output(); cmdRmErr != nil {
			fmt.Println(cmdRmErr)
			return os.Stdout
		}
	}
	if logFilePathErr := os.MkdirAll(filepath.Dir(logFilePath), 0777); logFilePathErr != nil {
		fmt.Println(logFilePathErr)
		return os.Stdout
	}
	logFile, logFileErr := os.OpenFile(logFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0777)
	if logFileErr != nil {
		fmt.Println(logFileErr)
		return os.Stdout
	}
	return logFile
}

/// services/tuiz_daemonize.go ///
package services

import (
	"flag"
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/mattn/go-isatty"
	"io"
	"log"
	"os"
)

var (
	helpStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Render
	mainStyle = lipgloss.NewStyle().MarginLeft(1)
)

type DaemonizeModel struct {
	spinner  spinner.Model
	quitting bool
	initFunc func() tea.Msg
}

func DaemonizeNewModel(initFunc func() tea.Msg) DaemonizeModel {
	sp := spinner.New()
	sp.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("206"))

	return DaemonizeModel{
		spinner:  sp,
		initFunc: initFunc,
	}
}

func (m DaemonizeModel) Init() tea.Cmd {
	log.Println("Starting work...")
	return tea.Batch(
		m.spinner.Tick,
		m.initFunc,
	)
}

func (m DaemonizeModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		m.quitting = true
		return m, tea.Quit
	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		return m, cmd
	case error:
		log.Printf("Error: %v", msg)
		return m, tea.Quit
	default:
		return m, nil
	}
}

func (m DaemonizeModel) View() string {
	s := "\n" +
		m.spinner.View() + " Running daemon...\n\n"

	s += helpStyle("\nPress any key to exit\n")

	if m.quitting {
		s += "\n"
	}

	return mainStyle.Render(s)
}

func Daemonize(initFunc func() tea.Msg, args ...string) error {
	var (
		daemonMode bool
		showHelp   bool
		opts       []tea.ProgramOption
	)

	flag.BoolVar(&daemonMode, "d", false, "run as a daemon")
	flag.BoolVar(&showHelp, "h", false, "show help")
	flag.Parse()

	if showHelp {
		flag.Usage()
		return nil
	}

	if daemonMode || !isatty.IsTerminal(os.Stdout.Fd()) {
		opts = []tea.ProgramOption{tea.WithoutRenderer()}
	} else {
		log.SetOutput(io.Discard)
	}

	p := tea.NewProgram(DaemonizeNewModel(initFunc), opts...)
	if _, err := p.Run(); err != nil {
		return err
	}

	return nil
}

/// services/tuiz_tcp_status.go ///
package services

import (
	"fmt"
	"net/http"
	"time"

	tea "github.com/charmbracelet/bubbletea"
)

var tcpStatusUrl string

type TcpStatusModel struct {
	status int
	err    error
}

type tcpStatusStatusMsg int

type tcpStatusErrMsg struct{ error }

func (e tcpStatusErrMsg) Error() string { return e.error.Error() }

func TcpStatus(args ...string) error {
	if len(args) != 1 {
		return fmt.Errorf("usage: tcp-status <url>")
	}
	tcpStatusUrl = args[0]
	p := tea.NewProgram(TcpStatusModel{})
	if _, err := p.Run(); err != nil {
		return err
	}
	return nil
}

func (m TcpStatusModel) Init() tea.Cmd {
	return tcpStatusCheckServer
}

func (m TcpStatusModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "q", "ctrl+c", "esc":
			return m, tea.Quit
		default:
			return m, nil
		}

	case tcpStatusStatusMsg:
		m.status = int(msg)
		return m, tea.Quit

	case tcpStatusErrMsg:
		m.err = msg
		return m, nil

	default:
		return m, nil
	}
}

func (m TcpStatusModel) View() string {
	s := fmt.Sprintf("Checking %s...", tcpStatusUrl)
	if m.err != nil {
		s += fmt.Sprintf("something went wrong: %s", m.err)
	} else if m.status != 0 {
		s += fmt.Sprintf("%d %s", m.status, http.StatusText(m.status))
	}
	return s + "\n"
}

func tcpStatusCheckServer() tea.Msg {
	c := &http.Client{
		Timeout: 10 * time.Second,
	}
	res, err := c.Get(tcpStatusUrl)
	if err != nil {
		return tcpStatusErrMsg{err}
	}
	defer res.Body.Close() // nolint:errcheck

	return tcpStatusStatusMsg(res.StatusCode)
}

/// support/composer.sh ///
#!/bin/bash

# Define o diretório base
BASE_DIR="lib"

# Lista de arquivos a serem criados
FILES=(
  "config.sh"
  "utils.sh"
  "platform.sh"
  "build.sh"
  "validate.sh"
  "install_funcs.sh"
  "info.sh"
)

# Cria o diretório base, se ainda não existir
mkdir -p "$BASE_DIR"

# Cria os arquivos dentro do diretório
for file in "${FILES[@]}"; do
  FILE_PATH="$BASE_DIR/$file"
  if [[ ! -f "$FILE_PATH" ]]; then
    touch "$FILE_PATH"
    printf '%s' "#!/bin/bash" | tee "$FILE_PATH" >/dev/null
    printf '%s' "# $file - script placeholder" | tee -a "$FILE_PATH" >/dev/null
    chmod +x "$FILE_PATH"
    echo "Criado: $FILE_PATH"
  else
    echo "Já existe: $FILE_PATH"
  fi
done


/// support/config.sh ///
#!/usr/bin/env bash

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

# Define o diretório raiz (assumindo que este script está em lib/ no root)
_ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
_APP_NAME="${APP_NAME:-$(basename "${_ROOT_DIR}")}"
_PROJECT_NAME="$_APP_NAME"
_OWNER="${OWNER:-rafa-mori}"
# Tenta ler a versão, ou define um fallback
_VERSION=$(cat "$_ROOT_DIR/version/CLI_VERSION" 2>/dev/null || echo "v0.0.0")
# Extrai a versão do Go do go.mod (certifique-se de que este arquivo exista na raiz)
_VERSION_GO=$(grep '^go ' "$_ROOT_DIR/go.mod" | awk '{print $2}')

_LICENSE="MIT"

_ABOUT="################################################################################
  Este script instala o projeto ${_PROJECT_NAME}, versão ${_VERSION}.
  OS suportados: Linux, MacOS, Windows
  Arquiteturas suportadas: amd64, arm64, 386
  Fonte: https://github.com/${_OWNER}/${_PROJECT_NAME}
  Binary Release: https://github.com/${_OWNER}/${_PROJECT_NAME}/releases/latest
  License: ${_LICENSE}
  Notas:
    - [version] é opcional; se omitido, a última versão será utilizada.
    - Se executado localmente, o script tentará resolver a versão pelos tags do repositório.
    - Instala em ~/.local/bin para usuário não-root ou em /usr/local/bin para root.
    - Adiciona o diretório de instalação à variável PATH.
    - Instala o UPX se necessário, ou compila o binário (build) conforme o comando.
    - Faz download do binário via URL de release ou efetua limpeza de artefatos.
    - Verifica dependências e versão do Go.
################################################################################"

_BANNER="################################################################################

               ██   ██ ██     ██ ██████   ████████ ██     ██
              ░██  ██ ░██    ░██░█░░░░██ ░██░░░░░ ░░██   ██
              ░██ ██  ░██    ░██░█   ░██ ░██       ░░██ ██
              ░████   ░██    ░██░██████  ░███████   ░░███
              ░██░██  ░██    ░██░█░░░░ ██░██░░░░     ██░██
              ░██░░██ ░██    ░██░█    ░██░██        ██ ░░██
              ░██ ░░██░░███████ ░███████ ░████████ ██   ░░██
              ░░   ░░  ░░░░░░░  ░░░░░░░  ░░░░░░░░ ░░     ░░"

# Caminhos para a compilação
_CMD_PATH="$_ROOT_DIR/cmd"
_BUILD_PATH="$(dirname "$_CMD_PATH")"
_BINARY="$_BUILD_PATH/$_APP_NAME"

# Diretórios de instalação
_LOCAL_BIN="${HOME:-"~"}/.local/bin"
_GLOBAL_BIN="/usr/local/bin"

# Caso queira, defina o OWNER (use no get_release_url)
_OWNER="rafa-mori"

/// support/info.sh ///
#!/usr/bin/env bash
# lib/info.sh – Funções para exibir banners e resumo de instalação

show_about() {
    printf '%s\n\n' "${_ABOUT:-}"
}

show_banner() {
    printf '\n%s\n\n' "${_BANNER:-}"
}

show_headers() {
    show_banner || return 1
    show_about || return 1
}

summary() {
    local install_dir="$_BINARY"
    log success "Build e instalação concluídos!"
    log success "Binário: $_BINARY"
    log success "Instalado em: ${install_dir}"
    check_path "$install_dir"
}

export -f show_about
export -f show_banner
export -f show_headers
export -f summary


/// support/install.sh ///
#!/usr/bin/env bash
# shellcheck disable=SC2065,SC2015

# Script Metadata
__secure_logic_version="1.0.0"
__secure_logic_date="$( date +%Y-%m-%d )"
__secure_logic_author="Rafael Mori"
__secure_logic_use_type="exec"
__secure_logic_init_timestamp="$(date +%s)"
__secure_logic_elapsed_time=0

# Check if verbose mode is enabled
if [[ "${MYNAME_VERBOSE:-false}" == "true" ]]; then
  set -x  # Enable debugging
fi

IFS=$'\n\t'

__secure_logic_sourced_name() {
  local _self="${BASH_SOURCE-}"
  _self="${_self//${_kbx_root:-$()}/}"
  _self="${_self//\.sh/}"
  _self="${_self//\-/_}"
  _self="${_self//\//_}"
  echo "_was_sourced_${_self//__/_}"
  return 0
}

__first(){
  if [ "$EUID" -eq 0 ] || [ "$UID" -eq 0 ]; then
    echo "Please do not run as root." 1>&2 > /dev/tty
    exit 1
  elif [ -n "${SUDO_USER:-}" ]; then
    echo "Please do not run as root, but with sudo privileges." 1>&2 > /dev/tty
    exit 1
  else
    # shellcheck disable=SC2155
    local _ws_name="$(__secure_logic_sourced_name)"

    if test "${BASH_SOURCE-}" != "${0}"; then
      if test $__secure_logic_use_type != "lib"; then
        echo "This script is not intended to be sourced." 1>&2 > /dev/tty
        echo "Please run it directly." 1>&2 > /dev/tty
        exit 1
      fi
      # If the script is sourced, we set the variable to true
      # and export it to the environment without changing
      # the shell options.
      export "${_ws_name}"="true"
    else
      if test $__secure_logic_use_type != "exec"; then
        echo "This script is not intended to be executed directly." 1>&2 > /dev/tty
        echo "Please source it instead." 1>&2 > /dev/tty
        exit 1
      fi
      # If the script is executed directly, we set the variable to false
      # and export it to the environment. We also set the shell options
      # to ensure a safe execution.
      export "${_ws_name}"="false"
      set -o errexit # Exit immediately if a command exits with a non-zero status
      set -o nounset # Treat unset variables as an error when substituting
      set -o pipefail # Return the exit status of the last command in the pipeline that failed
      set -o errtrace # If a command fails, the shell will exit immediately
      set -o functrace # If a function fails, the shell will exit immediately
      shopt -s inherit_errexit # Inherit the errexit option in functions
    fi
  fi
}

_DEBUG=${DEBUG:-false}
_HIDE_ABOUT=${HIDE_ABOUT:-false}

__first "$@" >/dev/tty || exit 1

# Carrega os arquivos de biblioteca
_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
#shellcheck source=/dev/null
test -z "${_BANNER:-}" && source "${_SCRIPT_DIR}/config.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f log)" >/dev/null && source "${_SCRIPT_DIR}/utils.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f what_platform)" >/dev/null && source "${_SCRIPT_DIR}/platform.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f check_dependencies)" >/dev/null && source "${_SCRIPT_DIR}/validate.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f detect_shell_rc)" >/dev/null && source "${_SCRIPT_DIR}/install_funcs.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f build_binary)" >/dev/null && source "${_SCRIPT_DIR}/build.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f show_banner)" >/dev/null && source "${_SCRIPT_DIR}/info.sh" || true

# Inicializa os traps
set_trap "$@"

clear_screen

__main() {
  if ! what_platform; then
    log error "Plataforma não suportada: ${_PLATFORM}"
    exit 1
  fi

  if [[ "${_DEBUG}" != true ]]; then
    show_headers
    if [[ -z "${_HIDE_ABOUT}" ]]; then
      show_about
    fi
  else
    log info "Modo debug ativado; banner será ignorado..."
    if [[ -z "${_HIDE_ABOUT}" ]]; then
      show_about
    fi
  fi

  _ARGS=( "$@" )
  local default_label='Auto detect'
  local arrArgs=( "${_ARGS[@]:0:$#}" )
  local PLATFORM_ARG
  PLATFORM_ARG=$(_get_os_from_args "${arrArgs[1]:-${_PLATFORM}}")
  local ARCH_ARG
  ARCH_ARG=$(_get_arch_arr_from_args "${arrArgs[2]:-${_ARCH}}")

  log info "Comando: ${arrArgs[0]:-}" true
  log info "Plataforma: ${PLATFORM_ARG:-$default_label}" true
  log info "Arquitetura: ${ARCH_ARG:-$default_label}" true
  log info "Args: ${_ARGS[*]:-}" true

  case "${arrArgs[0]:-}" in
    build|BUILD|-b|-B)
      # validate_versions
      log info "Executando comando de build..."
      build_binary "${PLATFORM_ARG}" "${ARCH_ARG}" || exit 1
      ;;
    install|INSTALL|-i|-I)
      log info "Executando comando de instalação..."
      read -r -p "Deseja baixar o binário pré-compilado? [y/N] (Caso contrário, fará build local): " choice </dev/tty
      log info "Escolha do usuário: ${choice}"
      if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
          log info "Baixando binário pré-compilado..."
          install_from_release
      else
          log info "Realizando build local..."
          validate_versions
          build_binary "${PLATFORM_ARG}" "${ARCH_ARG}" || exit 1
          install_binary
      fi
      summary
      ;;
    clear|clean|CLEAN|-c|-C)
      log info "Executando comando de limpeza..."
      clean_artifacts
      log success "Clean executado com sucesso."
      ;;
    *)
      log error "Comando inválido: ${arrArgs[0]:-}"
      echo "Uso: $0 {build|install|clean}"
      ;;
  esac
}

# Função para limpar artefatos de build
clean_artifacts() {
    log info "Limpando artefatos de build..."
    local platforms=("windows" "darwin" "linux")
    local archs=("amd64" "386" "arm64")
    for platform in "${platforms[@]}"; do
        for arch in "${archs[@]}"; do
            local output_name
            output_name=$(printf '%s_%s_%s' "${_BINARY}" "${platform}" "${arch}")
            if [[ "${platform}" != "windows" ]]; then
                local compress_name="${output_name}.tar.gz"
            else
                output_name="${output_name}.exe"
                local compress_name="${_BINARY}_${platform}_${arch}.zip"
            fi
            rm -f "${output_name}" || true
            rm -f "${compress_name}" || true
        done
    done
    log success "Artefatos de build removidos."
}

__secure_logic_main() {
  local _ws_name
  _ws_name="$(__secure_logic_sourced_name)"
  local _ws_name_val
  _ws_name_val=$(eval "echo \${$_ws_name}")
  if test "${_ws_name_val}" != "true"; then
    __main "$@"
    return $?
  else
    # If the script is sourced, we export the functions
    log error "This script is not intended to be sourced."
    log error "Please run it directly."
    return 1
  fi
}

# echo "MAKE ARGS: ${ARGS[*]:-}"
log info "Starting installation script..."
__secure_logic_main "$@"

__secure_logic_elapsed_time="$(($(date +%s) - __secure_logic_init_timestamp))"

if [[ "${MYNAME_VERBOSE:-false}" == "true" || "${_DEBUG:-false}" == "true" ]]; then
  log info "Script executed in ${__secure_logic_elapsed_time} seconds."
fi

# End of script logic

/// support/install_funcs.sh ///
#!/usr/bin/env bash
# lib/install_funcs.sh – Funções para instalação e manipulação de PATH

install_upx() {
    if ! command -v upx &> /dev/null; then
        if ! sudo -v &> /dev/null; then
            log error "Você não tem permissões de superusuário para instalar o empacotador de binários."
            log warn "Se deseja o empacotamento de binários, instale o UPX manualmente."
            log warn "Veja: https://upx.github.io/"
            return 1
        fi
        if [[ "$(uname)" == "Darwin" ]]; then
            brew install upx >/dev/null
        elif command -v apt-get &> /dev/null; then
            sudo apt-get install -y upx >/dev/null
        elif command -v yum &> /dev/null; then
            sudo yum install -y upx >/dev/null
        elif command -v dnf &> /dev/null; then
            sudo dnf install -y upx >/dev/null
        elif command -v pacman &> /dev/null; then
            sudo pacman -S --noconfirm upx >/dev/null
        elif command -v zypper &> /dev/null; then
            sudo zypper install -y upx >/dev/null
        elif command -v apk &> /dev/null; then
            sudo apk add upx >/dev/null
        elif command -v port &> /dev/null; then
            sudo port install upx >/dev/null
        elif command -v snap &> /dev/null; then
            sudo snap install upx >/dev/null
        elif command -v flatpak &> /dev/null; then
            sudo flatpak install flathub org.uptane.upx -y >/dev/null
        else
            log warn "Se deseja o empacotamento de binários, instale o UPX manualmente."
            log warn "Veja: https://upx.github.io/"
            return 1
        fi
    fi

    return 0
}

detect_shell_rc() {
    local shell_rc_file
    local user_shell
    user_shell=$(basename "$SHELL")

    case "$user_shell" in
        bash) shell_rc_file="${HOME:-~}/.bashrc" ;;
        zsh) shell_rc_file="${HOME:-~}/.zshrc" ;;
        sh) shell_rc_file="${HOME:-~}/.profile" ;;
        fish) shell_rc_file="${HOME:-~}/.config/fish/config.fish" ;;
        *)
            log warn "Shell não suportado; ajuste o PATH manualmente."
            return 1
            ;;
    esac

    if [ ! -f "$shell_rc_file" ]; then
        log error "Arquivo de configuração não encontrado: ${shell_rc_file}"
        return 1
    fi

    echo "$shell_rc_file"

    return 0
}

add_to_path() {
    local target_path="${1:-}"

    local shell_rc_file=""

    local path_expression=""

    path_expression="export PATH=\"${target_path}:\$PATH\""

    shell_rc_file="$(detect_shell_rc)"


    if [ -z "$shell_rc_file" ]; then
        log error "Não foi possível identificar o arquivo de configuração do shell."
        return 1
    fi
    if grep -q "${path_expression}" "$shell_rc_file" 2>/dev/null; then
        log success "$target_path já está no PATH do $shell_rc_file."
        return 0
    fi

    if [[ -z "${target_path}" ]]; then
        log error "Caminho de destino não fornecido."
        return 1
    fi

    if [[ ! -d "${target_path}" ]]; then
        log error "Caminho de destino não é um diretório válido: $target_path"
        return 1
    fi

    if [[ ! -f "${shell_rc_file}" ]]; then
        log error "Arquivo de configuração não encontrado: ${shell_rc_file}"
        return 1
    fi

    # echo "export PATH=${target_path}:\$PATH" >> "$shell_rc_file"
    printf '%s\n' "${path_expression}" | tee -a "$shell_rc_file" >/dev/null || {
        log error "Falha ao adicionar $target_path ao PATH em $shell_rc_file."
        return 1
    }

    log success "Adicionado $target_path ao PATH em $shell_rc_file."

    "$SHELL" -c "source ${shell_rc_file}" || {
        log warn "Falha ao recarregar o shell. Por favor, execute 'source ${shell_rc_file}' manualmente."
    }

    return 0
}

install_binary() {
    local SUFFIX="${_PLATFORM_WITH_ARCH}"
    local BINARY_TO_INSTALL="${_BINARY}${SUFFIX:+_${SUFFIX}}"
    log info "Instalando o binário: '${BINARY_TO_INSTALL}' como '$_APP_NAME'"

    if [ "$(id -u)" -ne 0 ]; then
        log info "Usuário não-root detectado. Instalando em ${_LOCAL_BIN}..."
        mkdir -p "$_LOCAL_BIN"
        cp "$BINARY_TO_INSTALL" "$_LOCAL_BIN/$_APP_NAME" || exit 1
        add_to_path "$_LOCAL_BIN"
    else
        log info "Usuário root detectado. Instalando em ${_GLOBAL_BIN}..."
        cp "$BINARY_TO_INSTALL" "$_GLOBAL_BIN/$_APP_NAME" || exit 1
        add_to_path "$_GLOBAL_BIN"
    fi
}

download_binary() {
    if ! what_platform; then
        log error "Falha ao detectar a plataforma."
        return 1
    fi
    if [[ -z "${_PLATFORM}" ]]; then
        log error "Plataforma não suportada: ${_PLATFORM}"
        return 1
    fi
    local version
    version=$(curl -s "https://api.github.com/repos/${_OWNER}/${_PROJECT_NAME}/releases/latest" | grep "tag_name" | cut -d '"' -f 4 || echo "latest")
    if [ -z "$version" ]; then
        log error "Falha ao determinar a última versão."
        return 1
    fi

    local release_url
    release_url=$(get_release_url)
    log info "Baixando o binário ${_APP_NAME} para OS=${_PLATFORM}, ARCH=${_ARCH}, Versão=${version}..."
    log info "URL de Release: ${release_url}"

    local archive_path="${_TEMP_DIR}/${_APP_NAME}.tar.gz"
    if ! curl -L -o "${archive_path}" "${release_url}"; then
        log error "Falha ao baixar o binário de: ${release_url}"
        return 1
    fi
    log success "Binário baixado com sucesso."

    log info "Extraindo o binário para: $(dirname "${_BINARY}")"
    if ! tar -xzf "${archive_path}" -C "$(dirname "${_BINARY}")"; then
        log error "Falha ao extrair o binário de: ${archive_path}"
        rm -rf "${_TEMP_DIR}"
        exit 1
    fi

    rm -rf "${_TEMP_DIR}"
    log success "Binário extraído com sucesso."

    if [ ! -f "$_BINARY" ]; then
        log error "Binário não encontrado após extração: ${_BINARY}"
        exit 1
    fi
    log success "Download e extração de ${_APP_NAME} concluídos!"
}

install_from_release() {
    download_binary
    install_binary
}

check_path() {
    log info "Verificando se o diretório de instalação está no PATH..."
    if ! echo "$PATH" | grep -q "$1"; then
        log warn "$1 não está no PATH."
        log warn "Adicione: export PATH=$1:\$PATH"
    else
        log success "$1 já está no PATH."
    fi
}

export -f install_upx
export -f detect_shell_rc
export -f add_to_path
export -f install_binary
export -f download_binary
export -f install_from_release
export -f check_path

/// support/platform.sh ///
#!/usr/bin/env bash

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

get_release_url() {
    local os="${_PLATFORM%%-*}"
    local format
    if [[ "$os" == "windows" ]]; then
      format="zip"
    else
      format="tar.gz"
    fi
    echo "'https://github.com/${_OWNER}/${_PROJECT_NAME}/releases/download/${_VERSION}/${_PROJECT_NAME}_.${format}'"
}

what_platform() {
  local _os
  _os="$(uname -s)"
  local _arch
  _arch="$(uname -m)"
  local platform=""

  case "${_os}" in
  *Linux*|*Nix*)
    _os="linux"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "armv6") _arch="armv6l" ;;
      "armv8"|"aarch64") _arch="arm64" ;;
      *386*) _arch="386" ;;
    esac
    platform="linux-${_arch}"
    ;;
  *Darwin*)
    _os="darwin"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "arm64") _arch="arm64" ;;
    esac
    platform="darwin-${_arch}"
    ;;
  MINGW*|MSYS*|CYGWIN*|Win*)
    _os="windows"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "arm64") _arch="arm64" ;;
    esac
    platform="windows-${_arch}"
    ;;
  *)
    log error "Plataforma não suportada: ${_os} ${_arch}"
    log error "Informe este problema aos mantenedores do projeto."
    return 1
    ;;
  esac

  export _PLATFORM_WITH_ARCH="${platform//-/_}"
  export _PLATFORM="${_os}"
  export _ARCH="${_arch}"

  return 0
}

_get_os_arr_from_args() {
  local _PLATFORM_ARG=$1
  if [[ "${_PLATFORM_ARG}" == "all" ]]; then
    echo "windows darwin linux"
  else
    echo "${_PLATFORM_ARG}"
  fi
}

_get_arch_arr_from_args() {
  local _ARCH_ARG=$1
  if [[ "${_ARCH_ARG}" == "all" ]]; then
    echo "amd64 386 arm64"
  else
    echo "${_ARCH_ARG}"
  fi
}

_get_os_from_args() {
  local arg=$1
  case "$arg" in
    all|ALL|a|A|-a|-A) echo "all" ;;
    win|WIN|windows|WINDOWS|w|W|-w|-W) echo "windows" ;;
    linux|LINUX|l|L|-l|-L) echo "linux" ;;
    darwin|DARWIN|macOS|MACOS|m|M|-m|-M) echo "darwin" ;;
    *)
      log error "Plataforma inválida: '${arg}'. Opções válidas: windows, linux, darwin, all."
      exit 1
      ;;
  esac
}

_get_arch_from_args() {
  local arg=$1
  case "$arg" in
    all|ALL|a|A|-a|-A) echo "all" ;;
    amd64|AMD64|x86_64|X86_64|x64|X64) echo "amd64" ;;
    arm64|ARM64|aarch64|AARCH64) echo "arm64" ;;
    386|i386|I386) echo "386" ;;
    *)
      log error "Arquitetura inválida: '${arg}'. Opções válidas: amd64, arm64, 386."
      exit 1
      ;;
  esac
}

export -f _get_os_arr_from_args
export -f _get_arch_arr_from_args
export -f _get_os_from_args
export -f _get_arch_from_args
export -f get_release_url
export -f what_platform

what_platform "${@}"

/// support/utils.sh ///
#!/usr/bin/env bash
# lib/utils.sh – Funções utilitárias

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

# Códigos de cor para logs
_SUCCESS="\033[0;32m"
_WARN="\033[0;33m"
_ERROR="\033[0;31m"
_INFO="\033[0;36m"
_NC="\033[0m"

log() {
  local type=${1:-info}
  local message=${2:-}
  local debug=${3:-${DEBUG:-false}}

  case $type in
    info|_INFO|-i|-I)
      if [[ "$debug" == true ]]; then
        printf '%b[_INFO]%b ℹ️  %s\n' "$_INFO" "$_NC" "$message"
      fi
      ;;
    warn|_WARN|-w|-W)
      if [[ "$debug" == true ]]; then
        printf '%b[_WARN]%b ⚠️  %s\n' "$_WARN" "$_NC" "$message"
      fi
      ;;
    error|_ERROR|-e|-E)
      printf '%b[_ERROR]%b ❌  %s\n' "$_ERROR" "$_NC" "$message"
      ;;
    success|_SUCCESS|-s|-S)
      printf '%b[_SUCCESS]%b ✅  %s\n' "$_SUCCESS" "$_NC" "$message"
      ;;
    *)
      if [[ "$debug" == true ]]; then
        log "info" "$message" "$debug"
      fi
      ;;
  esac
}

clear_screen() {
  printf "\033[H\033[2J"
}

get_current_shell() {
  local shell_proc
  shell_proc=$(cat /proc/$$/comm)
  case "${0##*/}" in
    ${shell_proc}*)
      local shebang
      shebang=$(head -1 "$0")
      printf '%s\n' "${shebang##*/}"
      ;;
    *)
      printf '%s\n' "$shell_proc"
      ;;
  esac
}

# Cria um diretório temporário para cache
_TEMP_DIR="${_TEMP_DIR:-$(mktemp -d)}"
if [[ -d "${_TEMP_DIR}" ]]; then
    log info "Diretório temporário criado: ${_TEMP_DIR}"
else
    log error "Falha ao criar o diretório temporário."
fi

clear_script_cache() {
  trap - EXIT HUP INT QUIT ABRT ALRM TERM
  if [[ ! -d "${_TEMP_DIR}" ]]; then
    exit 0
  fi
  rm -rf "${_TEMP_DIR}" || true
  if [[ -d "${_TEMP_DIR}" ]] && sudo -v 2>/dev/null; then
    sudo rm -rf "${_TEMP_DIR}"
    if [[ -d "${_TEMP_DIR}" ]]; then
      printf '%b[_ERROR]%b ❌  %s\n' "$_ERROR" "$_NC" "Falha ao remover o diretório temporário: ${_TEMP_DIR}"
    else
      printf '%b[_SUCCESS]%b ✅  %s\n' "$_SUCCESS" "$_NC" "Diretório temporário removido: ${_TEMP_DIR}"
    fi
  fi
  exit 0
}

set_trap() {
  local current_shell=""
  current_shell=$(get_current_shell)
  case "${current_shell}" in
    *ksh|*zsh|*bash)
      declare -a FULL_SCRIPT_ARGS=("$@")
      if [[ "${FULL_SCRIPT_ARGS[*]}" =~ -d ]]; then
          set -x
      fi
      if [[ "${current_shell}" == "bash" ]]; then
        set -o errexit
        set -o pipefail
        set -o errtrace
        set -o functrace
        shopt -s inherit_errexit
      fi
      trap 'clear_script_cache' EXIT HUP INT QUIT ABRT ALRM TERM
      ;;
  esac
}

/// support/validate.sh ///
#!/usr/bin/env bash
# lib/validate.sh – Validação da versão do Go e dependências

validate_versions() {
    local REQUIRED_GO_VERSION="${_VERSION_GO:-1.20.0}"
    local GO_VERSION
    GO_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
    if [[ "$(printf '%s\n' "$REQUIRED_GO_VERSION" "$GO_VERSION" | sort -V | head -n1)" != "$REQUIRED_GO_VERSION" ]]; then
        log error "A versão do Go deve ser >= $REQUIRED_GO_VERSION. Detectado: $GO_VERSION"
        exit 1
    fi
    log success "Versão do Go válida: $GO_VERSION"
    go mod tidy || return 1
}

check_dependencies() {
    for dep in "$@"; do
        if ! command -v "$dep" > /dev/null; then
            log error "$dep não está instalado."
            exit 1
        else
            log success "$dep está instalado."
        fi
    done
}

export -f validate_versions
export -f check_dependencies

/// types/abstract.go ///
package types

import (
	"github.com/charmbracelet/lipgloss"
)

// Validation interfaces and types

type FormInputValidationObject[T any] func(value T) error
type FormInputValidationString func(value string) error
type FormInputValidationCustom func(value string) error
type FormInputValidationRule[T any] struct {
	Min, Max  int
	ObjFunc   FormInputValidationObject[T]
	Challenge FormInputValidationCustom
	StrFunc   FormInputValidationString
}

// ---------------------------------------------------
// Form objects interfaces and types for handle with groups of fields, forms, sections and parts.

// FormPart is an interface that agroups fields and provides methods to manipulate them. It is used to
// group fields, manage screen space and fields distribution on the screen.
type FormPart struct {
	*lipgloss.Style
	FormGroup
	Width, Height, MaxWidth, MaxHeight int
	Title                              string
}

func (s FormPart) GetWidth() int { return s.Width }
func (s FormPart) GetUpperBound() int {
	mh := s.GetMaxHeight()
	if mh == 0 {
		return 0
	}
	return s.GetLowerBound() + mh
}
func (s FormPart) GetLowerBound() int {
	if s.GetMaxHeight() == 0 {
		return 0
	}
	return s.GetMaxHeight() - s.GetHeight()
}
func (s FormPart) GetLeftBound() int {
	if s.GetMaxWidth() == 0 {
		return 0
	}
	return s.GetMaxWidth() - s.GetWidth()
}
func (s FormPart) GetRightBound() int {
	mw := s.GetMaxWidth()
	if mw == 0 {
		return 0
	}
	return s.GetLeftBound() + mw
}

// FormGroup is an interface that manages goups of fields. It was created to provide a easy way to
// manage fields in a form, wrapping them in groups and providing methods to manipulate them.
type FormGroup interface {
	GetFields() FormFields

	GetFieldByID(id string) FieldDefinition
	GetFieldByIndex(index int) FieldDefinition
	GetFieldIndex(id string) int
	GetFieldID(index int) string

	FieldsCount() int

	Validate() error

	SetField(index int, field FieldDefinition)
	SetFieldByID(id string, field FieldDefinition)
	SetFields(fields FormFields)
}

/// types/custom_fields.go ///
package types

// New interfaces and structs for customization options, validation, and layout

type CustomizableField interface {
	FormInput[FormInputObject[any]]
	Label() string
	DefaultValue() string
	Group() string
}
type CustomField struct {
	Lbl  string
	DVal string
	Grp  string
}

func (f CustomField) Label() string        { return f.Lbl }
func (f CustomField) DefaultValue() string { return f.DVal }
func (f CustomField) Group() string        { return f.Grp }

/// types/data_exporter.go ///
package types

type DataExporter interface {
	ExportToCSV(filename string) error
	ExportToYAML(filename string) error
	ExportToJSON(filename string) error
	ExportToXML(filename string) error
	ExportToExcel(filename string) error
	ExportToPDF(filename string) error
	ExportToMarkdown(filename string) error
}
type dataExporter struct{}

func (e dataExporter) ExportToCSV(filename string) error {
	// Implementation for exporting to CSV
	return nil
}
func (e dataExporter) ExportToYAML(filename string) error {
	// Implementation for exporting to YAML
	return nil
}
func (e dataExporter) ExportToJSON(filename string) error {
	// Implementation for exporting to JSON
	return nil
}
func (e dataExporter) ExportToXML(filename string) error {
	// Implementation for exporting to XML
	return nil
}
func (e dataExporter) ExportToExcel(filename string) error {
	// Implementation for exporting to Excel
	return nil
}
func (e dataExporter) ExportToPDF(filename string) error {
	// Implementation for exporting to PDF
	return nil
}
func (e dataExporter) ExportToMarkdown(filename string) error {
	// Implementation for exporting to Markdown
	return nil
}

/// types/error.go ///
package types

// Form and Field Error interface and types
type FormError interface {
	Error() string
	ErrorOrNil() error
	FieldError() map[string]string
	FieldsError() map[string]string
}
type formError struct {
	Rule    string
	Message string
}

func (v *formError) Error() string {
	return v.Message
}
func (v *formError) FieldError() map[string]string {
	return map[string]string{v.Rule: v.Message}
}
func (v *formError) FieldsError() map[string]string {
	return map[string]string{v.Rule: v.Message}
}
func (v *formError) ErrorOrNil() error {
	return v
}

var (
	ErrRequired           = &formError{Rule: "Required", Message: "This field is required"}
	ErrInvalidEmail       = &formError{Rule: "InvalidEmail", Message: "This field must be a valid email address"}
	ErrInvalidURL         = &formError{Rule: "InvalidURL", Message: "This field must be a valid URL"}
	ErrInvalidIP          = &formError{Rule: "InvalidIP", Message: "This field must be a valid IP address"}
	ErrInvalidPort        = &formError{Rule: "InvalidPort", Message: "This field must be a valid Port number"}
	ErrInvalidMin         = &formError{Rule: "InvalidMin", Message: "This field must be a minimum of %d"}
	ErrInvalidMax         = &formError{Rule: "InvalidMax", Message: "This field must be a maximum of %d"}
	ErrInvalidMinLen      = &formError{Rule: "InvalidMinLen", Message: "This field must be a minimum length of %d"}
	ErrInvalidMaxLen      = &formError{Rule: "InvalidMaxLen", Message: "This field must be a maximum length of %d"}
	ErrInvalidRegexp      = &formError{Rule: "InvalidRegexp", Message: "This field must match the regular expression %s"}
	ErrInvalidPattern     = &formError{Rule: "InvalidPattern", Message: "This field must match the pattern %s"}
	ErrInvalidCustom      = &formError{Rule: "InvalidCustom", Message: "This field must match the custom rule"}
	ErrInvalidCustomCheck = &formError{Rule: "InvalidCustomCheck", Message: "This field must match the custom check"}
)

/// types/form_config.go ///
package types

type Config struct {
	Title  string
	Fields FormFields
}

func (c Config) GetTitle() string      { return c.Title }
func (c Config) GetFields() FormFields { return c.Fields }

type FormConfig struct {
	Title string
	FormFields
}

func NewFormConfig(title string, fields []FormInputObject[any]) FormConfig {
	return FormConfig{
		Title:      title,
		FormFields: FormFields{Title: title, Fields: fields},
	}
}

func (f FormConfig) GetTitle() string      { return f.Title }
func (f FormConfig) SetTitle(title string) { f.Title = title }

func (f FormConfig) GetFields() []FormInputObject[any] { return f.Fields }
func (f FormConfig) GetField(name string) FormInputObject[any] {
	for _, field := range f.Fields {
		if field.GetName() == name {
			return field
		}
	}
	return nil
}
func (f FormConfig) GetFieldValue(name string) any {
	for _, field := range f.Fields {
		if field.GetName() == name {
			return field.GetValue()
		}
	}
	return nil
}

func (f FormConfig) SetFieldValue(name string, value any) error {
	for _, field := range f.Fields {
		if field.GetName() == name {
			return field.SetValue(value)
		}
	}
	return nil
}
func (f FormConfig) SetField(name string, field FormInputObject[any]) error {
	for i, cf := range f.GetFields() {
		if cf.GetName() == name {
			f.Fields[i] = field
			return nil
		}
	}
	return nil
}

func (f FormConfig) AddField(field FormInputObject[any]) { f.Fields = append(f.Fields, field) }
func (f FormConfig) RemoveField(name string) error {
	for i, field := range f.Fields {
		if field.GetName() == name {
			f.Fields = append(f.Fields[:i], f.Fields[i+1:]...)
			return nil
		}
	}
	return nil
}

/// types/form_field.go ///
package types

type FormFields struct {
	Title  string
	Fields []FormInputObject[any]
}

func (f FormFields) InputType() string {
	return f.Title
}
func (f FormFields) Inputs() []FormInputObject[any] {
	return f.Fields
}

/// types/form_input.go ///
package types

import (
	"fmt"
	"reflect"
)

// FormInputObject is the most basic form input object. It will be used globally in all form input objects.
type FormInputObject[T any] interface {
	GetName() string
	GetType() reflect.Type
	GetValue() T
	SetValue(val T) error
}

// InputObject is a struct that implements the FormInputObject interface. It is used to store the value
// of the form input object in a serializable. It is used to store the value of the form input object in a
// serializable and to store metadata for easy and integrated serialization and type conversion.
type InputObject[T any] struct {
	Val  T      `json:"value" yaml:"value" gorm:"column:value"`
	Name string `json:"name" yaml:"name" gorm:"column:name"`
	err  error
}

func (s *InputObject[T]) GetName() string       { return s.Name }
func (s *InputObject[T]) GetType() reflect.Type { return reflect.TypeOf(s.Val) }
func (s *InputObject[T]) GetValue() T           { return s.Val }
func (s *InputObject[T]) SetValue(val T) error {
	if s != nil {
		s.Val = val
		return nil
	} else {
		return fmt.Errorf("input is nil")
	}
}

// -----------------------------------------------------------------------------
// Here we have that will be used to create another package later, for now it is just a draft.

type FormInput[T any] interface {
	FieldDefinition
	FormInputObject[T]

	Placeholder() string
	MinValue() int
	MaxValue() int
	Validation() func(string, func(interface{}) error) error
	IsRequired() bool
	Error() string
	SetPlaceholder(string)
	SetRequired(bool)
	SetMinValue(int)
	SetMaxValue(int)
	SetValidation(func(string, func(interface{}) error) error)
	SetValidationRules([]ValidationRule)
	ValidationRules() []ValidationRule
	Validate() error
	String() string
	FromString(string) error
	ToMap() map[string]interface{}
	FromMap(map[string]interface{}) error
}

type Input[T any] struct {
	FieldDefinition
	FormInputObject[T]
	Name               string           `json:"name" yaml:"name" gorm:"column:name"`
	Desc               string           `json:"description" yaml:"description" gorm:"column:description"`
	Ph                 string           `json:"placeholder" yaml:"placeholder" gorm:"column:placeholder"`
	Tp                 reflect.Type     `json:"type" yaml:"type" gorm:"column:type"`
	Val                *T               `json:"value" yaml:"value" gorm:"column:value"`
	Req                bool             `json:"required" yaml:"required" gorm:"column:required"`
	Min                int              `json:"min" yaml:"min" gorm:"column:min"`
	Max                int              `json:"max" yaml:"max" gorm:"column:max"`
	Err                string           `json:"error" yaml:"error" gorm:"column:error"`
	ValidationRulesVal []ValidationRule `json:"validation_rules" yaml:"validation_rules" gorm:"column:validation_rules"`
}

func (s *Input[T]) Description() string   { return s.Desc }
func (s *Input[T]) GetName() string       { return s.Name }
func (s *Input[T]) GetType() reflect.Type { return reflect.TypeOf(s.Val) }
func (s *Input[T]) GetValue() T {
	v := reflect.ValueOf(s.Val)
	return v.Interface().(T)
}
func (s *Input[T]) SetValue(val T) error {
	if s != nil {
		s.Val = &val
		return nil
	} else {
		return fmt.Errorf("input is nil")
	}
}
func (s *Input[T]) MinValue() int                                           { return s.Min }
func (s *Input[T]) MaxValue() int                                           { return s.Max }
func (s *Input[T]) Validation() func(string, func(interface{}) error) error { return nil }
func (s *Input[T]) Error() string                                           { return s.Err }
func (s *Input[T]) SetMaxValue(i int)                                       { s.Max = i }
func (s *Input[T]) Placeholder() string                                     { return s.Ph }
func (s *Input[T]) IsRequired() bool                                        { return s.Req }
func (s *Input[T]) GetError() string                                        { return s.Err }
func (s *Input[T]) SetPlaceholder(ph string)                                { s.Ph = ph }
func (s *Input[T]) SetRequired(req bool)                                    { s.Req = req }
func (s *Input[T]) SetMinValue(min int)                                     { s.Min = min }
func (s *Input[T]) SetValidation(validation func(string, func(interface{}) error) error) {
	var valRules = make([]ValidationRule, 0)
	if s != nil {
		if s.ValidationRules() != nil {
			if len(s.ValidationRules()) >= 1 {
				valRule := s.ValidationRules()[0]
				if err := valRule.Validate(s.String(), nil); err != nil {
					s.Err = err.Error()
				}
			}
		}
	}
	s.ValidationRulesVal = valRules
}
func (s *Input[T]) SetValidationRules(rules []ValidationRule) { s.ValidationRulesVal = rules }
func (s *Input[T]) ValidationRules() []ValidationRule         { return s.ValidationRulesVal }
func (s *Input[T]) Validate() error {
	if s.ValidationRulesVal == nil {
		return nil
	}
	for _, rule := range s.ValidationRulesVal {
		if s.Val != nil {
			if err := rule.Validate(s.String(), nil); err != nil {
				return err
			}
		}
	}
	return nil
}
func (s *Input[T]) String() string {
	if s != nil {
		if s.Val != nil {
			if s.GetType().Kind() == reflect.String {
				v := s.GetValue()
				vv := reflect.ValueOf(v)
				return vv.String()
			}
		}
	}
	return ""
}
func (s *Input[T]) FromString(str string) error {
	if s != nil {
		if s.Val != nil {
			v := s.GetValue()
			vv := reflect.ValueOf(v)
			vv.SetString(str)
		}
	}
	return nil
}
func (s *Input[T]) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"placeholder": s.Ph,
		"type":        s.Tp,
		"value":       s.Val,
		"required":    s.Req,
		"min":         s.Min,
		"max":         s.Max,
		"error":       s.Err,
	}
}
func (s *Input[T]) FromMap(m map[string]interface{}) error { return nil }

func NewInput[T FormInputObject[any]](t T) *Input[T]        { return &Input[T]{Val: &t} }
func NewFormInput[T FormInputObject[any]](t T) FormInput[T] { return NewInput[T](t) }
func NewFormInputFromMap[T FormInputObject[any]](m map[string]interface{}) FormInput[T] {
	return NewInput[T](m["value"].(T))
}
func NewFormInputFromString[T FormInputObject[any]](str string) FormInput[T] {
	v := reflect.ValueOf(str)
	return NewInput(v.Interface().(T))
}
func NewFormInputFromBytes[T FormInputObject[any]](b []byte) FormInput[T] {
	v := reflect.ValueOf(b)
	return NewInput[T](v.Interface().(T))
}

func NewInputObject[T any](t T) *InputObject[T]        { return &InputObject[T]{Val: t} }
func NewFormInputObject[T any](t T) FormInputObject[T] { return NewInputObject[T](t) }
func NewFormInputObjectFromMap[T any](m map[string]interface{}) FormInputObject[T] {
	v := m["value"].(T)
	return NewInputObject[T](v)
}
func NewFormInputObjectFromString[T any](str string) FormInputObject[T] {
	v := reflect.ValueOf(str)
	return NewInputObject[T](v.Interface().(T))
}
func NewFormInputObjectFromBytes[T any](b []byte) FormInputObject[T] {
	v := reflect.ValueOf(b)
	return NewInputObject[T](v.Interface().(T))
}

func NewFormInputList[T any](t []T) []FormInputObject[T] {
	lfo := make([]FormInputObject[T], 0)
	for _, v := range t {
		lfo = append(lfo, NewInputObject(v))
	}
	return lfo
}
func NewFormInputListFromMap[T any](m []map[string]interface{}) []FormInputObject[T] {
	lfo := make([]FormInputObject[T], 0)
	for _, v := range m {
		lfo = append(lfo, NewInputObject(v["value"].(T)))
	}
	return lfo
}
func NewFormInputListFromString[T any](str []string) []FormInputObject[T] {
	lfo := make([]FormInputObject[T], 0)
	for _, v := range str {
		lfo = append(lfo, NewInputObject[T](reflect.ValueOf(v).Interface().(T)))
	}
	return lfo
}
func NewFormInputListFromBytes[T any](b [][]byte) []FormInputObject[T] {
	lfo := make([]FormInputObject[T], 0)
	for _, v := range b {
		lfo = append(lfo, NewInputObject[T](reflect.ValueOf(v).Interface().(T)))
	}
	return lfo
}
func NewFormInputListFromInterface[T any](i []interface{}) []FormInputObject[T] {
	lfo := make([]FormInputObject[T], 0)
	for _, v := range i {
		lfo = append(lfo, NewInputObject[T](reflect.ValueOf(v).Interface().(T)))
	}
	return lfo
}

/// types/globals.go ///
package types

// Field Basic Generic Definition Interface

type FieldDefinition interface {
	Description() string
	String() string
}

// Shortcut Types

type Shortcut string

const (
	Q Shortcut = "q"
	F Shortcut = "f"

	UP    Shortcut = "up"
	DOWN  Shortcut = "down"
	LEFT  Shortcut = "left"
	RIGHT Shortcut = "right"

	DEL   Shortcut = "del"
	TAB   Shortcut = "tab"
	ESC   Shortcut = "esc"
	ENTER Shortcut = "enter"

	CTRLA Shortcut = "ctrl+a"
	CTRLE Shortcut = "ctrl+e"
	CTRLR Shortcut = "ctrl+r"
	CTRLC Shortcut = "ctrl+c"
	CTRLH Shortcut = "ctrl+h"

	SHIFTTAB Shortcut = "shift+tab"
)

func (s Shortcut) Description() string { return "Shortcut " + string(s) }
func (s Shortcut) String() string      { return string(s) }

// Field Position and Size Types

type FieldSize string

const (
	SizeDefault FieldSize = "default"
	SizeSmall   FieldSize = "small"
	SizeLarge   FieldSize = "large"
)

func (f FieldSize) Description() string { return "Field Size " + string(f) }
func (f FieldSize) String() string      { return string(f) }

type FieldPosition string

const (
	PositionDefault FieldPosition = "default"
	PositionTop     FieldPosition = "top"
	PositionBottom  FieldPosition = "bottom"
)

func (f FieldPosition) Description() string { return "Field Position " + string(f) }
func (f FieldPosition) String() string      { return string(f) }

// Field Alignment Types

type FieldAlignment string

const (
	AlignmentDefault FieldAlignment = "default"
	AlignmentLeft    FieldAlignment = "left"
	AlignmentCenter  FieldAlignment = "center"
	AlignmentRight   FieldAlignment = "right"
)

func (f FieldAlignment) Description() string { return "Field Alignment " + string(f) }
func (f FieldAlignment) String() string      { return string(f) }

// Field Input Primitive/Generic Types

type FieldType string

const (
	FieldBool     FieldType = "bool"
	FieldInt      FieldType = "int"
	FieldText     FieldType = "text"
	FieldPass     FieldType = "password"
	FieldDate     FieldType = "date"
	FieldTime     FieldType = "time"
	FieldList     FieldType = "list"
	FieldFile     FieldType = "file"
	FieldTable    FieldType = "table"
	FieldFunction FieldType = "function"
)

func (f FieldType) Description() string { return "Field Type " + string(f) }
func (f FieldType) String() string      { return string(f) }

// Field Rules and Validation Types

type FieldRule interface {
	Validate(value string) error
}

type ValidationRule string

const (
	Required ValidationRule = "required"
	Email    ValidationRule = "email"
	Url      ValidationRule = "url"
	IP       ValidationRule = "ip"
	Port     ValidationRule = "port"
	Min      ValidationRule = "min"
	Max      ValidationRule = "max"
	MinLen   ValidationRule = "min_len"
	MaxLen   ValidationRule = "max_len"
	Regexp   ValidationRule = "regexp"
	Pattern  ValidationRule = "pattern"
)

func (v ValidationRule) Description() string { return "Validation Rule " + string(v) }
func (v ValidationRule) String() string      { return string(v) }
func (v ValidationRule) Validate(value string, customCheck func(interface{}) error) error {
	switch v {
	case Required:
		if value == "" {
			return ErrRequired
		}
		// TODO: Add more native basic validation rules
		//default:
		//	if customCheck != nil {
		//		return customCheck(v)
		//	}
	}
	if customCheck != nil {
		return customCheck(v)
	}
	return nil
}

/// types/loader.go ///
package types

type LoaderMessage struct {
	Message    string
	DelayAfter int
	Icon       string
	Color      string

	Progress        bool
	ProgressProcess interface{}
	ProgressTotal   interface{}
	ProgressCurrent interface{}
	ProgressMessage string
	ProgressIcon    string
}

type LoaderOrchestrator struct {
	LoaderMessages []LoaderMessage
}

func (l *LoaderOrchestrator) AddMessage(m LoaderMessage) {
	l.LoaderMessages = append(l.LoaderMessages, m)
}
func (l *LoaderOrchestrator) AddMessages(m []LoaderMessage) {
	l.LoaderMessages = append(l.LoaderMessages, m...)
}
func (l *LoaderOrchestrator) ClearMessages()               { l.LoaderMessages = make([]LoaderMessage, 0) }
func (l *LoaderOrchestrator) GetMessages() []LoaderMessage { return l.LoaderMessages }
func (l *LoaderOrchestrator) GetMessagesCount() int        { return len(l.LoaderMessages) }
func (l *LoaderOrchestrator) GetLastMessage() LoaderMessage {
	if len(l.LoaderMessages) > 0 {
		return l.LoaderMessages[len(l.LoaderMessages)-1]
	}
	return LoaderMessage{}
}
func (l *LoaderOrchestrator) GetFirstMessage() LoaderMessage {
	if len(l.LoaderMessages) > 0 {
		return l.LoaderMessages[0]
	}
	return LoaderMessage{}
}

func NewLoaderOrchestrator() *LoaderOrchestrator {
	return &LoaderOrchestrator{}
}

type Loader interface {
	AddMessage(LoaderMessage)
	AddMessages([]LoaderMessage)
	ClearMessages()
	GetMessages() []LoaderMessage
	GetMessagesCount() int
	GetLastMessage() LoaderMessage
	GetFirstMessage() LoaderMessage
}

/// types/mapper.go ///
package types

import (
	"bufio"
	"encoding/asn1"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"os"
	"reflect"
	"strings"

	"github.com/pelletier/go-toml/v2"
	gl "github.com/kubex-ecosystem/xtui/logger"
	"github.com/subosito/gotenv"
	"gopkg.in/yaml.v3"
)

// IMapper is a generic interface for serializing and deserializing objects of type T.
type IMapper[T any] interface {
	// SerializeToFile serializes an object of type T to a file in the specified format.
	SerializeToFile(format string)
	// DeserializeFromFile deserializes an object of type T from a file in the specified format.
	DeserializeFromFile(format string) (T, error)
	// Serialize converts an object of type T to a byte array in the specified format.
	Serialize(format string) ([]byte, error)
	// Deserialize converts a byte array in the specified format to an object of type T.
	Deserialize(data []byte, format string) (T, error)
}

// Mapper is a generic struct that implements the IMapper interface for serializing and deserializing objects.
type Mapper[T any] struct {
	filePath string
	object   T
}

// NewMapperTypeWithObject creates a new instance of Mapper.
func NewMapperTypeWithObject[T any](object *T, filePath string) *Mapper[T] {
	return &Mapper[T]{filePath: filePath, object: *object}
}

// NewMapperType creates a new instance of Mapper.
func NewMapperType[T any](object *T, filePath string) *Mapper[T] {
	return &Mapper[T]{filePath: filePath, object: *object}
}

// NewMapperPtr creates a new instance of Mapper.
func NewMapperPtr[T any](object *T, filePath string) *Mapper[*T] {
	return &Mapper[*T]{filePath: filePath, object: *&object}
}

// NewMapper creates a new instance of Mapper.
func NewMapper[T any](object *T, filePath string) IMapper[T] {
	return NewMapperType[T](object, filePath)
}

// Serialize converts an object of type T to a byte array in the specified format.
func (m *Mapper[T]) Serialize(format string) ([]byte, error) {
	switch format {
	case "json":
		return json.Marshal(m.object)
	case "yaml":
		return yaml.Marshal(m.object)
	case "xml":
		return xml.Marshal(m.object)
	case "toml":
		return toml.Marshal(m.object)
	case "asn":
		return asn1.Marshal(m.object)
	case "env":
		if env, ok := reflect.ValueOf(m.object).Interface().(map[string]string); ok {
			if strM, strMErr := gotenv.Marshal(env); strMErr != nil {
				gl.Log("error", fmt.Sprintf("Error serializing to env: %v", strMErr))
				return nil, fmt.Errorf("erro ao serializar para env: %v", strMErr)
			} else {
				return []byte(strM), nil
			}
		} else {
			return nil, fmt.Errorf("tipo não suportado para env: %T", m.object)
		}
	default:
		return nil, fmt.Errorf("formato não suportado: %s", format)
	}
}

// Deserialize converts a byte array in the specified format to an object of type T.
func (m *Mapper[T]) Deserialize(data []byte, format string) (T, error) {
	if len(data) == 0 {
		return *new(T), fmt.Errorf("os dados estão vazios")
	}
	if !reflect.ValueOf(m.object).IsValid() || reflect.ValueOf(m.object).IsNil() {
		m.object = *new(T)
		//val := reflect.ValueOf(m.object)
		//if val.Kind() == reflect.Ptr {
		//	if val.IsNil() {
		//		val.Set(reflect.New(val.Type()))
		//	}
		//	m.object = val.Interface().(T)
		//} else if val.Kind() == reflect.Map {
		//	if val.IsNil() {
		//		val.Set(reflect.MakeMap(val.Type()))
		//	}
		//	m.object = val.Interface().(T)
		//} else if val.Kind() == reflect.Slice {
		//	if val.IsNil() {
		//		sliceType := reflect.SliceOf(reflect.TypeOf(m.object).Elem())
		//		val = reflect.New(sliceType).Elem()
		//		// Initialize the slice with zero length and capacity
		//		val.Set(reflect.MakeSlice(sliceType, 0, 0))
		//	} else {
		//		// Initialize the slice with zero length and capacity
		//		val.Set(reflect.MakeSlice(reflect.SliceOf(reflect.TypeOf(m.object).Elem()), 0, 0))
		//	}
		//	m.object = val.Interface().(T)
		//} else if val.Kind() == reflect.Array {
		//	if val.IsNil() {
		//		arrayType := reflect.ArrayOf(val.Len(), val.Type().Elem())
		//		val = reflect.New(arrayType).Elem()
		//		// Initialize the array with zero length and capacity
		//		val.Set(reflect.MakeSlice(arrayType, 0, 0))
		//	} else {
		//		// Initialize the array with zero length and capacity
		//		val.Set(reflect.MakeSlice(reflect.ArrayOf(val.Len(), val.Type().Elem()), 0, 0))
		//	}
		//	m.object = val.Interface().(T)
		//} else {
		//	m.object = reflect.New(reflect.TypeOf(m.object)).Interface().(T)
		//}
	}
	var err error
	switch format {
	case "json", "js":
		err = json.Unmarshal(data, m.object)
	case "yaml", "yml":
		err = yaml.Unmarshal(data, m.object)
	case "xml", "html":
		err = xml.Unmarshal(data, m.object)
	case "toml", "tml":
		err = toml.Unmarshal(data, m.object)
	case "asn", "asn1":
		_, err = asn1.Unmarshal(data, m.object)
	case "env", "envs", ".env", "environment":
		value := reflect.ValueOf(m.object)
		envT, ok := value.Interface().(*map[string]string)
		if !ok {
			envTB, ok := value.Interface().(map[string]string)
			if !ok {
				gl.Log("error", fmt.Sprintf("Type not valid for env: %T", m.object))
				return *new(T), fmt.Errorf("envT não é válido")
			} else {
				envT = &envTB
			}
		}
		if envT != nil {
			if !reflect.ValueOf(envT).IsValid() {
				gl.Log("error", fmt.Sprintf("Type not valid for env: %T", m.object))
				return *new(T), fmt.Errorf("envT não é válido")
			}
			env := *envT
			if strM, strMErr := gotenv.Unmarshal(string(data)); strMErr != nil {
				return *new(T), fmt.Errorf("erro ao desserializar de env: %v", strMErr)
			} else {
				for k, v := range strM {
					env[k] = v
				}
			}
		} else {
			// We not set err to nil, also we not set err to another value here.
			// This is a special case where we want to return nil, to allow the caller to
			// know that the object is really nil.
			gl.Log("error", fmt.Sprintf("Nil type for env: %T", m.object))
		}
	default:
		err = fmt.Errorf("formato não suportado: %s", format)
	}
	if err != nil {
		return *new(T), fmt.Errorf("erro ao desserializar os dados: %v", err)
	}
	return m.object, nil
}

// SerializeToFile serializes an object of type T to a file in the specified format.
func (m *Mapper[T]) SerializeToFile(format string) {
	if dataSer, dataSerErr := m.Serialize(format); dataSerErr != nil {
		gl.Log("error", fmt.Sprintf("Error serializing object: %v", dataSerErr.Error()))
		return
	} else {
		gl.Log("debug", fmt.Sprintf("Serialized object: %s", string(dataSer)))
		orf, orfErr := os.OpenFile(m.filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if orfErr != nil {
			gl.Log("error", fmt.Sprintf("Error opening file: %v", orfErr.Error()))
			return
		}
		defer func() {
			if err := orf.Close(); err != nil {
				gl.Log("error", fmt.Sprintf("Error closing file: %v", err.Error()))
				return
			}
		}()
		if _, err := orf.WriteString(fmt.Sprintf("%s\n", string(dataSer))); err != nil {
			gl.Log("error", fmt.Sprintf("Error writing to file: %v", err.Error()))
			return
		}
	}
}

// DeserializeFromFile deserializes an object of type T from a file in the specified format.
func (m *Mapper[T]) DeserializeFromFile(format string) (T, error) {
	if _, err := os.Stat(m.filePath); os.IsNotExist(err) {
		gl.Log("error", fmt.Sprintf("File does not exist: %v", err.Error()))
		return *new(T), err
	}

	inputFile, err := os.Open(m.filePath)
	if err != nil {
		gl.Log("error", "Error opening file: %v", err.Error())
		return *new(T), err
	}

	defer func(inputFile *os.File) {
		gl.Log("debug", "Closing input file")
		if closeErr := inputFile.Close(); closeErr != nil {
			gl.Log("error", fmt.Sprintf("Error closing file: %v", closeErr.Error()))
			return
		}
		return
	}(inputFile)

	reader := bufio.NewReader(inputFile)
	scanner := bufio.NewScanner(reader)

	scanner.Split(bufio.ScanLines)
	objSlice := make([]T, 0)

	for scanner.Scan() {
		line := scanner.Text()
		if len(line) == 0 {
			continue
		}

		if desObj, desObjErr := m.Deserialize([]byte(line), format); desObjErr != nil {
			gl.Log("error", fmt.Sprintf("Error deserializing line: %v", desObjErr.Error()))
			return *new(T), err
		} else {
			gl.Log("debug", fmt.Sprintf("Deserialized line: %s", line))
			gl.Log("debug", fmt.Sprintf("Deserialized object: %v", desObj))
			if err = scanner.Err(); err != nil {
				gl.Log("error", fmt.Sprintf("Error reading file: %v", err.Error()))
				return *new(T), err
			}
			objSlice = append(objSlice, desObj)
		}
	}
	if err := scanner.Err(); err != nil {
		gl.Log("error", fmt.Sprintf("Error reading file: %v", err.Error()))
		return *new(T), err
	}
	gl.Log("debug", "File closed successfully")

	var isSliceOrMap int
	value := reflect.ValueOf(m.object)

	switch reflect.TypeFor[T]().Kind() {
	case reflect.Slice, reflect.SliceOf(reflect.TypeFor[map[string]string]()).Kind():
		if value.Len() == 0 {
			// If the slice is empty, assign the deserialized object to the slice
			m.object = *reflect.ValueOf(objSlice).Interface().(*T)
			return m.object, nil
		}
		break
	case reflect.Map:
		if value.Len() == 0 {
			// If the map is empty, assign the deserialized object to the map
			m.object = *reflect.ValueOf(objSlice).Interface().(*T)
			return m.object, nil
		}
		isSliceOrMap = 1
		break
	default:
		// If the type is neither a slice nor a map, assign the first object to m.object
		if len(objSlice) == 0 {
			gl.Log("error", "No objects found in the file")
			return *new(T), fmt.Errorf("nenhum objeto encontrado no arquivo")
		}
		if len(objSlice) > 1 {
			gl.Log("error", "Multiple objects found in the file")
			return *new(T), fmt.Errorf("múltiplos objetos encontrados no arquivo")
		}
		m.object = objSlice[0]
		break
	}

	for _, obj := range objSlice {
		if isSliceOrMap == 0 {
			if reflect.TypeOf(m.object).Kind() == reflect.Slice {
				m.object = *reflect.AppendSlice(reflect.ValueOf(m.object), reflect.ValueOf(obj)).Interface().(*T)
			} else {
				// Check if is a pointer
				if reflect.TypeOf(m.object).Kind() != reflect.Ptr {
					m.object = *reflect.Append(reflect.ValueOf(m.object), reflect.ValueOf(obj)).Interface().(*T)
				} else {
					// Check if is a map
					if reflect.TypeOf(m.object).Kind() == reflect.Map {
						m.object = *reflect.Append(reflect.ValueOf(m.object), reflect.ValueOf(obj)).Interface().(*T)
					} else {
						m.object = obj
					}
				}
			}
		} else {
			newMap := reflect.ValueOf(obj)
			iter := newMap.MapRange()
			for iter.Next() {
				value.SetMapIndex(iter.Key(), iter.Value())
			}
		}
	}

	m.object = value.Interface().(T)
	gl.Log("debug", fmt.Sprintf("File %s deserialized successfully", m.filePath))
	return m.object, nil
}

func SanitizeQuotesAndSpaces(input string) string {
	input = strings.TrimSpace(input)
	input = strings.ReplaceAll(input, "'", "\"")
	input = strings.Trim(input, "\"")
	return input
}

func IsEqual(a, b string) bool {
	a, b = SanitizeQuotesAndSpaces(a), SanitizeQuotesAndSpaces(b)
	ptsEqual := levenshtein(a, b)
	maxLen := maxL(len(a), len(b))
	threshold := maxLen / 4
	return ptsEqual <= threshold
}

func maxL(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func levenshtein(s, t string) int {
	m, n := len(s), len(t)
	if m == 0 {
		return n
	}
	if n == 0 {
		return m
	}
	prevRow := make([]int, n+1)
	for j := 0; j <= n; j++ {
		prevRow[j] = j
	}
	for i := 1; i <= m; i++ {
		currRow := make([]int, n+1)
		currRow[0] = i
		for j := 1; j <= n; j++ {
			cost := 1
			if s[i-1] == t[j-1] {
				cost = 0
			}
			currRow[j] = min(prevRow[j]+1, currRow[j-1]+1, prevRow[j-1]+cost)
		}
		prevRow = currRow
	}
	return prevRow[n]
}

/// types/multitable_handler.go ///
package types

type MultiTableManager struct {
	Handlers []TableDataHandler
	Current  int
}

func (m *MultiTableManager) Next() {
	m.Current = (m.Current + 1) % len(m.Handlers)
}
func (m *MultiTableManager) Previous() {
	m.Current = (m.Current - 1 + len(m.Handlers)) % len(m.Handlers)
}
func (m *MultiTableManager) GetCurrentHandler() TableDataHandler {
	return m.Handlers[m.Current]
}

type MultiTableHandler struct {
	handlers []TableHandler
	current  int // Índice da tabela atual
}

func (h *MultiTableHandler) GetHeaders() []string {
	return h.handlers[h.current].GetHeaders()
}
func (h *MultiTableHandler) GetRows() [][]string {
	return h.handlers[h.current].GetRows()
}
func (h *MultiTableHandler) NextTable() {
	h.current = (h.current + 1) % len(h.handlers)
}
func (h *MultiTableHandler) PreviousTable() {
	h.current = (h.current - 1 + len(h.handlers)) % len(h.handlers)
}

/// types/table_handler.go ///
package types

type TableDataHandler interface {
	GetHeaders() []string
	GetRows() [][]string
	GetArrayMap() map[string][]string
	GetHashMap() map[string]string
	GetObjectMap() []map[string]string
	GetByteMap() map[string][]byte
}

func NewTableHandler(headers []string, rows [][]string) TableDataHandler {
	return &TableHandler{
		Headers: headers,
		Rows:    rows,
	}
}

func NewTableHandlerFromRows(headers []string, rows [][]string) TableDataHandler {
	if len(headers) == 0 {
		headers = make([]string, len(rows[0]))
		for i := range headers {
			headers[i] = "Column " + string(i+1)
		}
	}
	return &TableHandler{
		Headers: headers,
		Rows:    rows,
	}
}

func NewTableHandlerFromMap(data map[string][]string) TableDataHandler {
	headers := make([]string, 0, len(data))
	rows := make([][]string, 0, len(data))
	for key, values := range data {
		headers = append(headers, key)
		rows = append(rows, append([]string{key}, values...))
	}
	return &TableHandler{
		Headers: headers,
		Rows:    rows,
	}
}

type TableHandler struct {
	TableDataHandler
	Headers []string
	Rows    [][]string
}
type TableHandlerWithContext struct {
	TableHandler
	Context string
}

func (h *TableHandler) GetHeaders() []string { return h.Headers }
func (h *TableHandler) GetRows() [][]string  { return h.Rows }
func (h *TableHandler) GetArrayMap() map[string][]string {
	m := make(map[string][]string)
	for _, row := range h.Rows {
		m[row[0]] = row[1:]
	}
	return m
}
func (h *TableHandler) GetHashMap() map[string]string {
	m := make(map[string]string)
	for _, row := range h.Rows {
		m[row[0]] = row[1]
	}
	return m
}
func (h *TableHandler) GetObjectMap() []map[string]string {
	var m []map[string]string
	for _, row := range h.Rows {
		m = append(m, map[string]string{row[0]: row[1]})
	}
	return m
}
func (h *TableHandler) GetByteMap() map[string][]byte {
	m := make(map[string][]byte)
	for _, row := range h.Rows {
		m[row[0]] = []byte(row[1])
	}
	return m
}

/// version/semantic.go ///
package version

import (
	l "github.com/kubex-ecosystem/logz"
	gl "github.com/kubex-ecosystem/xtui/logger"

	"github.com/spf13/cobra"

	_ "embed"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"
)

const moduleAlias = "XTuI"
const moduleName = "xtui"
const gitModelUrl = "https://github.com/kubex-ecosystem/" + moduleName + ".git"
const currentVersionFallback = "v1.3.1" // First version with the version file

type Service interface {
	GetLatestVersion() (string, error)
	GetCurrentVersion() string
	IsLatestVersion() (bool, error)
}
type ServiceImpl struct {
	gitModelUrl    string
	latestVersion  string
	currentVersion string
}
type Tag struct {
	Name string `json:"name"`
}

func init() {
	l.GetLogger(moduleAlias)
}

func getLatestTag(repoURL string) (string, error) {
	apiURL := fmt.Sprintf("%s/tags", repoURL)
	resp, err := http.Get(apiURL)
	if err != nil {
		return "", err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to fetch tags: %s", resp.Status)
	}

	var tags []Tag
	if err := json.NewDecoder(resp.Body).Decode(&tags); err != nil {
		return "", err
	}

	if len(tags) == 0 {
		return "", fmt.Errorf("no tags found")
	}

	return tags[0].Name, nil
}

func (v *ServiceImpl) updateLatestVersion() error {
	repoURL := strings.TrimSuffix(v.gitModelUrl, ".git")
	tag, err := getLatestTag(repoURL)
	if err != nil {
		return err
	}
	v.latestVersion = tag
	return nil
}
func (v *ServiceImpl) vrsCompare(v1, v2 []int) (int, error) {
	if len(v1) != len(v2) {
		return 0, fmt.Errorf("version length mismatch")
	}

	for idx, v2S := range v2 {
		v1S := v1[idx]
		if v1S > v2S {
			return 1, nil
		}

		if v1S < v2S {
			return -1, nil
		}
	}
	return 0, nil
}
func (v *ServiceImpl) versionAtMost(versionAtMostArg, max []int) (bool, error) {
	if comp, err := v.vrsCompare(versionAtMostArg, max); err != nil {
		return false, err
	} else if comp == 1 {
		return false, nil
	}
	return true, nil
}
func (v *ServiceImpl) parseVersion(versionToParse string) []int {
	version := make([]int, 3)
	for idx, vStr := range strings.Split(versionToParse, ".") {
		vS, err := strconv.Atoi(vStr)
		if err != nil {
			return nil
		}
		version[idx] = vS
	}
	return version
}

func (v *ServiceImpl) IsLatestVersion() (bool, error) {
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return false, err
		}
	}

	curr := v.parseVersion(v.currentVersion)
	latest := v.parseVersion(v.latestVersion)

	if curr == nil || latest == nil {
		return false, fmt.Errorf("error parsing versions")
	}

	if isLatest, err := v.versionAtMost(curr, latest); err != nil {
		return false, err
	} else if isLatest {
		return true, nil
	}
	return false, nil
}
func (v *ServiceImpl) GetLatestVersion() (string, error) {
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return "", err
		}
	}

	return v.latestVersion, nil
}
func (v *ServiceImpl) GetCurrentVersion() string { return v.currentVersion }

func NewVersionService() Service {
	return &ServiceImpl{
		gitModelUrl:    gitModelUrl,
		currentVersion: currentVersion,
		latestVersion:  "",
	}
}

var (
	versionCmd = &cobra.Command{
		Use:   "version",
		Short: "Print the version number of " + moduleAlias,
		Long:  "Print the version number of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetVersionInfo()
		},
	}
	subLatestCmd = &cobra.Command{
		Use:   "latest",
		Short: "Print the latest version number of " + moduleAlias,
		Long:  "Print the latest version number of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetLatestVersionInfo()
		},
	}
	subCmdCheck = &cobra.Command{
		Use:   "check",
		Short: "Check if the current version is the latest version of " + moduleAlias,
		Long:  "Check if the current version is the latest version of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetVersionInfoWithLatestAndCheck()
		},
	}
)

//go:embed CLI_VERSION
var currentVersion string

func GetVersion() string {
	if currentVersion == "" {
		return currentVersionFallback
	}
	return currentVersion
}

func GetGitModelUrl() string {
	return gitModelUrl
}

func GetVersionInfo() string {
	gl.Log("info", "Version: "+GetVersion())
	gl.Log("info", "Git repository: "+GetGitModelUrl())
	return fmt.Sprintf("Version: %s\nGit repository: %s", GetVersion(), GetGitModelUrl())
}

func GetLatestVersionFromGit() string {
	netClient := &http.Client{
		Timeout: time.Second * 10,
	}

	gitUrlWithoutGit := strings.TrimSuffix(gitModelUrl, ".git")

	response, err := netClient.Get(gitUrlWithoutGit + "/releases/latest")
	if err != nil {
		gl.Log("error", "ErrorCtx fetching latest version: "+err.Error())
		gl.Log("error", gitUrlWithoutGit+"/releases/latest")
		return err.Error()
	}

	if response.StatusCode != 200 {
		gl.Log("error", "ErrorCtx fetching latest version: "+response.Status)
		gl.Log("error", "Url: "+gitUrlWithoutGit+"/releases/latest")
		body, _ := io.ReadAll(response.Body)
		return fmt.Sprintf("ErrorCtx: %s\nResponse: %s", response.Status, string(body))
	}

	tag := strings.Split(response.Request.URL.Path, "/")

	return tag[len(tag)-1]
}

func GetLatestVersionInfo() string {
	gl.Log("info", "Latest version: "+GetLatestVersionFromGit())
	return "Latest version: " + GetLatestVersionFromGit()
}

func GetVersionInfoWithLatestAndCheck() string {
	if GetVersion() == GetLatestVersionFromGit() {
		gl.Log("info", "You are using the latest version.")
		return fmt.Sprintf("You are using the latest version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	} else {
		gl.Log("warn", "You are using an outdated version.")
		return fmt.Sprintf("You are using an outdated version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	}
}

func CliCommand() *cobra.Command {
	versionCmd.AddCommand(subLatestCmd)
	versionCmd.AddCommand(subCmdCheck)
	return versionCmd
}

/// wrappers/application_mgr.go ///
package wrappers

import (
	"fmt"
	"log"
	"os/exec"
	"strings"

	"github.com/charmbracelet/bubbles/progress"
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	gl "github.com/kubex-ecosystem/xtui/logger"
)

type AppDepsModel struct {
	apps     []string
	path     string
	yes      bool
	quiet    bool
	index    int
	width    int
	height   int
	spinner  spinner.Model
	progress progress.Model
	done     bool
}

var (
	appDepsCurrentPkgNameStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("202"))
	appDepsDoneStyle           = lipgloss.NewStyle()
	appDepsCheckMark           = lipgloss.NewStyle().Foreground(lipgloss.Color("42")).SetString("✓")
)

func NewAppDepsModel(apps []string, path string, yes bool, quiet bool) AppDepsModel {
	p := progress.New(
		progress.WithScaledGradient("#F72100", "#F66600"),
		progress.WithWidth(40),
		progress.WithoutPercentage(),
	)
	s := spinner.New()
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("202"))
	return AppDepsModel{
		apps:     apps,
		path:     path,
		yes:      yes,
		quiet:    quiet,
		spinner:  s,
		progress: p,
	}
}

func (m *AppDepsModel) Init() tea.Cmd {
	return tea.Batch(downloadAndInstall(m.apps[m.index], m.path, m.yes, m.quiet))
}

func (m *AppDepsModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width, m.height = msg.Width, msg.Height
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "esc", "q":
			return m, tea.Quit
		}
	case installedPkgMsg:
		if m.index >= len(m.apps)-1 {
			m.done = true
			return m, tea.Quit
		}

		m.index++
		progressCmd := m.progress.SetPercent(float64(m.index+1) / float64(len(m.apps)))

		return m, tea.Batch(
			progressCmd,
			downloadAndInstall(m.apps[m.index], m.path, m.yes, m.quiet),
		)
	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		return m, cmd
	case progress.FrameMsg:
		newModel, cmd := m.progress.Update(msg)
		if newModel, ok := newModel.(progress.Model); ok {
			m.progress = newModel
		}
		return m, cmd
	}
	return m, nil
}

func (m *AppDepsModel) View() string {
	n := len(m.apps)
	w := lipgloss.Width(fmt.Sprintf("%d", n))

	depCount := fmt.Sprintf(" %*d/%*d", w, m.index+1, w, n)

	spin := m.spinner.View() + " "
	prog := m.progress.View()
	cellsAvail := appDepsMax(0, m.width-lipgloss.Width(spin+prog+depCount))

	infoMsg := lipgloss.NewStyle().Foreground(lipgloss.Color("6")).Render("Installation progress: ")
	info := lipgloss.NewStyle().MaxWidth(cellsAvail).Render("[pkgz] " + infoMsg + prog + depCount)

	cellsRemaining := appDepsMax(0, m.width-lipgloss.Width(info+spin))
	gap := strings.Repeat(" ", cellsRemaining)

	if m.done {
		depsQty := lipgloss.NewStyle().Foreground(lipgloss.Color("6")).Render(fmt.Sprintf("%d", n))
		return info + gap + "\n" + m.renderInstalledApps() + appDepsDoneStyle.Render(fmt.Sprintf("[pkgz] Done! Installed %s applications.\n", depsQty))
	}

	return info + gap + "\n" + m.renderInstalledApps()
}

func (m *AppDepsModel) renderInstalledApps() string {
	var installedApps strings.Builder
	for i := 0; i < m.index+1; i++ {
		dep := m.apps[i]
		depRendered := appDepsCurrentPkgNameStyle.Render(dep)
		infoBadge := lipgloss.NewStyle().Inline(true).Render("[pkgz] ")
		infoMsg := lipgloss.NewStyle().Inline(true).Foreground(lipgloss.Color("6")).Render("Installed application: ")
		installedApps.WriteString(fmt.Sprintf("%s%s%s %s\n", infoBadge, infoMsg, appDepsCheckMark, depRendered))
	}
	return installedApps.String()
}

type installedPkgMsg string

func downloadAndInstall(dep string, path string, yes bool, quiet bool) tea.Cmd {
	return func() tea.Msg {
		gl.Log("info", "Installing application: ")
		pkg := dep
		if strings.Contains(dep, "/") {
			pkg = strings.Split(dep, "/")[1]
		}
		pathFlag := ""
		if path != "" {
			pathFlag = "-p " + path
		}
		yesFlag := ""
		if yes {
			yesFlag = "-y"
		}
		quietFlag := ""
		if quiet {
			quietFlag = "-qq"
		}
		cmd := exec.Command("sudo", "apt-get", "install", pkg, pathFlag, yesFlag, quietFlag)
		stdin := strings.NewReader("s\n")
		cmd.Stdout = log.Writer()
		cmd.Stdin = stdin
		if err := cmd.Run(); err != nil {
			gl.Log("error", "error installing application: "+err.Error())
			return tea.Quit()
		}
		gl.Log("info", "Application installed.")
		return installedPkgMsg(dep)
	}
}

func appDepsMax(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func InstallDependenciesWithUI(args ...string) error {
	if len(args) < 4 {
		gl.Log("error", "missing arguments")
		return nil
	}
	apps := strings.Split(args[0], " ")
	if len(apps) == 0 {
		gl.Log("error", "no applications requested")
		return nil
	}
	path := args[1]
	yes := args[2] == "true"
	quiet := args[3] == "true"

	availableProperties := getAvailableProperties()
	if len(availableProperties) > 0 {
		adaptedArgs := adaptArgsToProperties(args, availableProperties)
		return InstallDependenciesWithUI(adaptedArgs...)
	}

	model := NewAppDepsModel(apps, path, yes, quiet)
	p := tea.NewProgram(&model)
	_, err := p.Run()
	defer p.Quit()
	if err != nil {
		gl.Log("error", "error running dependencies installation: "+err.Error())
		return nil
	}
	return nil
}

func getAvailableProperties() map[string]string {
	return map[string]string{
		"property1": "value1",
		"property2": "value2",
	}
}

func adaptArgsToProperties(args []string, properties map[string]string) []string {
	adaptedArgs := args
	for key, value := range properties {
		adaptedArgs = append(adaptedArgs, fmt.Sprintf("--%s=%s", key, value))
	}
	return adaptedArgs
}

func NavigateAndExecuteApplication(apps []string, path string, yes bool, quiet bool) error {
	model := NewAppDepsModel(apps, path, yes, quiet)
	p := tea.NewProgram(&model)
	_, err := p.Run()
	defer p.Quit()
	if err != nil {
		gl.Log("error", "error running application navigation and execution: "+err.Error())
		return nil
	}
	return nil
}

/// wrappers/loader_screen.go ///
package wrappers

import (
	"strings"

	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/kubex-ecosystem/xtui/types"
)

var (
	loaderSpinnerStyle  = lipgloss.NewStyle().Foreground(lipgloss.Color("215"))
	loaderHelpStyle     = lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Margin(1, 0)
	loaderDotStyle      = loaderHelpStyle.UnsetMargins()
	loaderDurationStyle = loaderDotStyle
	loaderAppStyle      = lipgloss.NewStyle().Margin(1, 2, 0, 2)
	loaderErrorStyle    = lipgloss.NewStyle().Foreground(lipgloss.Color("160"))
	loaderTitleStyle    = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("214"))
	loaderMessageStyle  = lipgloss.NewStyle().Foreground(lipgloss.Color("75"))

	loaderSuccessStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("42")).Bold(true)
	loaderWarningStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("214")).Italic(true)
	loaderInfoStyle    = lipgloss.NewStyle().Foreground(lipgloss.Color("33")).Underline(true)
)

type LoaderMsg struct {
	Message string
}

type LoaderCloseMsg struct{}

type loaderModel struct {
	spinner  spinner.Model
	messages []types.LoaderMessage
	quitting bool
	err      error
}

func newLoaderModel() loaderModel {
	s := spinner.New()
	s.Style = loaderSpinnerStyle
	return loaderModel{
		spinner:  s,
		messages: []types.LoaderMessage{},
	}
}

func (m loaderModel) Init() tea.Cmd {
	return m.spinner.Tick
}

func (m loaderModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		m.quitting = true
		return m, tea.Quit
	case LoaderMsg:
		m.messages = append(m.messages, types.LoaderMessage{Message: msg.Message})
		return m, nil
	case LoaderCloseMsg:
		m.quitting = true
		return m, tea.Quit
	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		return m, cmd
	default:
		return m, nil
	}
}

func (m loaderModel) View() string {
	var s string

	if m.quitting {
		s += loaderTitleStyle.Render("Done!")
	} else {
		s += loaderTitleStyle.Render(m.spinner.View() + " Working...")
	}

	s += "\n\n"

	for _, msg := range m.messages {
		if strings.Contains(msg.Message, "Error: ") {
			s += loaderErrorStyle.Render(msg.Message) + "\n"
		} else if strings.Contains(msg.Message, "Success: ") {
			s += loaderSuccessStyle.Render(msg.Message) + "\n"
		} else if strings.Contains(msg.Message, "Warning: ") {
			s += loaderWarningStyle.Render(msg.Message) + "\n"
		} else {
			s += loaderMessageStyle.Render(msg.Message) + "\n"
		}
	}

	if !m.quitting {
		s += loaderHelpStyle.Render("Press any key to quit")
	}

	if m.quitting {
		s += "\n"
	}

	return loaderAppStyle.Render(s)
}

func StartLoader(messages chan tea.Msg) error {
	p := tea.NewProgram(newLoaderModel())

	go func() {
		for msg := range messages {
			p.Send(msg)
		}
	}()

	if _, err := p.Run(); err != nil {
		return err
	}

	return nil
}

func NavigateAndExecuteLoader(messages chan tea.Msg) error {
	p := tea.NewProgram(newLoaderModel())

	go func() {
		for msg := range messages {
			p.Send(msg)
		}
	}()

	if _, err := p.Run(); err != nil {
		return err
	}

	return nil
}

/// wrappers/log_viewer.go ///
package wrappers

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"sync"
	"time"

	gl "github.com/kubex-ecosystem/xtui/logger"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

var (
	treeHeight int
	logHeight  int
)

type LogViewerModel struct {
	logs         []string
	moduleColors map[string]string
	mu           sync.Mutex
	treeView     string
	scrollOffset int
	autoScroll   bool
}

func (m *LogViewerModel) Init() tea.Cmd {
	return tea.Batch(streamLogs(m.moduleColors, &m.mu), updateTreeView(&m.mu), logViewerTickCmd())
}

func logViewerTickCmd() tea.Cmd {
	return tea.Tick(time.Second/3, func(t time.Time) tea.Msg {
		return t
	})
}

func (m *LogViewerModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "q", "ctrl+c":
			return m, tea.Quit
		case "up":
			if m.scrollOffset > 0 {
				m.scrollOffset--
				m.autoScroll = false
			}
		case "down":
			if m.scrollOffset < len(m.logs)-1 {
				m.scrollOffset++
				if m.scrollOffset == len(m.logs)-1 {
					m.autoScroll = true
				}
			}
		}
	case time.Time:
		return m, tea.Batch(updateTreeView(&m.mu), logViewerTickCmd())
	case string:
		m.mu.Lock()
		m.logs = append(m.logs, msg)
		if len(m.logs) > 100 {
			m.logs = m.logs[len(m.logs)-100:]
		}
		if m.autoScroll {
			lines, _ := strconv.Atoi(os.Getenv("LINES"))
			logHeight = lines - treeHeight - 2
			if len(m.logs) > logHeight {
				m.scrollOffset = len(m.logs) - logHeight
			}
		}
		m.mu.Unlock()
		return m, streamLogs(m.moduleColors, &m.mu)
	case logViewerTreeViewMsg:
		m.mu.Lock()
		m.treeView = string(msg)
		m.mu.Unlock()
		return m, updateTreeView(&m.mu)
	}
	return m, nil
}

func (m *LogViewerModel) View() string {
	m.mu.Lock()
	defer m.mu.Unlock()
	logView := strings.Join(m.logs[m.scrollOffset:], "\n")
	treeView := lipgloss.NewStyle().Height(treeHeight).Render(m.treeView)
	return lipgloss.JoinVertical(lipgloss.Top, treeView, logView)
}

func parseAnsiColors(text string, moduleColors map[string]string) string {
	for module, color := range moduleColors {
		text = strings.ReplaceAll(text, module, lipgloss.NewStyle().Foreground(lipgloss.Color(color)).Render(module))
	}
	return text
}

func streamLogs(moduleColors map[string]string, mu *sync.Mutex) tea.Cmd {
	return func() tea.Msg {
		cmd := exec.Command("kbx", "log", "--show=all", "-f")
		stdout, err := cmd.StdoutPipe()
		if err != nil {
			gl.Log("fatal", "failed to get stdout pipe", "streamLogs")
		}

		if err := cmd.Start(); err != nil {
			gl.Log("fatal", "failed to start command:", err.Error())
		}

		scanner := bufio.NewScanner(stdout)
		for scanner.Scan() {
			logLine := scanner.Text()
			mu.Lock()
			coloredLogLine := parseAnsiColors(logLine, moduleColors)
			mu.Unlock()
			return coloredLogLine
		}
		if err := scanner.Err(); err != nil {
			gl.Log("fatal", "error reading stdout: %v", err.Error())
		}
		return ""
	}
}

type logViewerTreeViewMsg string

func updateTreeView(mu *sync.Mutex) tea.Cmd {
	return func() tea.Msg {
		cmd := exec.Command("tree", os.Getenv("HOME")+"/.cache/kubex", "-s", "--du", "-C", "-h", "-P", "*.log")
		stdout, err := cmd.Output()
		if err != nil {
			gl.Log("fatal", "failed to execute command:", err.Error())
		}
		treeView := string(stdout)
		treeHeight = len(strings.Split(treeView, "\n")) + 3
		mu.Lock()
		defer mu.Unlock()
		return logViewerTreeViewMsg(treeView)
	}
}

func LogViewer(args ...string) error {
	moduleColors := map[string]string{
		"module1": "1",
		"module2": "2",
	}
	p := tea.NewProgram(&LogViewerModel{moduleColors: moduleColors}, tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("failed to run program: %v", err)
	}
	return nil
}

/// xtui.go ///
package xtui

import (
	c "github.com/kubex-ecosystem/xtui/components"
	t "github.com/kubex-ecosystem/xtui/types"
)

type Config struct{ t.FormConfig }
type FormFields = t.FormFields
type FormField[T any] struct {
	*t.InputObject[t.FormInputObject[T]]
}
type InputField[T any] struct{ *t.InputObject[T] }

func LogViewer(args ...string) error {
	return c.StartTableScreen(nil, nil)
}
func ShowForm(form Config) (map[string]string, error) {
	return c.ShowForm(form.FormConfig)
}

func NewConfig(title string, fields FormFields) Config {
	return Config{FormConfig: t.NewFormConfig(title, fields.Inputs())}
}
func NewInputField[T any](placeholder string, typ string, value T, required bool, minValue int, maxValue int, err string, validation func(string) error) *FormField[T] {
	input := t.NewInputObject[t.FormInputObject[T]](t.NewFormInputObject[T](value))
	return &FormField[T]{
		input,
	}
}
func NewFormFields[T any](title string, fields []*FormField[t.FormInputObject[T]]) FormFields {
	ffs := make([]t.FormInputObject[any], 0)
	for i, f := range fields {
		ffs[i] = t.NewFormInputObject[any](f.GetValue())
	}
	return FormFields{
		Title:  title,
		Fields: ffs,
	}
}
func NewFormModel(config Config) (map[string]string, error) { return c.ShowForm(config.FormConfig) }
