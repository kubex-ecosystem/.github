# LookAtni Code - Gerado automaticamente
# Data: 2025-07-13T23:14:40.585Z
# Fonte: /srv/apps/KUBEX/gocrafter/
# Total de arquivos: 56

/// .golangci.yml ///
run:
  timeout: 5m
  tests: true
  # skip-dirs:
  #   - vendor
  #   - testdata
  #   - templates

linters:
  govet:
    check-shadowing: true
    settings:
      printf:
        funcs:
          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Infof
          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Warnf
          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Errorf
          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Fatalf

  gocyclo:
    min-complexity: 15

  goimports:
    local-prefixes: github.com/kubex-ecosystem/gocrafter

  dupl:
    threshold: 100

  goconst:
    min-len: 2
    min-occurrences: 2

  misspell:
    locale: US

  lll:
    line-length: 120

  unused:
    check-exported: false

  unparam:
    check-exported: false

  nakedret:
    max-func-lines: 30

  prealloc:
    simple: true
    range-loops: true
    for-loops: false

  whitespace:
    multi-if: false
    multi-func: false

  wsl:
    strict-append: true
    allow-assign-and-call: true
    allow-multiline-assign: true
    allow-case-trailing-whitespace: true
    allow-cuddle-declarations: false

linters:
  # disable-all: true
  enable:
    - bodyclose
    - deadcode
    - depguard
    - dogsled
    - dupl
    - errcheck
    - exportloopref
    - exhaustive
    - gochecknoinits
    - goconst
    - gocritic
    - gocyclo
    - gofmt
    - goimports
    - golint
    - gomnd
    - goprintffuncname
    - gosec
    - gosimple
    - govet
    - ineffassign
    - interfacer
    - lll
    - misspell
    - nakedret
    - noctx
    - nolintlint
    - rowserrcheck
    - scopelint
    - staticcheck
    - structcheck
    - stylecheck
    - typecheck
    - unconvert
    - unparam
    - unused
    - varcheck
    - whitespace

issues:
  exclude-rules:
    # Exclude some linters from running on tests files.
    - path: _test\.go
      linters:
        - gocyclo
        - errcheck
        - dupl
        - gosec

    # Exclude known linters from partially hard-to-fix issues
    - path: internal/generator/generator.go
      linters:
        - lll
        - gocyclo

    # Exclude linters for template files
    - path: templates/
      linters:
        - lll
        - whitespace

  # Excluding configuration per-path, per-linter, per-text and per-source
  exclude:
    # errcheck: Almost all programs ignore errors on these functions and in most cases it's ok
    - Error return value of .((os\.)?std(out|err)\..*|.*Close|.*Flush|os\.Remove(All)?|.*printf?|os\.(Un)?Setenv). is not checked

    # golint: False positive when used with embed
    - "exported (type|method|function) (.+) should have comment or be unexported"

    # gosec: Too many false positives
    - G104
    - G204
    - G304

  max-same-issues: 50

/// CHANGELOG.md ///
# Changelog

All notable changes to GoCrafter will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added

- Initial GoCrafter implementation
- Interactive project generation wizard
- Multiple project templates (api-rest, cli-tool, microservice)
- Template-based project scaffolding
- Comprehensive documentation and examples

### Templates

- **api-rest**: Complete REST API template with Gin framework
  - Database support (PostgreSQL, MySQL, MongoDB, SQLite)
  - Caching layer (Redis, Memcached, In-Memory)
  - Authentication (JWT, OAuth2, API Keys)
  - API documentation with Swagger
  - Docker and Kubernetes support
  - Health checks and metrics
  - Comprehensive test suite

## [1.0.0] - 2025-06-21

### Added

- üöÄ **Core Features**
  - Interactive CLI wizard with `survey` library
  - Quick project generation with templates
  - Template listing and information commands
  - Modular and extensible architecture

- üì¶ **Templates**
  - `api-rest`: Production-ready REST API server
  - `cli-tool`: Command-line application framework
  - `microservice`: Microservice with gRPC support

- ‚öôÔ∏è **Configuration**
  - Dynamic project configuration
  - Template metadata system
  - Feature-based conditional generation
  - Environment-specific settings

- üõ†Ô∏è **Developer Experience**
  - Comprehensive error handling and validation
  - User-friendly prompts and feedback
  - Professional project structure
  - Best practices integration

- üìö **Documentation**
  - Complete user guide and tutorials
  - Template development guide
  - Architecture documentation
  - Contributing guidelines
  - Multi-language support (English, Portuguese)

### Technical Details

- **Go Version**: Requires Go 1.21 or higher
- **Dependencies**:
  - `github.com/AlecAivazis/survey/v2` for interactive prompts
  - `github.com/spf13/cobra` for CLI framework
  - `github.com/sirupsen/logrus` for structured logging
- **Platforms**: Cross-platform support (Linux, macOS, Windows)

### Templates Features

#### API REST Template

- **Framework**: Gin HTTP framework
- **Database**: PostgreSQL, MySQL, MongoDB, SQLite support
- **Caching**: Redis, Memcached, in-memory options
- **Authentication**: JWT, OAuth2, API key authentication
- **Documentation**: Swagger/OpenAPI integration
- **DevOps**: Docker, Kubernetes, CI/CD configurations
- **Monitoring**: Health checks, metrics, logging
- **Testing**: Unit and integration test structure

#### CLI Tool Template

- **Framework**: Cobra command framework
- **Features**: Subcommands, configuration, colored output
- **Build**: Cross-platform builds and releases
- **Documentation**: Man pages and shell completion

#### Microservice Template

- **Protocols**: gRPC and HTTP support
- **Discovery**: Service discovery integration
- **Observability**: Metrics, tracing, logging
- **Deployment**: Kubernetes-ready manifests

### Project Structure

```
gocrafter/
‚îú‚îÄ‚îÄ cmd/                    # CLI application entry points
‚îú‚îÄ‚îÄ internal/               # Private packages and business logic
‚îÇ   ‚îú‚îÄ‚îÄ cli/               # Command implementations
‚îÇ   ‚îú‚îÄ‚îÄ generator/         # Template engine and generation logic
‚îÇ   ‚îî‚îÄ‚îÄ prompt/            # Interactive user prompts
‚îú‚îÄ‚îÄ templates/             # Project templates
‚îú‚îÄ‚îÄ docs/                  # Comprehensive documentation
‚îú‚îÄ‚îÄ logger/                # Logging utilities
‚îî‚îÄ‚îÄ version/               # Version management
```

### Installation Methods

- **Go Install**: `go install github.com/kubex-ecosystem/gocrafter@latest`
- **Binary Releases**: GitHub releases with pre-built binaries
- **Docker**: Container image support (planned)

### Supported Platforms

- Linux (amd64, arm64)
- macOS (amd64, arm64)
- Windows (amd64)

---

### Migration Guide

This is the initial release of GoCrafter. No migration is required.

### Breaking Changes

None - this is the first release.

### Deprecations

None - this is the first release.

### Security Updates

None - this is the first release.

---

### Contributors

Special thanks to all contributors who made this release possible:

- [@rafa-mori](https://github.com/rafa-mori) - Lead developer and architect

### Acknowledgments

- [Cobra](https://github.com/spf13/cobra) - Powerful CLI framework
- [Survey](https://github.com/AlecAivazis/survey) - Interactive prompts
- [Gin](https://github.com/gin-gonic/gin) - HTTP web framework
- [Logrus](https://github.com/sirupsen/logrus) - Structured logging

---

## Release Process

### Versioning Strategy

GoCrafter follows [Semantic Versioning](https://semver.org/):

- **MAJOR** version for incompatible API changes
- **MINOR** version for backward-compatible functionality additions
- **PATCH** version for backward-compatible bug fixes

### Release Schedule

- **Major releases**: Quarterly (every 3 months)
- **Minor releases**: Monthly or as needed for significant features
- **Patch releases**: As needed for critical bug fixes

### Release Criteria

For each release, we ensure:

- [ ] All tests pass
- [ ] Documentation is updated
- [ ] Templates are validated
- [ ] Cross-platform builds work
- [ ] Security scan completed
- [ ] Performance benchmarks maintained

### Upgrade Path

Each release will include:

- **Changelog**: Detailed list of changes
- **Migration Guide**: Steps for upgrading (if needed)
- **Breaking Changes**: Clear documentation of any breaking changes
- **Deprecation Notices**: Advance warning of future removals

---

## Support Policy

### Long Term Support (LTS)

- **Current Version**: Full support with all features and bug fixes
- **Previous Major**: Security fixes and critical bug fixes
- **Older Versions**: Community support only

### End of Life (EOL)

Versions reach EOL 12 months after the next major release.

---

## Roadmap Preview

### Upcoming Features (v1.1.0)

- Additional templates (worker, library, grpc-service)
- Template repository system
- Plugin architecture foundation
- Enhanced CLI experience

### Future Releases

- Web-based project generator
- Template marketplace
- Cloud deployment integration
- IDE extensions

---

*For the complete roadmap and feature requests, see our [GitHub Issues](https://github.com/kubex-ecosystem/gocrafter/issues) and [Discussions](https://github.com/kubex-ecosystem/gocrafter/discussions).*

/// CODE_OF_CONDUCT.md ///
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
discord.gg/CCBJsFHT.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
<https://www.contributor-covenant.org/version/2/0/code_of_conduct.html>.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
<https://www.contributor-covenant.org/faq>. Translations are available at
<https://www.contributor-covenant.org/translations>.

/// NOTICE.md ///
# NOTICE

This software is licensed under the MIT License. Below are additional notes on usage and attribution:

## Attribution Requirement (Optional)

- When distributing or using this software, please provide credit to the original author(s) in one or more of the following ways:
- Retain the copyright notice: `Copyright (c) 2025 Rafael Mori`.
- Include a link to the original project repository or website.

## Acknowledgment

This project was developed with the goal of enhancing usability and providing open access to its features.

For further information about the license and terms of use, please refer to the `LICENSE` file included with this project.

/// README.md ///
 ![GoCrafter Banner](docs/assets/top_banner.png)

# **GoCrafter**

## A powerful Go project scaffolding and templating tool with pluggable kits that helps you create production-ready Go projects with best practices, modern tooling, and customizable templates

[![Build](https://github.com/kubex-ecosystem/gocrafter/actions/workflows/release.yml/badge.svg)](https://github.com/kubex-ecosystem/gocrafter/actions/workflows/release.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Go Version](https://img.shields.io/badge/go-%3E=1.21-blue)](go.mod)
[![Releases](https://img.shields.io/github/v/release/kubex-ecosystem/gocrafter?include_prereleases)](https://github.com/kubex-ecosystem/gocrafter/releases)

---

## ‚ú® Features

- üéØ **Interactive Project Creation** - Guided wizard for project setup
- üì¶ **Multiple Templates** - Built-in templates for API REST, CLI tools, microservices, gRPC services, and more
- üß© **Pluggable Kits** - Install and use external project kits from repositories
- üîß **Smart Placeholders** - Advanced placeholder system with template functions
- ‚öôÔ∏è **Smart Configuration** - Database, cache, authentication, and DevOps integration
- üõ†Ô∏è **Modern Tooling** - Docker, Kubernetes, CI/CD, Swagger documentation
- üé® **Extensible** - Create and share your own kits
- üöÄ **Production Ready** - Best practices and professional structure

## üèÉ‚Äç‚ôÇÔ∏è Quick Start

### Installation

```bash
# Using Go install
go install github.com/kubex-ecosystem/gocrafter@latest

# Or download from releases
curl -sSL https://github.com/kubex-ecosystem/gocrafter/releases/latest/download/gocrafter-linux-amd64.tar.gz | tar xz
```

### Create Your First Project

#### Using Built-in Templates

```bash
# Interactive mode (recommended for first time)
gocrafter new

# Quick mode with template
gocrafter new my-api --template api-rest

# List available templates
gocrafter list

# Get template details
gocrafter info api-rest
```

#### Using Kits

```bash
# Add a kit from repository
gocrafter kit add https://github.com/user/golang-api-kit

# List installed kits
gocrafter kit list

# Create project from kit
gocrafter new my-project --kit golang-api-kit --author "Your Name"

# Get kit information
gocrafter kit info golang-api-kit
```

## üì¶ Available Templates

| Template | Description | Features |
|----------|-------------|----------|
| **api-rest** | REST API server | Gin framework, middleware, health checks, Swagger |
| **cli-tool** | Command-line application | Cobra framework, subcommands, configuration |
| **microservice** | Microservice architecture | gRPC + HTTP, service discovery, metrics |
| **grpc-service** | Pure gRPC service | Protocol buffers, streaming, service mesh ready |
| **worker** | Background job processor | Queue integration, retry mechanisms, monitoring |
| **library** | Go library/package | Documentation, testing, CI/CD workflows |

## üéØ Example: Creating a REST API

```bash
$ gocrafter new my-blog-api --template api-rest
üöÄ Starting project generation...
‚úÖ Project generated successfully!
üìÅ Location: my-blog-api

Next steps:
  cd my-blog-api
  make run    # Start the application
  make test   # Run tests
  make build  # Build the application
```

**Generated project structure:**

```
my-blog-api/
‚îú‚îÄ‚îÄ cmd/main.go              # Application entry point
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/             # Configuration management
‚îÇ   ‚îú‚îÄ‚îÄ handler/            # HTTP handlers
‚îÇ   ‚îú‚îÄ‚îÄ middleware/         # HTTP middleware
‚îÇ   ‚îú‚îÄ‚îÄ model/              # Data models
‚îÇ   ‚îú‚îÄ‚îÄ repository/         # Data access layer
‚îÇ   ‚îî‚îÄ‚îÄ service/            # Business logic
‚îú‚îÄ‚îÄ pkg/                    # Public packages
‚îú‚îÄ‚îÄ Makefile               # Build automation
‚îú‚îÄ‚îÄ Dockerfile             # Container configuration
‚îú‚îÄ‚îÄ docker-compose.yml     # Development environment
‚îú‚îÄ‚îÄ .env.example           # Environment template
‚îî‚îÄ‚îÄ README.md              # Project documentation
```

## ‚öôÔ∏è Configuration Options

GoCrafter supports extensive configuration through interactive prompts:

### Database Support

- **PostgreSQL** - Production-ready with connection pooling
- **MySQL** - High-performance relational database
- **MongoDB** - Document-based NoSQL database
- **SQLite** - Embedded database for development

### Caching

- **Redis** - In-memory data structure store
- **Memcached** - High-performance caching system
- **In-Memory** - Built-in Go cache

### Authentication

- **JWT** - JSON Web Token authentication
- **OAuth2** - Third-party authentication providers
- **API Keys** - Simple API key authentication

### DevOps Integration

- **Docker** - Containerization with multi-stage builds
- **Kubernetes** - Production deployment manifests
- **CI/CD** - GitHub Actions, GitLab CI, Jenkins, Azure DevOps

## üõ†Ô∏è Advanced Usage

### Interactive Mode

```bash
$ gocrafter new
üöÄ Welcome to GoCrafter - Go Project Generator!
Let's craft your perfect Go project together...

? What's your project name? my-awesome-api
? What's your Go module name? github.com/username/my-awesome-api
? What type of project do you want to create? api-rest - REST API with HTTP server
? Which database do you want to use? postgres
? Do you want to add a cache layer? redis
? Which additional features do you want to include? [Use arrows to move, space to select]
  ‚óØ Authentication (JWT)
  ‚óâ API Documentation (Swagger)
  ‚óâ Health Checks
  ‚óâ Metrics (Prometheus)
  ‚óØ Distributed Tracing
```

### Quick Mode

```bash
# Create API with specific features
gocrafter new blog-api \
  --template api-rest \
  --output ./projects \
  --config api-config.json

# Create CLI tool
gocrafter new my-cli \
  --template cli-tool \
  --quick

# Create microservice
gocrafter new user-service \
  --template microservice
```

### Template Information

```bash
# List all templates with descriptions
gocrafter list

# Get detailed template information
gocrafter info api-rest

# Show template structure
gocrafter info microservice --show-structure
```

## üìö Documentation

- üìñ [**User Guide**](docs/user-guide.md) - Complete usage documentation
- üõ†Ô∏è [**Template Development**](docs/template-development.md) - Create custom templates
- üèóÔ∏è [**Architecture**](docs/architecture.md) - How GoCrafter works
- üéØ [**Examples**](docs/examples/) - Project examples and tutorials
- ü§ù [**Contributing**](docs/CONTRIBUTING.md) - How to contribute

## üåç Language Support

- [üá∫üá∏ English](README.md)
- [üáßüá∑ Portugu√™s](docs/README.pt-BR.md)

## ü§ù Contributing

We welcome contributions! Please see our [Contributing Guide](docs/CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- [Cobra](https://github.com/spf13/cobra) - CLI framework
- [Survey](https://github.com/AlecAivazis/survey) - Interactive prompts
- [Gin](https://github.com/gin-gonic/gin) - HTTP web framework
- [Logrus](https://github.com/sirupsen/logrus) - Structured logging

---

<p align="center">
  Made with ‚ù§Ô∏è by <a href="https://github.com/rafa-mori">@rafa-mori</a>
</p>

<p align="center">
  <a href="https://github.com/kubex-ecosystem/gocrafter">‚≠ê Give us a star if you find GoCrafter useful!</a>
</p>

/// ROADMAP.md ///
# GoCrafter Roadmap

This document outlines the future direction and planned features for GoCrafter. Our goal is to make GoCrafter the most comprehensive and user-friendly Go project scaffolding tool.

## Version 1.0.0 ‚úÖ (Current - Released June 2025)

### **Core Foundation**

- [x] Interactive CLI wizard with survey prompts
- [x] Template-based project generation
- [x] Built-in templates (api-rest, cli-tool, microservice)
- [x] Configuration management and validation
- [x] Comprehensive documentation
- [x] GitHub Actions CI/CD pipeline
- [x] Multi-platform builds (Linux, macOS, Windows)

## Version 1.1.0 üöß (Next - Q3 2025)

### **Enhanced Templates**

- [ ] **GraphQL API Template** - GraphQL server with schema generation
- [ ] **gRPC Service Template** - Pure gRPC services with protocol buffers
- [ ] **Worker Template** - Background job processing with queues
- [ ] **Library Template** - Go library/package with documentation

### **Template Improvements**

- [ ] **Template Validation** - Validate template structure and metadata
- [ ] **Template Testing** - Automated testing for template generation
- [ ] **Template Dependencies** - Template can depend on other templates
- [ ] **Conditional Features** - More granular feature selection

### **CLI Enhancements**

- [ ] **Template Search** - Search templates by keywords and features
- [ ] **Template Updates** - Update existing projects with template changes
- [ ] **Project Validation** - Validate existing projects against templates
- [ ] **Configuration Files** - Save and reuse project configurations

## Version 1.2.0 üìã (Q4 2025)

### **Advanced Features**

- [ ] **Custom Template Support** - Load templates from local directories
- [ ] **Template Repository** - Remote template repositories
- [ ] **Plugin System** - Extensible plugin architecture
- [ ] **Template Inheritance** - Templates can extend other templates

### **Developer Experience**

- [ ] **VS Code Extension** - Visual Studio Code integration
- [ ] **Web Interface** - Browser-based project generator
- [ ] **Template Editor** - GUI for creating and editing templates
- [ ] **Live Preview** - Preview projects before generation

### **Enterprise Features**

- [ ] **Organization Templates** - Private template repositories
- [ ] **Team Collaboration** - Shared configurations and templates
- [ ] **Template Versioning** - Version control for templates
- [ ] **Audit Logging** - Track template usage and changes

## Version 2.0.0 üîÆ (2026)

### **Cloud Integration**

- [ ] **Cloud Deployment** - Deploy generated projects to cloud platforms
- [ ] **Infrastructure as Code** - Generate Terraform/Pulumi configurations
- [ ] **Container Orchestration** - Kubernetes manifests and Helm charts
- [ ] **CI/CD Pipeline Generation** - Generate complete CI/CD workflows

### **Advanced Templating**

- [ ] **Template Marketplace** - Community template sharing
- [ ] **Template Analytics** - Usage statistics and metrics
- [ ] **AI-Assisted Templates** - AI-powered template suggestions
- [ ] **Interactive Template Builder** - Visual template creation tool

### **Ecosystem Integration**

- [ ] **IDE Integrations** - Support for GoLand, Vim, Emacs
- [ ] **Package Manager Integration** - Integration with Go modules and vendors
- [ ] **Monitoring Integration** - Built-in observability and monitoring
- [ ] **Security Scanning** - Automated security analysis of generated code

## Community & Ecosystem

### Template Ecosystem

- [ ] **Community Templates** - User-contributed templates
- [ ] **Template Certification** - Verified and tested templates
- [ ] **Template Documentation** - Enhanced template documentation
- [ ] **Template Examples** - Sample projects for each template

### Developer Tools

- [ ] **GoCrafter SDK** - Library for building custom tools
- [ ] **Template Testing Framework** - Tools for template developers
- [ ] **Template Linting** - Code quality checks for templates
- [ ] **Template Documentation Generator** - Auto-generate template docs

### Integrations

- [ ] **GitHub App** - GitHub integration for project generation
- [ ] **GitLab Integration** - GitLab project templates
- [ ] **Bitbucket Support** - Bitbucket repository integration
- [ ] **Container Registry** - Pre-built container images

## Long-term Vision (Beyond 2026)

### AI and Machine Learning

- **Intelligent Templates** - Templates that adapt based on usage patterns
- **Code Generation** - AI-powered code completion and generation
- **Best Practice Suggestions** - AI recommendations for project structure
- **Automated Refactoring** - Intelligent code refactoring suggestions

### Enterprise and Scale

- **Multi-Language Support** - Extend beyond Go to other languages
- **Enterprise Dashboard** - Centralized management for organizations
- **Compliance and Governance** - Built-in compliance checking
- **Advanced Analytics** - Deep insights into project generation patterns

### Developer Experience

- **Real-time Collaboration** - Collaborative project creation
- **Live Coding Environment** - Browser-based development environment
- **Integrated Development** - Full development lifecycle management
- **Smart Suggestions** - Context-aware suggestions and completions

## How to Contribute

We welcome contributions to help achieve these goals:

### For Developers

- **Code Contributions** - Implement new features and fix bugs
- **Template Creation** - Create new templates for the community
- **Documentation** - Improve and expand documentation
- **Testing** - Write tests and help with quality assurance

### For the Community

- **Feedback** - Share your experience and suggestions
- **Use Cases** - Share how you use GoCrafter
- **Template Requests** - Request templates for your use cases
- **Bug Reports** - Help us identify and fix issues

### Getting Involved

- **GitHub Issues** - Report bugs and request features
- **GitHub Discussions** - Join community discussions
- **Pull Requests** - Contribute code and documentation
- **Template Submissions** - Submit your own templates

## Feedback and Suggestions

We value community input in shaping the future of GoCrafter:

- **Feature Requests** - [Create an issue](https://github.com/kubex-ecosystem/gocrafter/issues/new?template=feature-request.md)
- **Template Requests** - [Request a template](https://github.com/kubex-ecosystem/gocrafter/issues/new?template=template-request.md)
- **General Feedback** - [Start a discussion](https://github.com/kubex-ecosystem/gocrafter/discussions)
- **Roadmap Input** - Comment on [roadmap discussions](https://github.com/kubex-ecosystem/gocrafter/discussions/categories/roadmap)

---

**Note**: This roadmap is subject to change based on community feedback, market demands, and technical considerations. Features may be moved between versions or postponed as needed.

## Stay Updated

- **GitHub Repository**: [GoCrafter on GitHub](https://github.com/kubex-ecosystem/gocrafter)
- **Release Notes**: [Changelog](https://github.com/kubex-ecosystem/gocrafter/releases)

/// SECURITY.md ///
# Security Policy

## Supported Versions

We actively support and provide security updates for the following versions of GoCrafter:

| Version | Supported          |
| ------- | ------------------ |
| 1.x.x   | :white_check_mark: |
| < 1.0   | :x:                |

## Reporting a Vulnerability

We take the security of GoCrafter seriously. If you have discovered a security vulnerability, please report it privately.

**Please do NOT report security vulnerabilities through public GitHub issues.**

### How to Report

Please use one of these private channels:

- **GitHub Security Advisories**: [Report a vulnerability](https://github.com/kubex-ecosystem/gocrafter/security/advisories/new)
- **Email**: <security@rafamori.dev>

Include as much detail as possible:

- A description of the vulnerability
- Steps to reproduce or proof-of-concept
- The impact and affected versions
- Suggested fix (if you have one)

### What to Expect

- **Acknowledgment**: We'll acknowledge receipt within **48 hours**
- **Initial Assessment**: Initial assessment within **5 business days**
- **Status Updates**: Updates every **7 days** until resolution
- **Resolution**: We'll work to address critical issues quickly
- **Credit**: We'll credit you in release notes (with your permission)

## Security Best Practices

### When Using GoCrafter

- **Review Generated Code**: Always review generated projects before production use
- **Keep Dependencies Updated**: Regularly update dependencies in generated projects
- **Use Environment Variables**: Store sensitive configuration in environment variables
- **Enable Security Features**: Use authentication, validation, and security middleware in templates

### Generated Project Security

GoCrafter templates include security best practices:

- Input validation and sanitization
- Secure authentication patterns (JWT, OAuth2)
- HTTPS/TLS configuration
- CORS protection
- Rate limiting
- Parameterized database queries
- Security headers

## Contact

- **Security Issues**: <security@rafamori.dev> or [GitHub Security Advisories](https://github.com/kubex-ecosystem/gocrafter/security/advisories)
- **General Questions**: [GitHub Issues](https://github.com/kubex-ecosystem/gocrafter/issues) or [Discussions](https://github.com/kubex-ecosystem/gocrafter/discussions)

/// cmd/cli/commands.go ///
package cli

import (
	"github.com/spf13/cobra"
)

// GetCommands returns all available CLI commands
func GetCommands() []*cobra.Command {
	return []*cobra.Command{
		NewCommand(),
		ListCommand(),
		InfoCommand(),
		KitCommand(),
	}
}

/// cmd/cli/common.go ///
package cli

import (
	"math/rand"
	"os"
	"strings"
)

var banners = []string{
	`
  ______            ______                     ______    __
 /      \          /      \                   /      \  |  \
|  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\ ______ |  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\ ______   ______ |  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\_| ‚ñì‚ñì_    ______   ______
| ‚ñì‚ñì __\‚ñì‚ñì/      \| ‚ñì‚ñì   \‚ñì‚ñì/      \ |      \| ‚ñì‚ñì_  \‚ñì‚ñì   ‚ñì‚ñì \  /      \ /      \
| ‚ñì‚ñì|    \  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\ ‚ñì‚ñì     |  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\ \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\ ‚ñì‚ñì \    \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì |  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\
| ‚ñì‚ñì \‚ñì‚ñì‚ñì‚ñì ‚ñì‚ñì  | ‚ñì‚ñì ‚ñì‚ñì   __| ‚ñì‚ñì   \‚ñì‚ñì/      ‚ñì‚ñì ‚ñì‚ñì‚ñì‚ñì     | ‚ñì‚ñì __| ‚ñì‚ñì    ‚ñì‚ñì ‚ñì‚ñì   \‚ñì‚ñì
| ‚ñì‚ñì__| ‚ñì‚ñì ‚ñì‚ñì__/ ‚ñì‚ñì ‚ñì‚ñì__/  \ ‚ñì‚ñì     |  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ‚ñì‚ñì       | ‚ñì‚ñì|  \ ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì ‚ñì‚ñì
 \‚ñì‚ñì    ‚ñì‚ñì\‚ñì‚ñì    ‚ñì‚ñì\‚ñì‚ñì    ‚ñì‚ñì ‚ñì‚ñì      \‚ñì‚ñì    ‚ñì‚ñì ‚ñì‚ñì        \‚ñì‚ñì  ‚ñì‚ñì\‚ñì‚ñì     \ ‚ñì‚ñì
  \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì  \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì  \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì \‚ñì‚ñì       \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\‚ñì‚ñì         \‚ñì‚ñì‚ñì‚ñì  \‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\‚ñì‚ñì      `,

	// Here you can add more banners, they will be randomly selected at runtime on each execution
	// ` SOME OTHER BANNER `,
}

func GetDescriptions(descriptionArg []string, _ bool) map[string]string {
	var description, banner string
	if descriptionArg != nil {
		if strings.Contains(strings.Join(os.Args[0:], ""), "-h") {
			description = descriptionArg[0]
		} else {
			description = descriptionArg[1]
		}
	} else {
		description = ""
	}
	bannerRandLen := len(banners)
	bannerRandIndex := rand.Intn(bannerRandLen)
	banner = banners[bannerRandIndex]
	return map[string]string{"banner": banner, "description": description}
}

/// cmd/cli/kit.go ///
package cli

import (
	"fmt"
	"strings"

	"github.com/AlecAivazis/survey/v2"
	"github.com/kubex-ecosystem/gocrafter/internal/generator"
	"github.com/kubex-ecosystem/gocrafter/internal/types"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
	"github.com/spf13/cobra"
)

// KitCommand creates the kit management command
func KitCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "kit",
		Aliases: []string{"k"},
		Short:   "Manage project kits",
		Long:    `Manage pluggable project kits for generating different types of projects.`,
		Example: `  # Add a new kit from repository
  gocrafter kit add https://github.com/user/my-go-kit

  # List all available kits
  gocrafter kit list

  # Remove a kit
  gocrafter kit remove my-go-kit

  # Update a kit
  gocrafter kit update my-go-kit

  # Show kit information
  gocrafter kit info my-go-kit`,
		Annotations: GetDescriptions([]string{"Manage project kits", "Manage pluggable project kits for generating different types of projects."}, false),
	}

	// Add subcommands
	cmd.AddCommand(
		kitAddCommand(),
		kitListCommand(),
		kitRemoveCommand(),
		kitUpdateCommand(),
		kitInfoCommand(),
	)

	return cmd
}

func kitAddCommand() *cobra.Command {
	var force bool

	cmd := &cobra.Command{
		Use:     "add <repository-url>",
		Aliases: []string{"install", "a"},
		Short:   "Add a new kit from repository",
		Long:    `Add a new project kit from a Git repository or archive URL.`,
		Args:    cobra.ExactArgs(1),
		Example: `  # Add kit from GitHub
  gocrafter kit add https://github.com/user/golang-api-kit

  # Add kit from archive
  gocrafter kit add https://example.com/kits/web-kit.tar.gz

  # Force add (overwrite existing)
  gocrafter kit add --force https://github.com/user/my-kit`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runKitAddCommand(args[0], force)
		},
	}

	cmd.Flags().BoolVarP(&force, "force", "f", false, "Force add kit (overwrite if exists)")
	return cmd
}

func kitListCommand() *cobra.Command {
	var verbose bool

	cmd := &cobra.Command{
		Use:     "list",
		Aliases: []string{"ls", "l"},
		Short:   "List all available kits",
		Long:    `List all installed project kits with their information.`,
		Example: `  # List all kits
  gocrafter kit list

  # List with detailed information
  gocrafter kit list --verbose`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runKitListCommand(verbose)
		},
	}

	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Show detailed information")
	return cmd
}

func kitRemoveCommand() *cobra.Command {
	var force bool

	cmd := &cobra.Command{
		Use:     "remove <kit-name>",
		Aliases: []string{"rm", "uninstall", "delete"},
		Short:   "Remove a kit",
		Long:    `Remove an installed project kit.`,
		Args:    cobra.ExactArgs(1),
		Example: `  # Remove a kit
  gocrafter kit remove my-go-kit

  # Force remove without confirmation
  gocrafter kit remove --force my-go-kit`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runKitRemoveCommand(args[0], force)
		},
	}

	cmd.Flags().BoolVarP(&force, "force", "f", false, "Force remove without confirmation")
	return cmd
}

func kitUpdateCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "update <kit-name>",
		Aliases: []string{"upgrade", "u"},
		Short:   "Update a kit",
		Long:    `Update an installed project kit to the latest version.`,
		Args:    cobra.ExactArgs(1),
		Example: `  # Update a specific kit
  gocrafter kit update my-go-kit

  # Update all kits
  gocrafter kit update --all`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runKitUpdateCommand(args[0])
		},
	}

	return cmd
}

func kitInfoCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "info <kit-name>",
		Aliases: []string{"show", "details"},
		Short:   "Show kit information",
		Long:    `Show detailed information about a specific kit.`,
		Args:    cobra.ExactArgs(1),
		Example: `  # Show kit information
  gocrafter kit info my-go-kit`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runKitInfoCommand(args[0])
		},
	}

	return cmd
}

// Command implementations

func runKitAddCommand(repoURL string, force bool) error {
	gl.Log("info", fmt.Sprintf("Adding kit from repository: %s", repoURL))

	// Initialize kit manager
	kitManager, err := generator.NewKitManager(nil)
	if err != nil {
		return fmt.Errorf("failed to initialize kit manager: %w", err)
	}

	// Extract kit name for force check
	kitName := extractKitNameFromURL(repoURL)
	if kitName == "" {
		return fmt.Errorf("could not extract kit name from URL")
	}

	// Check if kit already exists
	if !force {
		_, err := kitManager.GetKit(kitName)
		if err == nil {
			// Kit exists, ask for confirmation
			var overwrite bool
			prompt := &survey.Confirm{
				Message: fmt.Sprintf("Kit '%s' already exists. Overwrite?", kitName),
			}
			if err := survey.AskOne(prompt, &overwrite); err != nil {
				return fmt.Errorf("prompt failed: %w", err)
			}
			if !overwrite {
				gl.Log("info", "Kit installation cancelled")
				return nil
			}
			// Remove existing kit
			if err := kitManager.RemoveKit(kitName); err != nil {
				return fmt.Errorf("failed to remove existing kit: %w", err)
			}
		}
	} else {
		// Force mode: remove existing kit if it exists
		if _, err := kitManager.GetKit(kitName); err == nil {
			if err := kitManager.RemoveKit(kitName); err != nil {
				gl.Log("warn", fmt.Sprintf("Failed to remove existing kit: %v", err))
			}
		}
	}

	// Add the kit
	if err := kitManager.AddKit(repoURL); err != nil {
		return fmt.Errorf("failed to add kit: %w", err)
	}

	gl.Log("info", fmt.Sprintf("Kit '%s' added successfully", kitName))
	return nil
}

func runKitListCommand(verbose bool) error {
	// Initialize kit manager
	kitManager, err := generator.NewKitManager(nil)
	if err != nil {
		return fmt.Errorf("failed to initialize kit manager: %w", err)
	}

	// Get all kits
	kits, err := kitManager.ListKits()
	if err != nil {
		return fmt.Errorf("failed to list kits: %w", err)
	}

	if len(kits) == 0 {
		gl.Log("info", "No kits installed")
		gl.Log("info", "Use 'gocrafter kit add <repository-url>' to add a kit")
		return nil
	}

	gl.Log("info", fmt.Sprintf("üì¶ Installed Kits (%d):", len(kits)))
	gl.Log("info", "")

	for _, kit := range kits {
		if verbose {
			printKitDetailed(kit)
		} else {
			printKitSummary(kit)
		}
	}

	return nil
}

func runKitRemoveCommand(kitName string, force bool) error {
	// Initialize kit manager
	kitManager, err := generator.NewKitManager(nil)
	if err != nil {
		return fmt.Errorf("failed to initialize kit manager: %w", err)
	}

	// Check if kit exists
	_, err = kitManager.GetKit(kitName)
	if err != nil {
		return fmt.Errorf("kit '%s' not found", kitName)
	}

	// Ask for confirmation unless force is used
	if !force {
		var confirm bool
		prompt := &survey.Confirm{
			Message: fmt.Sprintf("Are you sure you want to remove kit '%s'?", kitName),
		}
		if err := survey.AskOne(prompt, &confirm); err != nil {
			return fmt.Errorf("prompt failed: %w", err)
		}
		if !confirm {
			gl.Log("info", "Kit removal cancelled")
			return nil
		}
	}

	// Remove the kit
	if err := kitManager.RemoveKit(kitName); err != nil {
		return fmt.Errorf("failed to remove kit: %w", err)
	}

	return nil
}

func runKitUpdateCommand(kitName string) error {
	// Initialize kit manager
	kitManager, err := generator.NewKitManager(nil)
	if err != nil {
		return fmt.Errorf("failed to initialize kit manager: %w", err)
	}

	// Update the kit
	if err := kitManager.UpdateKit(kitName); err != nil {
		return fmt.Errorf("failed to update kit: %w", err)
	}

	return nil
}

func runKitInfoCommand(kitName string) error {
	// Initialize kit manager
	kitManager, err := generator.NewKitManager(nil)
	if err != nil {
		return fmt.Errorf("failed to initialize kit manager: %w", err)
	}

	// Get kit information
	kit, err := kitManager.GetKit(kitName)
	if err != nil {
		return fmt.Errorf("kit '%s' not found", kitName)
	}

	// Print detailed kit information
	printKitDetailed(*kit)

	// Show placeholders
	kitGenerator := generator.NewKitGenerator(kitManager)
	placeholders, err := kitGenerator.GetKitPlaceholders(kitName)
	if err != nil {
		gl.Log("warn", fmt.Sprintf("Failed to get placeholders: %v", err))
	} else if len(placeholders) > 0 {
		gl.Log("info", "")
		gl.Log("info", "üìù Required Placeholders:")
		for _, placeholder := range placeholders {
			gl.Log("info", fmt.Sprintf("   ‚Ä¢ %s", placeholder))
		}
	}

	return nil
}

// Helper functions

func extractKitNameFromURL(repoURL string) string {
	if strings.Contains(repoURL, "github.com") {
		parts := strings.Split(repoURL, "/")
		if len(parts) >= 2 {
			name := parts[len(parts)-1]
			return strings.TrimSuffix(name, ".git")
		}
	}

	parts := strings.Split(strings.TrimSuffix(repoURL, "/"), "/")
	if len(parts) > 0 {
		return strings.TrimSuffix(parts[len(parts)-1], ".git")
	}

	return ""
}

func printKitSummary(kit types.Kit) {
	gl.Log("info", fmt.Sprintf("üì¶ %s", kit.Name))
	if kit.Description != "" {
		gl.Log("info", fmt.Sprintf("   %s", kit.Description))
	}
	if kit.Language != "" {
		gl.Log("info", fmt.Sprintf("   Language: %s", kit.Language))
	}
	gl.Log("info", "")
}

func printKitDetailed(kit types.Kit) {
	gl.Log("info", fmt.Sprintf("üì¶ %s", kit.Name))

	if kit.Description != "" {
		gl.Log("info", fmt.Sprintf("   Description: %s", kit.Description))
	}
	if kit.Language != "" {
		gl.Log("info", fmt.Sprintf("   Language: %s", kit.Language))
	}
	if kit.Version != "" {
		gl.Log("info", fmt.Sprintf("   Version: %s", kit.Version))
	}
	if kit.Author != "" {
		gl.Log("info", fmt.Sprintf("   Author: %s", kit.Author))
	}
	if kit.Repository != "" {
		gl.Log("info", fmt.Sprintf("   Repository: %s", kit.Repository))
	}
	if kit.LocalPath != "" {
		gl.Log("info", fmt.Sprintf("   Path: %s", kit.LocalPath))
	}

	if len(kit.Dependencies) > 0 {
		gl.Log("info", "   Dependencies:")
		for _, dep := range kit.Dependencies {
			gl.Log("info", fmt.Sprintf("     ‚Ä¢ %s", dep))
		}
	}

	if len(kit.Tags) > 0 {
		gl.Log("info", fmt.Sprintf("   Tags: %s", strings.Join(kit.Tags, ", ")))
	}

	gl.Log("info", "")
}

/// cmd/cli/list.go ///
package cli

import (
	"fmt"
	"path/filepath"

	"github.com/kubex-ecosystem/gocrafter/internal/generator"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
	"github.com/spf13/cobra"
)

// ListCommand creates a command to list available templates
func ListCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "list",
		Aliases: []string{"ls", "templates"},
		Short:   "List available project templates",
		Long:    `List all available project templates with their descriptions.`,
		Example: `  # List all templates
  gocrafter list

  # List templates (alias)
  gocrafter templates`,
		Annotations: GetDescriptions([]string{"List available project templates", "List all available project templates with their descriptions."}, false),
		RunE: func(cmd *cobra.Command, args []string) error {
			return runListCommand()
		},
	}

	return cmd
}

func runListCommand() error {
	gl.Log("info", "üéØ Available Project Templates:")

	templates := generator.SupportedTemplates()
	templateDescriptions := map[string]string{
		"api-rest":     "REST API server with HTTP endpoints (Gin/Fiber)",
		"cli-tool":     "Command-line application with Cobra framework",
		"microservice": "Microservice with gRPC and HTTP endpoints",
		"grpc-service": "Pure gRPC service with protocol buffers",
		"worker":       "Background worker for job processing",
		"library":      "Go library/package for reusable code",
	}

	templateFeatures := map[string][]string{
		"api-rest": {
			"HTTP server with routing",
			"Middleware support",
			"Database integration",
			"Authentication ready",
			"API documentation",
		},
		"cli-tool": {
			"Cobra CLI framework",
			"Subcommands support",
			"Configuration management",
			"Logging system",
			"Cross-platform builds",
		},
		"microservice": {
			"gRPC and HTTP servers",
			"Service discovery",
			"Health checks",
			"Metrics collection",
			"Distributed tracing",
		},
		"grpc-service": {
			"Protocol buffers",
			"gRPC server",
			"Client generation",
			"Streaming support",
			"Service mesh ready",
		},
		"worker": {
			"Job queue integration",
			"Background processing",
			"Retry mechanisms",
			"Monitoring hooks",
			"Graceful shutdown",
		},
		"library": {
			"Package structure",
			"Documentation templates",
			"Testing framework",
			"CI/CD workflows",
			"Version management",
		},
	}

	for _, tmpl := range templates {
		desc := templateDescriptions[tmpl]
		features := templateFeatures[tmpl]

		gl.Log("info", fmt.Sprintf("üì¶ %s\n", tmpl))
		gl.Log("info", fmt.Sprintf("   %s\n", desc))

		if len(features) > 0 {
			gl.Log("info", "   Features:")
			for _, feature := range features {
				gl.Log("info", fmt.Sprintf("   ‚Ä¢ %s\n", feature))
			}
		}
	}

	gl.Log("info", fmt.Sprintf("üí° Usage:"))
	gl.Log("info", fmt.Sprintf("   gocrafter new --template <template-name>"))
	gl.Log("info", fmt.Sprintf("   gocrafter new  # Interactive mode"))

	return nil
}

// InfoCommand creates a command to show detailed information about a template
func InfoCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "info <template-name>",
		Short: "Show detailed information about a template",
		Long:  `Show detailed information about a specific template including its structure and features.`,
		Example: `  # Show info about api-rest template
  gocrafter info api-rest

  # Show info about cli-tool template
  gocrafter info cli-tool`,
		Args:        cobra.ExactArgs(1),
		Annotations: GetDescriptions([]string{"Show detailed information about a template", "Show detailed information about a specific template including its structure and features."}, false),
		RunE: func(cmd *cobra.Command, args []string) error {
			return runInfoCommand(args[0])
		},
	}

	return cmd
}

func runInfoCommand(templateName string) error {
	// Check if template exists
	supportedTemplates := generator.SupportedTemplates()
	templateExists := false
	for _, tmpl := range supportedTemplates {
		if tmpl == templateName {
			templateExists = true
			break
		}
	}

	if !templateExists {
		return fmt.Errorf("template '%s' not found. Run 'gocrafter list' to see available templates", templateName)
	}

	// Get templates path
	templatesPath, err := getTemplatesPath()
	if err != nil {
		return fmt.Errorf("failed to get templates path: %w", err)
	}

	// Get template info
	info, err := generator.GetTemplateInfo(templatesPath, templateName)
	if err != nil {
		return fmt.Errorf("failed to get template info: %w", err)
	}

	// Display template information
	gl.Log("info", fmt.Sprintf("üì¶ Template: %s\n", info.Name))
	gl.Log("info", fmt.Sprintf("üìù Description: %s\n", info.Description))
	gl.Log("info", fmt.Sprintf("üè∑Ô∏è  Version: %s\n", info.Version))

	if info.Author != "" {
		gl.Log("info", fmt.Sprintf("üë§ Author: %s\n", info.Author))
	}

	if len(info.Tags) > 0 {
		gl.Log("info", fmt.Sprintf("üè∑Ô∏è  Tags: %s\n", joinStrings(info.Tags, ", ")))
	}

	if len(info.Features) > 0 {
		gl.Log("info", "\n‚ú® Features:")
		for _, feature := range info.Features {
			gl.Log("info", fmt.Sprintf("   ‚Ä¢ %s\n", feature))
		}
	}

	// Show template structure
	gl.Log("info", "\nüìÅ Template Structure:")
	templatePath := filepath.Join(templatesPath, templateName)
	if err := showTemplateStructure(templatePath, ""); err != nil {
		gl.Log("info", fmt.Sprintf("   (Unable to show structure: %s)\n", err))
	}

	gl.Log("info", "\nüí° Usage:")
	gl.Log("info", fmt.Sprintf("   gocrafter new --template %s\n", templateName))
	gl.Log("info", fmt.Sprintf("   gocrafter new my-project --template %s\n", templateName))

	return nil
}

func showTemplateStructure(templatePath, indent string) error {
	// This would walk through the template directory and show its structure
	// For now, we'll show a placeholder
	gl.Log("info", fmt.Sprintf("%s   (Template structure will be shown here)\n", indent))
	return nil
}

func joinStrings(strs []string, separator string) string {
	if len(strs) == 0 {
		return ""
	}

	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += separator + strs[i]
	}

	return result
}

/// cmd/cli/new.go ///
package cli

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/kubex-ecosystem/gocrafter/internal/generator"
	"github.com/kubex-ecosystem/gocrafter/internal/prompt"
	"github.com/kubex-ecosystem/gocrafter/internal/types"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
	"github.com/spf13/cobra"
)

// NewCommand creates a new project generation command
func NewCommand() *cobra.Command {
	var (
		template   string
		kit        string
		outputDir  string
		configFile string
		quick      bool
		author     string
		license    string
	)

	cmd := &cobra.Command{
		Use:   "new [project-name]",
		Short: "Create a new Go project from template or kit",
		Long: `Create a new Go project using one of the available templates or kits.
This command will guide you through an interactive setup process
or you can use flags for quick generation.

Templates are built-in project structures, while kits are pluggable
external project templates that can be added from repositories.`,
		Example: `  # Interactive mode
  gocrafter new

  # Quick mode with built-in template
  gocrafter new my-api --template api-rest

  # Use a kit
  gocrafter new my-project --kit golang-web-api

  # Use configuration file
  gocrafter new --config project.json

  # Specify output directory and author
  gocrafter new my-service --kit microservice --output /path/to/projects --author "John Doe"`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runNewCommand(args, template, kit, outputDir, configFile, quick, author, license)
		},
	}

	cmd.Flags().StringVarP(&template, "template", "t", "", "Built-in template to use (api-rest, cli-tool, microservice, etc.)")
	cmd.Flags().StringVarP(&kit, "kit", "k", "", "Kit to use for project generation")
	cmd.Flags().StringVarP(&outputDir, "output", "o", "", "Output directory for the new project")
	cmd.Flags().StringVarP(&configFile, "config", "c", "", "Configuration file to use")
	cmd.Flags().BoolVarP(&quick, "quick", "q", false, "Quick mode with minimal prompts")
	cmd.Flags().StringVarP(&author, "author", "a", "", "Project author name")
	cmd.Flags().StringVarP(&license, "license", "l", "MIT", "Project license")

	return cmd
}

func runNewCommand(args []string, template, kit, outputDir, configFile string, quick bool, author, license string) error {
	// Validate that both template and kit are not specified
	if template != "" && kit != "" {
		return fmt.Errorf("cannot specify both template and kit. Use either --template or --kit")
	}

	// If kit is specified, use kit generation
	if kit != "" {
		return runKitGeneration(args, kit, outputDir, author, license)
	}

	// Otherwise, use traditional template generation
	return runTemplateGeneration(args, template, outputDir, configFile, quick)
}

func runKitGeneration(args []string, kitName, outputDir, author, license string) error {
	// Validate project name
	if len(args) == 0 {
		return fmt.Errorf("project name is required when using kit generation")
	}

	projectName := args[0]

	// Initialize kit manager
	kitManager, err := generator.NewKitManager(nil)
	if err != nil {
		return fmt.Errorf("failed to initialize kit manager: %w", err)
	}

	// Create kit generator
	kitGenerator := generator.NewKitGenerator(kitManager)

	// Set output path
	if outputDir == "" {
		outputDir = filepath.Join(".", projectName)
	} else {
		outputDir = filepath.Join(outputDir, projectName)
	}

	// Get kit placeholders
	placeholders, err := kitGenerator.GetKitPlaceholders(kitName)
	if err != nil {
		return fmt.Errorf("failed to get kit placeholders: %w", err)
	}

	// Create placeholder values
	var placeholderValues []types.PlaceholderValue

	// Add basic placeholders
	if author != "" {
		placeholderValues = append(placeholderValues, types.PlaceholderValue{
			Name:  "author",
			Value: author,
		})
	}

	if license != "" {
		placeholderValues = append(placeholderValues, types.PlaceholderValue{
			Name:  "license",
			Value: license,
		})
	}

	// Prompt for additional placeholders
	prompter := prompt.NewKitPrompt()
	additionalPlaceholders, err := prompter.PromptForPlaceholders(placeholders, placeholderValues)
	if err != nil {
		return fmt.Errorf("failed to prompt for placeholders: %w", err)
	}

	// Merge placeholders
	placeholderValues = append(placeholderValues, additionalPlaceholders...)

	// Create generation request
	req := &types.GenerationRequest{
		KitName:      kitName,
		ProjectName:  projectName,
		OutputPath:   outputDir,
		Placeholders: placeholderValues,
	}

	// Validate request
	if err := kitGenerator.ValidateGenerationRequest(req); err != nil {
		return fmt.Errorf("generation request validation failed: %w", err)
	}

	// Generate project
	if err := kitGenerator.GenerateFromKit(req); err != nil {
		return fmt.Errorf("kit generation failed: %w", err)
	}

	// Success message
	gl.Log("info", "‚úÖ Project generated successfully from kit!")
	gl.Log("info", fmt.Sprintf("üìÅ Location: %s", outputDir))
	gl.Log("info", fmt.Sprintf("üì¶ Kit: %s", kitName))
	gl.Log("info", "Next steps:")
	gl.Log("info", fmt.Sprintf("  cd %s", projectName))
	gl.Log("info", "  # Check the generated README.md for specific instructions")

	return nil
}

func runTemplateGeneration(args []string, template, outputDir, configFile string, quick bool) error {
	var config *generator.ProjectConfig
	var err error

	// Load from config file if provided
	if configFile != "" {
		gl.Log("info", fmt.Sprintf("Loading configuration from file: %s", configFile))
		// TODO: Implement config file loading
		return fmt.Errorf("config file loading not yet implemented")
	}

	// Quick mode
	if quick && template != "" {
		gl.Log("info", fmt.Sprintf("Running in quick mode with template: %s", template))
		config, err = prompt.QuickPrompt(template)
		if err != nil {
			return fmt.Errorf("quick prompt failed: %w", err)
		}
	} else if template != "" && len(args) > 0 {
		// Direct mode with template and project name
		config = generator.NewProjectConfig()
		config.Name = args[0]
		config.Template = template
		config.Module = fmt.Sprintf("github.com/user/%s", args[0]) // Default module name
	} else {
		// Interactive mode
		gl.Log("info", "Running interactive mode")
		prompter := prompt.NewInteractivePrompt()
		config, err = prompter.Run()
		if err != nil {
			return fmt.Errorf("interactive prompt failed: %w", err)
		}
	}

	// Set output directory if provided
	if outputDir != "" {
		config.OutputDir = outputDir
	}

	// Validate configuration
	if err := config.Validate(); err != nil {
		return fmt.Errorf("configuration validation failed: %w", err)
	}

	// Get templates path
	templatesPath, err := getTemplatesPath()
	if err != nil {
		return fmt.Errorf("failed to get templates path: %w", err)
	}

	// Create generator and generate project
	gen := generator.NewGenerator(config, templatesPath)
	if err := gen.Generate(); err != nil {
		return fmt.Errorf("project generation failed: %w", err)
	}

	// Success message
	gl.Log("info", "‚úÖ Project generated successfully!")
	gl.Log("info", fmt.Sprintf("üìÅ Location: %s", config.GetOutputPath()))
	gl.Log("info", "Next steps:")
	gl.Log("info", fmt.Sprintf("  cd %s", config.Name))
	gl.Log("info", "  make run    # Start the application")
	gl.Log("info", "  make test   # Run tests")
	gl.Log("info", "  make build  # Build the application")

	return nil
}

func getTemplatesPath() (string, error) {
	// Try to find templates directory relative to the executable
	// First, try relative to current working directory
	if _, err := os.Stat("templates"); err == nil {
		return "templates", nil
	}

	// Try relative to the executable location
	executable, err := os.Executable()
	if err != nil {
		return "", err
	}

	execDir := filepath.Dir(executable)
	templatesPath := filepath.Join(execDir, "templates")
	if _, err := os.Stat(templatesPath); err == nil {
		return templatesPath, nil
	}

	// Try one level up from executable (for development)
	templatesPath = filepath.Join(execDir, "..", "templates")
	if _, err := os.Stat(templatesPath); err == nil {
		return templatesPath, nil
	}

	return "", fmt.Errorf("templates directory not found")
}

/// cmd/cli/service.go ///
package cli

import (
	gl "github.com/kubex-ecosystem/gocrafter/logger"
	"github.com/spf13/cobra"
)

func ServiceCmdList() []*cobra.Command {
	return []*cobra.Command{
		startCommand(),
	}
}

func startCommand() *cobra.Command {
	var debug bool

	var startCmd = &cobra.Command{
		Use: "start",
		Annotations: GetDescriptions([]string{
			"Start some command.",
			"This command is used to start the GoCrafter service with the specified configuration.",
		}, false),
		Run: func(cmd *cobra.Command, args []string) {
			if debug {
				gl.SetDebug(true)
				gl.Log("debug", "Debug mode enabled")
			}
			gl.Log("success", "GoCrafter service started successfully")
		},
	}

	startCmd.Flags().BoolVarP(&debug, "debug", "d", false, "Enable debug mode")

	return startCmd
}

/// cmd/main.go ///
package main

import (
	gl "github.com/kubex-ecosystem/gocrafter/logger"
)

// This file is the entry point for the GoCrafter CLI application.
// It initializes the logger and starts the application by executing the main command.
// It allows the application to be run as a standalone CLI tool.

// main initializes the logger and creates a new GoCrafter instance.
func main() {
	if err := RegX().Command().Execute(); err != nil {
		gl.Log("fatal", err.Error())
	}
}

/// cmd/usage.go ///
package main

import (
	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

// colorYellow, colorGreen, colorBlue, colorRed, and colorHelp are utility functions
// that return a string formatted with the specified color using the fatih/color package.
// These functions are used to colorize output in the CLI usage template.
// They are registered as template functions in the CLI usage template to allow
// coloring specific parts of the command usage output.
func colorYellow(s string) string {
	return color.New(color.FgYellow).SprintFunc()(s)
}

func colorGreen(s string) string {
	return color.New(color.FgGreen).SprintFunc()(s)
}

func colorBlue(s string) string {
	return color.New(color.FgBlue).SprintFunc()(s)
}

func colorRed(s string) string {
	return color.New(color.FgRed).SprintFunc()(s)
}

func colorHelp(s string) string {
	return color.New(color.FgCyan).SprintFunc()(s)
}

func hasServiceCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] == "true" {
			return true
		}
	}
	return false
}

func hasModuleCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] != "true" {
			return true
		}
	}
	return false
}

func setUsageDefinition(cmd *cobra.Command) {
	cobra.AddTemplateFunc("colorYellow", colorYellow)
	cobra.AddTemplateFunc("colorGreen", colorGreen)
	cobra.AddTemplateFunc("colorRed", colorRed)
	cobra.AddTemplateFunc("colorBlue", colorBlue)
	cobra.AddTemplateFunc("colorHelp", colorHelp)
	cobra.AddTemplateFunc("hasServiceCommands", hasServiceCommands)
	cobra.AddTemplateFunc("hasModuleCommands", hasModuleCommands)

	// Altera o template de uso do cobra
	cmd.SetUsageTemplate(cliUsageTemplate)
}

var cliUsageTemplate = `{{- if index .Annotations "banner" }}{{colorBlue (index .Annotations "banner")}}{{end}}{{- if (index .Annotations "description") }}
{{index .Annotations "description"}}
{{- end }}

{{colorYellow "Usage:"}}{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command] [args]{{end}}{{if gt (len .Aliases) 0}}

{{colorYellow "Aliases:"}}
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

{{colorYellow "Example:"}}
  {{.Example}}{{end}}{{if .HasAvailableSubCommands}}
{{colorYellow "Available Commands:"}}{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{colorGreen (rpad .Name .NamePadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

{{colorYellow "Flags:"}}
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasAvailableInheritedFlags}}

{{colorYellow "Global Options:"}}
  {{.InheritedFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasHelpSubCommands}}

{{colorYellow "Additional help topics:"}}
{{range .Commands}}{{if .IsHelpCommand}}
  {{colorGreen (rpad .CommandPath .CommandPathPadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasSubCommands}}

{{colorYellow (printf "Use \"%s [command] --help\" for more information about a command." .CommandPath)}}{{end}}
`

/// cmd/wrpr.go ///
package main

import (
	"github.com/kubex-ecosystem/gocrafter/cmd/cli"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
	vs "github.com/kubex-ecosystem/gocrafter/version"
	"github.com/spf13/cobra"

	"os"
	"strings"
)

type GoCrafter struct {
	parentCmdName string
	printBanner   bool
}

func (m *GoCrafter) Alias() string {
	return "craft"
}
func (m *GoCrafter) ShortDescription() string {
	return "GoCrafter is a Go project scaffolding and templating tool."
}
func (m *GoCrafter) LongDescription() string {
	return `GoCrafter: A Go project scaffolding and templating tool.
Create production-ready Go projects with best practices, modern tooling, and customizable templates.`
}
func (m *GoCrafter) Usage() string {
	return "gocrafter [command] [args]"
}
func (m *GoCrafter) Examples() []string {
	return []string{
		"gocrafter new                    # Interactive project creation",
		"gocrafter new --template api-rest # Quick API project",
		"gocrafter list                   # Show available templates",
		"gocrafter info api-rest          # Show template details",
	}
}
func (m *GoCrafter) Active() bool {
	return true
}
func (m *GoCrafter) Module() string {
	return "gocrafter"
}
func (m *GoCrafter) Execute() error {
	return m.Command().Execute()
}
func (m *GoCrafter) Command() *cobra.Command {
	gl.Log("debug", "Starting GoCrafter CLI...")

	var rtCmd = &cobra.Command{
		Use:         m.Module(),
		Aliases:     []string{m.Alias()},
		Example:     m.concatenateExamples(),
		Version:     vs.GetVersion(),
		Annotations: cli.GetDescriptions([]string{m.LongDescription(), m.ShortDescription()}, m.printBanner),
	}

	// Add GoCrafter commands
	rtCmd.AddCommand(cli.GetCommands()...)
	rtCmd.AddCommand(vs.CliCommand())

	// Set usage definitions for the command and its subcommands
	setUsageDefinition(rtCmd)

	for _, c := range rtCmd.Commands() {

		setUsageDefinition(c)

		if !strings.Contains(strings.Join(os.Args, " "), c.Use) {
			if c.Short == "" {
				c.Short = c.Annotations["description"]
			}
		}
	}

	return rtCmd
}
func (m *GoCrafter) SetParentCmdName(rtCmd string) {
	m.parentCmdName = rtCmd
}
func (m *GoCrafter) concatenateExamples() string {
	examples := ""
	rtCmd := m.parentCmdName
	if rtCmd != "" {
		rtCmd = rtCmd + " "
	}
	for _, example := range m.Examples() {
		examples += rtCmd + example + "\n  "
	}
	return examples
}
func RegX() *GoCrafter {
	var printBannerV = os.Getenv("GOCRAFTER_PRINT_BANNER")
	if printBannerV == "" {
		printBannerV = "true"
	}

	return &GoCrafter{
		printBanner: strings.ToLower(printBannerV) == "true",
	}
}

/// docs/CONTRIBUTING.md ///
# Contributing to GoCrafter

Thank you for your interest in contributing to **GoCrafter**! We welcome contributions from the community and are excited to have you join us in making GoCrafter the best Go project scaffolding tool.

## Code of Conduct

By participating in this project, you agree to abide by our [Code of Conduct](../CODE_OF_CONDUCT.md). Please be respectful and professional in all interactions.

## How to Contribute

There are many ways to contribute to GoCrafter:

### üêõ Report Bugs

- Found a bug? Open an issue with detailed information
- Include steps to reproduce, expected vs actual behavior
- Provide your Go version, OS, and GoCrafter version

### üí° Suggest Features

- Have an idea for improvement? Open an issue with the `enhancement` label
- Describe the problem you're trying to solve
- Suggest a possible solution or approach

### üìù Improve Documentation

- Fix typos, improve clarity, or add examples
- Translate documentation to other languages
- Create tutorials or guides

### üîß Submit Code Changes

- Fix bugs or implement new features
- Add new templates or improve existing ones
- Improve performance or code quality

### üß™ Test and Review

- Test pull requests and provide feedback
- Review code changes and suggest improvements
- Help validate new features

## Getting Started

### Prerequisites

Before contributing, ensure you have:

- **Go 1.21+** installed ([Download Go](https://golang.org/dl/))
- **Git** for version control
- A **GitHub account** for pull requests

Quick Go installation (optional):

```bash
# Using go-installer (easy way)
bash -c "$(curl -fsSL https://raw.githubusercontent.com/kubex-ecosystem/gosetup/main/install.sh)"
```

### Setting Up Your Development Environment

1. **Fork and Clone**

   ```bash
   # Fork the repository on GitHub first
   git clone https://github.com/kubex-ecosystem/gocrafter.git
   cd gocrafter

   # Add upstream remote
   git remote add upstream https://github.com/kubex-ecosystem/gocrafter.git
   ```

2. **Install Dependencies**

   ```bash
   # Download Go modules
   go mod download

   # Install development tools
   go install golang.org/x/tools/cmd/goimports@latest
   go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
   ```

3. **Build and Test**

   ```bash
   # Build the project
   go build -o gocrafter .

   # Run tests
   go test ./...

   # Test the CLI
   ./gocrafter list
   ```

4. **Verify Everything Works**

   ```bash
   # Create a test project
   ./gocrafter new test-project --template api-rest
   cd test-project
   go mod tidy
   go build
   ```

## Development Workflow

### Making Changes

1. **Create a Feature Branch**

   ```bash
   git checkout -b feature/your-feature-name
   # or
   git checkout -b fix/issue-description
   ```

2. **Write Code**
   - Follow Go best practices and conventions
   - Add appropriate comments and documentation
   - Write tests for new functionality

3. **Test Your Changes**

   ```bash
   # Run all tests
   go test ./...

   # Run linting
   golangci-lint run

   # Format code
   goimports -w .
   ```

4. **Commit Changes**

   ```bash
   git add .
   git commit -m "type: brief description of changes"
   ```

   Use conventional commit types:
   - `feat:` - New features
   - `fix:` - Bug fixes
   - `docs:` - Documentation changes
   - `style:` - Code style changes
   - `refactor:` - Code refactoring
   - `test:` - Adding tests
   - `chore:` - Maintenance tasks

5. **Push and Create PR**

   ```bash
   git push origin feature/your-feature-name
   ```

   Then create a Pull Request on GitHub.

## Code Standards

### Go Style Guide

We follow the standard Go style guide:

- Use `gofmt` and `goimports` for formatting
- Follow [Effective Go](https://golang.org/doc/effective_go.html) guidelines
- Use meaningful variable and function names
- Add comments for exported functions and types
- Keep functions small and focused

### Project Structure

```
gocrafter/
‚îú‚îÄ‚îÄ cmd/                    # CLI entry points
‚îú‚îÄ‚îÄ internal/               # Private packages
‚îÇ   ‚îú‚îÄ‚îÄ cli/               # CLI commands
‚îÇ   ‚îú‚îÄ‚îÄ generator/         # Project generation logic
‚îÇ   ‚îî‚îÄ‚îÄ prompt/            # Interactive prompts
‚îú‚îÄ‚îÄ templates/             # Project templates
‚îú‚îÄ‚îÄ docs/                  # Documentation
‚îî‚îÄ‚îÄ tests/                 # Integration tests
```

### Template Development

When creating or modifying templates:

1. Follow the [Template Development Guide](template-development.md)
2. Include proper `template.json` metadata
3. Use template variables consistently
4. Test generation with various configurations
5. Document template features and usage

## Testing

### Unit Tests

- Write tests for all new functions
- Aim for good test coverage
- Use table-driven tests where appropriate
- Mock external dependencies

```bash
# Run tests with coverage
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

### Integration Tests

- Test CLI commands end-to-end
- Verify template generation works correctly
- Test with different configurations

```bash
# Run integration tests
go test -tags=integration ./tests/...
```

## Pull Request Guidelines

### Before Submitting

- [ ] Code follows Go style guidelines
- [ ] Tests pass (`go test ./...`)
- [ ] Linting passes (`golangci-lint run`)
- [ ] Documentation is updated
- [ ] Commit messages follow conventional format

### PR Description

Please include:

1. **What** - What changes were made?
2. **Why** - Why were these changes needed?
3. **How** - How do the changes work?
4. **Testing** - How were the changes tested?

### Example PR Template

```markdown
## Description
Brief description of the changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Tests pass
- [ ] Manual testing completed
- [ ] New tests added

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
```

## Adding New Templates

To add a new template:

1. Create template directory in `templates/`
2. Add `template.json` with metadata
3. Create template files with Go template syntax
4. Test template generation
5. Update documentation
6. Add to template list in CLI

See [Template Development Guide](template-development.md) for details.

## Documentation

### Writing Documentation

- Use clear, concise language
- Include code examples
- Add screenshots where helpful
- Keep documentation up-to-date with code changes

### Documentation Structure

- `README.md` - Main project overview
- `docs/user-guide.md` - Complete user documentation
- `docs/template-development.md` - Template creation guide
- `docs/CONTRIBUTING.md` - This file
- `docs/examples/` - Example projects and tutorials

## Community Guidelines

### Code of Conduct

We are committed to providing a welcoming and inclusive environment. Please:

- Be respectful and professional
- Welcome newcomers and help them succeed
- Focus on constructive feedback
- Respect different viewpoints and experiences

### Getting Help

- üìñ Check the documentation first
- üîç Search existing issues
- üí¨ Ask questions in discussions
- üêõ Report bugs with detailed information

### Recognition

Contributors are recognized in:

- Release notes
- Contributors section
- Special mentions for significant contributions

## Release Process

Releases are managed by maintainers:

1. Version bumping follows semantic versioning
2. Changelog is updated automatically
3. GitHub Actions handle builds and releases
4. Templates are versioned with the main project

## Questions?

If you have questions about contributing:

- Open a GitHub Discussion
- Check existing documentation
- Ask in pull request comments
- Contact maintainers directly

Thank you for contributing to GoCrafter! üöÄ

2. **Document Your Changes**
   Update the `README.md` or documentation, if necessary, to include your changes.

3. **Add Tests When Possible**
   Ensure any new functionality is accompanied by tests.

4. **Be Clear in Issue Reports**
   When opening an issue, be detailed and provide as much context as possible.

---

## **Where to Get Help**

If you need assistance, feel free to:

- Open an issue with the `question` tag.
- Contact me via the email or LinkedIn listed in the `README.md`.

---

## **Our Commitment**

We commit to reviewing pull requests and issues as quickly as possible. We value your contribution and appreciate the time dedicated to the project!

/// docs/README.pt-BR.md ///
# üöÄ GoCrafter

**GoCrafter** √© uma poderosa ferramenta de scaffolding e templating para projetos Go que ajuda voc√™ a criar projetos Go prontos para produ√ß√£o com melhores pr√°ticas, ferramentas modernas e templates personaliz√°veis.

[![Build](https://github.com/kubex-ecosystem/gocrafter/actions/workflows/release.yml/badge.svg)](https://github.com/kubex-ecosystem/gocrafter/actions/workflows/release.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Go Version](https://img.shields.io/badge/go-%3E=1.21-blue)](go.mod)
[![Releases](https://img.shields.io/github/v/release/kubex-ecosystem/gocrafter?include_prereleases)](https://github.com/kubex-ecosystem/gocrafter/releases)

---

## ‚ú® Funcionalidades

- üéØ **Cria√ß√£o Interativa de Projetos** - Assistente guiado para configura√ß√£o de projetos
- üì¶ **M√∫ltiplos Templates** - API REST, ferramentas CLI, microsservi√ßos, servi√ßos gRPC e mais
- ‚öôÔ∏è **Configura√ß√£o Inteligente** - Integra√ß√£o com banco de dados, cache, autentica√ß√£o e DevOps
- üõ†Ô∏è **Ferramentas Modernas** - Docker, Kubernetes, CI/CD, documenta√ß√£o Swagger
- üé® **Personaliz√°vel** - Estenda com seus pr√≥prios templates
- üöÄ **Pronto para Produ√ß√£o** - Melhores pr√°ticas e estrutura profissional

## üèÉ‚Äç‚ôÇÔ∏è In√≠cio R√°pido

### Instala√ß√£o

```bash
# Usando Go install
go install github.com/kubex-ecosystem/gocrafter@latest

# Ou baixar das releases
curl -sSL https://github.com/kubex-ecosystem/gocrafter/releases/latest/download/gocrafter-linux-amd64.tar.gz | tar xz
```

### Crie Seu Primeiro Projeto

```bash
# Modo interativo (recomendado para primeira vez)
gocrafter new

# Modo r√°pido
gocrafter new minha-api --template api-rest

# Listar templates dispon√≠veis
gocrafter list

# Obter detalhes do template
gocrafter info api-rest
```

## üì¶ Templates Dispon√≠veis

| Template | Descri√ß√£o | Funcionalidades |
|----------|-----------|-----------------|
| **api-rest** | Servidor de API REST | Framework Gin, middleware, health checks, Swagger |
| **cli-tool** | Aplica√ß√£o de linha de comando | Framework Cobra, subcomandos, configura√ß√£o |
| **microservice** | Arquitetura de microsservi√ßos | gRPC + HTTP, service discovery, m√©tricas |
| **grpc-service** | Servi√ßo gRPC puro | Protocol buffers, streaming, service mesh |
| **worker** | Processador de jobs em background | Integra√ß√£o com filas, retry, monitoramento |
| **library** | Biblioteca/pacote Go | Documenta√ß√£o, testes, workflows CI/CD |

## üéØ Exemplo: Criando uma API REST

```bash
$ gocrafter new minha-api-blog --template api-rest
üöÄ Iniciando gera√ß√£o do projeto...
‚úÖ Projeto gerado com sucesso!
üìÅ Localiza√ß√£o: minha-api-blog

Pr√≥ximos passos:
  cd minha-api-blog
  make run    # Iniciar a aplica√ß√£o
  make test   # Executar testes
  make build  # Compilar a aplica√ß√£o
```

**Estrutura do projeto gerado:**

```text
minha-api-blog/
‚îú‚îÄ‚îÄ cmd/main.go              # Ponto de entrada da aplica√ß√£o
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/             # Gerenciamento de configura√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ handler/            # Handlers HTTP
‚îÇ   ‚îú‚îÄ‚îÄ middleware/         # Middleware HTTP
‚îÇ   ‚îú‚îÄ‚îÄ model/              # Modelos de dados
‚îÇ   ‚îú‚îÄ‚îÄ repository/         # Camada de acesso a dados
‚îÇ   ‚îî‚îÄ‚îÄ service/            # L√≥gica de neg√≥cio
‚îú‚îÄ‚îÄ pkg/                    # Pacotes p√∫blicos
‚îú‚îÄ‚îÄ Makefile               # Automa√ß√£o de build
‚îú‚îÄ‚îÄ Dockerfile             # Configura√ß√£o de container
‚îú‚îÄ‚îÄ docker-compose.yml     # Ambiente de desenvolvimento
‚îú‚îÄ‚îÄ .env.example           # Template de vari√°veis de ambiente
‚îî‚îÄ‚îÄ README.md              # Documenta√ß√£o do projeto
```

## ‚öôÔ∏è Op√ß√µes de Configura√ß√£o

GoCrafter suporta configura√ß√£o extensiva atrav√©s de prompts interativos:

### Suporte a Bancos de Dados

- **PostgreSQL** - Pronto para produ√ß√£o com connection pooling
- **MySQL** - Banco relacional de alta performance
- **MongoDB** - Banco NoSQL baseado em documentos
- **SQLite** - Banco embarcado para desenvolvimento

### Cache

- **Redis** - Store de estrutura de dados em mem√≥ria
- **Memcached** - Sistema de cache de alta performance
- **In-Memory** - Cache Go integrado

### Autentica√ß√£o

- **JWT** - Autentica√ß√£o com JSON Web Token
- **OAuth2** - Provedores de autentica√ß√£o de terceiros
- **API Keys** - Autentica√ß√£o simples com chaves de API

### Integra√ß√£o DevOps

- **Docker** - Containeriza√ß√£o com multi-stage builds
- **Kubernetes** - Manifests de deployment para produ√ß√£o
- **CI/CD** - GitHub Actions, GitLab CI, Jenkins, Azure DevOps

## üõ†Ô∏è Uso Avan√ßado

### Modo Interativo

```bash
$ gocrafter new
üöÄ Bem-vindo ao GoCrafter - Gerador de Projetos Go!
Vamos criar seu projeto Go perfeito juntos...

? Qual o nome do seu projeto? minha-api-incrivel
? Qual o nome do m√≥dulo Go? github.com/usuario/minha-api-incrivel
? Que tipo de projeto voc√™ quer criar? api-rest - Servidor API REST com HTTP
? Qual banco de dados voc√™ quer usar? postgres
? Voc√™ quer adicionar uma camada de cache? redis
? Quais funcionalidades adicionais voc√™ quer incluir? [Use setas para mover, espa√ßo para selecionar]
  ‚óØ Autentica√ß√£o (JWT)
  ‚óâ Documenta√ß√£o da API (Swagger)
  ‚óâ Health Checks
  ‚óâ M√©tricas (Prometheus)
  ‚óØ Distributed Tracing
```

### Modo R√°pido

```bash
# Criar API com funcionalidades espec√≠ficas
gocrafter new blog-api \
  --template api-rest \
  --output ./projetos \
  --config api-config.json

# Criar ferramenta CLI
gocrafter new minha-cli \
  --template cli-tool \
  --quick

# Criar microsservi√ßo
gocrafter new user-service \
  --template microservice
```

### Informa√ß√µes do Template

```bash
# Listar todos os templates com descri√ß√µes
gocrafter list

# Obter informa√ß√µes detalhadas do template
gocrafter info api-rest

# Mostrar estrutura do template
gocrafter info microservice --show-structure
```

## üìö Documenta√ß√£o

- üìñ [**Guia do Usu√°rio**](user-guide.md) - Documenta√ß√£o completa de uso
- üõ†Ô∏è [**Desenvolvimento de Templates**](template-development.md) - Criar templates customizados
- üèóÔ∏è [**Arquitetura**](architecture.md) - Como o GoCrafter funciona
- üéØ [**Exemplos**](examples/) - Exemplos de projetos e tutoriais
- ü§ù [**Contribuindo**](CONTRIBUTING.md) - Como contribuir

## üåç Suporte a Idiomas

- [üá∫üá∏ English](../README.md)
- [üáßüá∑ Portugu√™s](README.pt-BR.md)

## ü§ù Contribuindo

Damos as boas-vindas a contribui√ß√µes! Por favor, veja nosso [Guia de Contribui√ß√£o](CONTRIBUTING.md) para detalhes.

1. Fa√ßa fork do reposit√≥rio
2. Crie sua branch de feature (`git checkout -b feature/funcionalidade-incrivel`)
3. Commit suas mudan√ßas (`git commit -m 'Adiciona funcionalidade incr√≠vel'`)
4. Push para a branch (`git push origin feature/funcionalidade-incrivel`)
5. Abra um Pull Request

## üìÑ Licen√ßa

Este projeto est√° licenciado sob a Licen√ßa MIT - veja o arquivo [LICENSE](../LICENSE) para detalhes.

## üôè Agradecimentos

- [Cobra](https://github.com/spf13/cobra) - Framework CLI
- [Survey](https://github.com/AlecAivazis/survey) - Prompts interativos
- [Gin](https://github.com/gin-gonic/gin) - Framework web HTTP
- [Logrus](https://github.com/sirupsen/logrus) - Logging estruturado

---

Feito com ‚ù§Ô∏è por [@rafa-mori](https://github.com/rafa-mori)

[‚≠ê Nos d√™ uma estrela se voc√™ acha o GoCrafter √∫til!](https://github.com/kubex-ecosystem/gocrafter)

/// docs/architecture.md ///
# GoCrafter Architecture

This document provides an overview of GoCrafter's architecture, design decisions, and internal workings.

## Overview

GoCrafter is a CLI-based project scaffolding tool designed with modularity, extensibility, and ease of use in mind. The architecture follows Go best practices and clean architecture principles.

## Project Structure

```plain
gocrafter/
‚îú‚îÄ‚îÄ cmd/                        # CLI entry points
‚îÇ   ‚îú‚îÄ‚îÄ main.go                # Application entry point
‚îÇ   ‚îú‚îÄ‚îÄ usage.go               # Usage documentation
‚îÇ   ‚îî‚îÄ‚îÄ wrpr.go                # Wrapper logic
‚îú‚îÄ‚îÄ internal/                   # Private packages
‚îÇ   ‚îú‚îÄ‚îÄ cli/                   # CLI command implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands.go        # Command definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ new.go             # Project creation command
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ list.go            # Template listing command
‚îÇ   ‚îú‚îÄ‚îÄ generator/             # Core generation logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.go          # Configuration management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ generator.go       # Template engine
‚îÇ   ‚îî‚îÄ‚îÄ prompt/                # Interactive prompts
‚îÇ       ‚îî‚îÄ‚îÄ interactive.go     # Survey-based prompts
‚îú‚îÄ‚îÄ templates/                  # Project templates
‚îÇ   ‚îú‚îÄ‚îÄ api-rest/              # REST API template
‚îÇ   ‚îú‚îÄ‚îÄ cli-tool/              # CLI tool template
‚îÇ   ‚îî‚îÄ‚îÄ microservice/          # Microservice template
‚îú‚îÄ‚îÄ logger/                     # Logging utilities
‚îú‚îÄ‚îÄ version/                    # Version management
‚îî‚îÄ‚îÄ docs/                       # Documentation
```

## Core Components

### 1. CLI Layer (`cmd/`)

The CLI layer serves as the user interface and application entry point.

**Key Components:**

- `main.go` - Application bootstrap and configuration
- `wrpr.go` - Command routing and execution wrapper
- `usage.go` - Help and usage information

**Responsibilities:**

- Parse command-line arguments
- Route commands to appropriate handlers
- Handle global flags and configuration
- Provide user feedback and error messages

### 2. Command Layer (`internal/cli/`)

Implements specific CLI commands and their business logic.

**Key Components:**

- `commands.go` - Command definitions and registration
- `new.go` - Project creation workflow
- `list.go` - Template listing and information

**Design Patterns:**

- Command Pattern for CLI operations
- Factory Pattern for command creation
- Strategy Pattern for different command types

### 3. Generation Engine (`internal/generator/`)

The core template processing and project generation engine.

**Key Components:**

- `generator.go` - Main template engine
- `config.go` - Project configuration model

**Features:**

- Go template engine integration
- Dynamic content generation
- File and directory structure creation
- Variable substitution and processing

### 4. Interactive System (`internal/prompt/`)

Handles user interaction and input collection.

**Key Components:**

- `interactive.go` - Survey-based prompts

**Features:**

- Multi-step interactive wizards
- Input validation and sanitization
- Conditional prompting logic
- User experience optimization

### 5. Template System (`templates/`)

Modular template definitions for different project types.

**Structure:**

```
templates/
‚îî‚îÄ‚îÄ template-name/
    ‚îú‚îÄ‚îÄ template.json          # Template metadata
    ‚îú‚îÄ‚îÄ go.mod.tmpl           # Go module template
    ‚îú‚îÄ‚îÄ main.go.tmpl          # Main application template
    ‚îî‚îÄ‚îÄ internal/             # Template directory structure
        ‚îî‚îÄ‚îÄ config/
            ‚îî‚îÄ‚îÄ config.go.tmpl
```

## Design Principles

### 1. Modularity

- **Separation of Concerns**: Each package has a single, well-defined responsibility
- **Loose Coupling**: Components interact through well-defined interfaces
- **High Cohesion**: Related functionality is grouped together

### 2. Extensibility

- **Template System**: Easy to add new project templates
- **Plugin Architecture**: Designed for future plugin support
- **Configuration Driven**: Behavior controlled through configuration

### 3. User Experience

- **Interactive Design**: Guided workflows for beginners
- **Power User Support**: Quick commands for experienced users
- **Consistent Interface**: Uniform command structure and feedback

### 4. Reliability

- **Error Handling**: Comprehensive error checking and recovery
- **Input Validation**: Robust validation of user input
- **Safe Operations**: Non-destructive operations with confirmation

## Data Flow

### 1. Project Creation Flow

```plain
User Input ‚Üí CLI Parser ‚Üí Command Router ‚Üí Interactive Prompts
    ‚Üì
Configuration Builder ‚Üí Template Engine ‚Üí File Generator ‚Üí Project Output
```

### 2. Template Processing Flow

```plain
Template Selection ‚Üí Metadata Loading ‚Üí Variable Collection
    ‚Üì
Template Parsing ‚Üí Content Generation ‚Üí File System Operations
```

## Template Engine

### Template Structure

Templates use Go's `text/template` package with custom functions:

```go
// Template variables
type TemplateData struct {
    ProjectName   string
    ModuleName    string
    Database      string
    Features      []string
    // ... other fields
}
```

### Template Functions

Custom template functions provide additional functionality:

- `title` - Convert to title case
- `lower` - Convert to lowercase
- `contains` - Check if slice contains value
- `join` - Join strings with separator

### Conditional Generation

Templates support conditional content generation:

```go
{{if .Features.Contains "database"}}
// Database-related code
{{end}}
```

## Configuration Management

### Project Configuration

```go
type ProjectConfig struct {
    Name         string              `json:"name"`
    ModuleName   string              `json:"module_name"`
    Template     string              `json:"template"`
    Database     string              `json:"database,omitempty"`
    Features     []string            `json:"features,omitempty"`
    Additional   map[string]string   `json:"additional,omitempty"`
}
```

### Template Metadata

```json
{
    "name": "api-rest",
    "description": "REST API with HTTP server",
    "version": "1.0.0",
    "author": "GoCrafter Team",
    "tags": ["api", "rest", "http", "server"],
    "features": ["database", "cache", "auth", "swagger"],
    "dependencies": {
        "go_version": ">=1.21"
    }
}
```

## Error Handling Strategy

### 1. Error Types

- **User Errors**: Invalid input, missing requirements
- **System Errors**: File system issues, permission problems
- **Template Errors**: Invalid templates, parsing failures

### 2. Error Recovery

- **Graceful Degradation**: Continue when possible
- **Clear Messages**: User-friendly error descriptions
- **Suggestions**: Provide actionable next steps

### 3. Logging

- **Structured Logging**: Using logrus for consistent log format
- **Log Levels**: Debug, Info, Warning, Error
- **Context**: Include relevant context in log messages

## Performance Considerations

### 1. Template Caching

- Templates are parsed once and cached
- Metadata is loaded on demand
- File operations are batched when possible

### 2. Memory Management

- Stream processing for large files
- Cleanup of temporary resources
- Efficient string operations

### 3. Concurrency

- Parallel file operations where safe
- Async operations for independent tasks
- Resource pooling for expensive operations

## Security Considerations

### 1. Input Validation

- Path traversal prevention
- Input sanitization
- File name validation

### 2. Template Security

- Restricted template functions
- Safe variable substitution
- Controlled file system access

### 3. Dependency Management

- Vetted dependencies only
- Regular security updates
- Minimal dependency surface

## Testing Strategy

### 1. Unit Tests

- Individual component testing
- Mock external dependencies
- Edge case coverage

### 2. Integration Tests

- End-to-end command testing
- Template generation validation
- File system operation testing

### 3. Template Tests

- Template parsing validation
- Generated project verification
- Cross-platform compatibility

## Future Architecture Considerations

### 1. Plugin System

- Dynamic plugin loading
- Plugin API definition
- Security and isolation

### 2. Remote Templates

- Template repository support
- Version management
- Caching and updates

### 3. GUI Interface

- Web-based interface
- Desktop application
- Mobile companion app

### 4. Cloud Integration

- Cloud project deployment
- CI/CD pipeline integration
- Remote collaboration features

## Monitoring and Observability

### 1. Metrics

- Command usage statistics
- Template popularity
- Performance metrics

### 2. Health Checks

- System dependency validation
- Template integrity checks
- Resource availability monitoring

### 3. Telemetry

- Anonymous usage data
- Error reporting
- Performance profiling

## Deployment Architecture

### 1. Distribution

- Binary releases for multiple platforms
- Package manager integration
- Container images

### 2. Updates

- Version checking
- Automatic updates
- Rollback capability

### 3. Configuration

- User configuration files
- System-wide defaults
- Environment-specific settings

This architecture provides a solid foundation for GoCrafter's current functionality while allowing for future growth and enhancement.

/// docs/examples/README.md ///
# GoCrafter Examples

This directory contains practical examples and tutorials for using GoCrafter effectively.

## Quick Start Examples

### 1. Creating a Simple REST API

```bash
# Interactive mode (recommended for beginners)
gocrafter new blog-api

# Follow the prompts:
# - Template: api-rest
# - Database: PostgreSQL
# - Features: Authentication, Swagger, Health Checks
```

**Generated structure:**

```
blog-api/
‚îú‚îÄ‚îÄ cmd/main.go
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ handler/
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îî‚îÄ‚îÄ service/
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ README.md
```

**Next steps:**

```bash
cd blog-api
make setup    # Install dependencies
make run      # Start the development server
make test     # Run tests
```

### 2. Creating a CLI Tool

```bash
# Quick mode with specific template
gocrafter new my-cli --template cli-tool

cd my-cli
go run cmd/main.go --help
```

### 3. Creating a Microservice

```bash
# With custom configuration
gocrafter new user-service \
  --template microservice \
  --output ./services/
```

## Real-World Examples

### Blog API with Full Features

This example shows how to create a complete blog API with authentication, database, and API documentation.

```bash
# Create the project
gocrafter new blog-api --template api-rest

# Answer the prompts:
# - Database: PostgreSQL
# - Cache: Redis
# - Features: JWT Auth, Swagger, Metrics, Docker
```

**Features included:**

- REST endpoints for posts, users, comments
- JWT authentication and authorization
- PostgreSQL database with migrations
- Redis caching layer
- API documentation with Swagger
- Docker containerization
- Health checks and metrics
- Comprehensive test suite

**Project structure:**

```
blog-api/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ main.go                 # Application entry point
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.go          # Configuration management
‚îÇ   ‚îú‚îÄ‚îÄ handler/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.go            # Authentication endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ post.go            # Blog post endpoints
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.go            # User management endpoints
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.go            # JWT middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cors.go            # CORS handling
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging.go         # Request logging
‚îÇ   ‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ post.go            # Post model
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.go            # User model
‚îÇ   ‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ post.go            # Post data access
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.go            # User data access
‚îÇ   ‚îî‚îÄ‚îÄ service/
‚îÇ       ‚îú‚îÄ‚îÄ auth.go            # Authentication logic
‚îÇ       ‚îú‚îÄ‚îÄ post.go            # Post business logic
‚îÇ       ‚îî‚îÄ‚îÄ user.go            # User business logic
‚îú‚îÄ‚îÄ pkg/
‚îÇ   ‚îú‚îÄ‚îÄ database/              # Database utilities
‚îÇ   ‚îú‚îÄ‚îÄ redis/                 # Redis utilities
‚îÇ   ‚îî‚îÄ‚îÄ validation/            # Input validation
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ 001_create_users.sql
‚îÇ   ‚îî‚îÄ‚îÄ 002_create_posts.sql
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îî‚îÄ‚îÄ api.yaml              # OpenAPI specification
‚îú‚îÄ‚îÄ docker-compose.yml        # Development environment
‚îú‚îÄ‚îÄ Dockerfile               # Production container
‚îú‚îÄ‚îÄ Makefile                 # Build automation
‚îî‚îÄ‚îÄ README.md               # Project documentation
```

### CLI Tool with Subcommands

Create a feature-rich CLI tool with multiple subcommands and configuration.

```bash
gocrafter new devtools --template cli-tool
```

**Generated CLI features:**

- Multiple subcommands (init, build, deploy)
- Configuration file support
- Colored output and progress bars
- Shell completion
- Cross-platform builds

### Microservice with gRPC

Create a production-ready microservice with gRPC and HTTP support.

```bash
gocrafter new user-service --template microservice
```

**Features:**

- gRPC service definitions
- HTTP gateway integration
- Service discovery ready
- Observability built-in
- Kubernetes deployment manifests

## Advanced Usage Examples

### Custom Template Configuration

Using a configuration file to pre-define project settings:

```json
{
  "name": "my-ecommerce-api",
  "module_name": "github.com/mycompany/ecommerce-api",
  "template": "api-rest",
  "database": "postgres",
  "cache": "redis",
  "features": [
    "jwt-auth",
    "swagger",
    "metrics",
    "docker",
    "kubernetes"
  ],
  "additional": {
    "payment_gateway": "stripe",
    "email_service": "sendgrid"
  }
}
```

```bash
gocrafter new --config project-config.json
```

### Batch Project Creation

Create multiple related services:

```bash
# API Gateway
gocrafter new api-gateway --template api-rest

# User Service
gocrafter new user-service --template microservice

# Order Service
gocrafter new order-service --template microservice

# Notification Service
gocrafter new notification-service --template worker
```

### Template Customization

Extending existing templates for organization-specific needs:

```bash
# Copy existing template
cp -r templates/api-rest templates/company-api

# Customize template.json
# Add company-specific configurations
# Modify template files as needed

# Use custom template
gocrafter new company-project --template company-api
```

## Development Workflow Examples

### Full Development Cycle

```bash
# 1. Create project
gocrafter new my-api --template api-rest

cd my-api

# 2. Set up development environment
make setup
docker-compose up -d postgres redis

# 3. Run database migrations
make migrate

# 4. Start development server
make dev

# 5. Run tests
make test

# 6. Build for production
make build

# 7. Deploy
make deploy
```

### Testing Generated Projects

```bash
# Unit tests
make test

# Integration tests
make test-integration

# Load testing
make test-load

# Security testing
make test-security
```

### Continuous Integration

Generated projects include CI/CD configurations:

**GitHub Actions:**

```yaml
# .github/workflows/ci.yml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v3
        with:
          go-version: '1.21'
      - run: make test
      - run: make build
```

## Best Practices Examples

### Project Organization

```
my-service/
‚îú‚îÄ‚îÄ cmd/                    # Main applications
‚îú‚îÄ‚îÄ internal/              # Private code
‚îú‚îÄ‚îÄ pkg/                   # Public libraries
‚îú‚îÄ‚îÄ api/                   # API definitions
‚îú‚îÄ‚îÄ configs/               # Configuration files
‚îú‚îÄ‚îÄ deployments/           # Deployment configurations
‚îú‚îÄ‚îÄ docs/                  # Documentation
‚îú‚îÄ‚îÄ scripts/               # Build and deployment scripts
‚îú‚îÄ‚îÄ test/                  # Integration tests
‚îî‚îÄ‚îÄ vendor/                # Dependencies (if using vendor)
```

### Configuration Management

```go
// internal/config/config.go
type Config struct {
    Server   ServerConfig   `yaml:"server"`
    Database DatabaseConfig `yaml:"database"`
    Redis    RedisConfig    `yaml:"redis"`
    Auth     AuthConfig     `yaml:"auth"`
}

// Environment-specific configs
// config/development.yaml
// config/production.yaml
// config/testing.yaml
```

### Error Handling

```go
// pkg/errors/errors.go
type APIError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

func (e APIError) Error() string {
    return e.Message
}
```

### Testing Patterns

```go
// internal/handler/post_test.go
func TestCreatePost(t *testing.T) {
    tests := []struct {
        name           string
        input          CreatePostRequest
        expectedStatus int
        expectedError  string
    }{
        {
            name: "valid post creation",
            input: CreatePostRequest{
                Title:   "Test Post",
                Content: "Test content",
            },
            expectedStatus: http.StatusCreated,
        },
        // ... more test cases
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

## Troubleshooting Examples

### Common Issues and Solutions

**Issue: Module name conflicts**

```bash
# Problem: Module name already exists
gocrafter new my-project --module github.com/existing/repo

# Solution: Use a unique module name
gocrafter new my-project --module github.com/myusername/unique-name
```

**Issue: Template not found**

```bash
# Problem: Custom template not recognized
gocrafter new project --template my-template

# Solution: Check template exists
gocrafter list
```

**Issue: Permission errors**

```bash
# Problem: Cannot create files in directory
# Solution: Check permissions or use different output directory
gocrafter new project --output ~/projects/
```

## Performance Examples

### Optimized Project Structure

```
high-performance-api/
‚îú‚îÄ‚îÄ cmd/main.go
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ handler/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handler.go      # Optimized handlers
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.go        # Caching middleware
‚îÇ   ‚îî‚îÄ‚îÄ pool/
‚îÇ       ‚îî‚îÄ‚îÄ worker.go       # Worker pools
‚îú‚îÄ‚îÄ pkg/
‚îÇ   ‚îú‚îÄ‚îÄ metrics/            # Performance metrics
‚îÇ   ‚îî‚îÄ‚îÄ profiling/          # Profiling utilities
‚îî‚îÄ‚îÄ configs/
    ‚îî‚îÄ‚îÄ performance.yaml    # Performance tuning
```

### Monitoring and Observability

Generated projects include observability features:

```go
// Metrics collection
prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Name: "http_requests_total",
        Help: "Total number of HTTP requests",
    },
    []string{"method", "endpoint", "status"},
)

// Distributed tracing
span := opentracing.StartSpan("http_request")
defer span.Finish()
```

## Integration Examples

### Database Integration

```go
// Multiple database support
switch config.Database.Type {
case "postgres":
    db = setupPostgreSQL(config.Database.URL)
case "mysql":
    db = setupMySQL(config.Database.URL)
case "mongodb":
    db = setupMongoDB(config.Database.URL)
}
```

### External Services

```go
// Service integrations
type Services struct {
    EmailService    email.Service
    PaymentService  payment.Service
    StorageService  storage.Service
}
```

These examples demonstrate the versatility and power of GoCrafter for creating production-ready Go applications across different domains and use cases.

/// docs/jobs/IMPLEMENTATION_SUMMARY.md ///
# GoCrafter - Sistema de Kits Implementado

## ‚úÖ Funcionalidades Implementadas

### 1. **Arquitetura Modular H√≠brida**

- Templates internos existentes preservados
- Sistema de kits plug√°veis adicionado
- Engine de substitui√ß√£o de placeholders avan√ßado

### 2. **Gerenciamento de Kits**

```bash
# Comandos dispon√≠veis
gocrafter kit add <repo-url>     # Adicionar kit
gocrafter kit list               # Listar kits
gocrafter kit remove <nome>      # Remover kit
gocrafter kit update <nome>      # Atualizar kit
gocrafter kit info <nome>        # Informa√ß√µes do kit
```

### 3. **Gera√ß√£o de Projetos com Kits**

```bash
# Usando kits
gocrafter new <projeto> --kit <nome-kit> --author "Nome" --license "MIT"

# Usando templates tradicionais (preservado)
gocrafter new <projeto> --template <nome-template>
```

### 4. **Sistema de Placeholders Avan√ßado**

- Placeholders b√°sicos: `{{project_name}}`, `{{author}}`, `{{license}}`, etc.
- Placeholders derivados autom√°ticos
- Fun√ß√µes de template: `upper`, `lower`, `kebab`, `snake`, `camel`, `pascal`
- Suporte a l√≥gica condicional e express√µes

### 5. **Estrutura de Kit Completa**

```plaintext
kit/
‚îú‚îÄ‚îÄ metadata.yaml        # Metadados do kit
‚îú‚îÄ‚îÄ templates/          # Arquivos do projeto
‚îÇ   ‚îú‚îÄ‚îÄ *.tpl          # Templates com placeholders
‚îÇ   ‚îî‚îÄ‚îÄ arquivos-est√°ticos
‚îî‚îÄ‚îÄ scaffold.sh         # Script p√≥s-gera√ß√£o (opcional)
```

## üèóÔ∏è Arquivos Criados/Modificados

### Novos Arquivos

- `internal/types/kit.go` - Defini√ß√µes de tipos para kits
- `internal/generator/kit_manager.go` - Gerenciador de kits
- `internal/generator/kit_generator.go` - Gerador baseado em kits
- `internal/generator/replacer.go` - Sistema de substitui√ß√£o de placeholders
- `internal/prompt/kit.go` - Sistema de prompts para kits
- `cmd/cli/kit.go` - Comandos CLI para gerenciamento de kits
- `docs/kit-development.md` - Guia de desenvolvimento de kits
- `examples/sample-kit/` - Exemplo funcional de kit

### Arquivos Modificados

- `cmd/cli/commands.go` - Adicionado comando kit
- `cmd/cli/new.go` - Suporte a kits no comando new
- `go.mod` - Depend√™ncias adicionadas
- `README.md` - Documenta√ß√£o atualizada

## üéØ Caracter√≠sticas T√©cnicas

### 1. **Compatibilidade**

- ‚úÖ Suporte multiplataforma (Windows, Linux, macOS)
- ‚úÖ Backward compatibility mantida
- ‚úÖ Templates existentes funcionam normalmente

### 2. **Performance**

- ‚úÖ Cache local de kits baixados
- ‚úÖ Lazy loading de templates
- ‚úÖ Opera√ß√µes de I/O otimizadas

### 3. **Robustez**

- ‚úÖ Valida√ß√£o de par√¢metros de entrada
- ‚úÖ Verifica√ß√£o de depend√™ncias
- ‚úÖ Tratamento de erros robusto
- ‚úÖ Fallback para opera√ß√µes offline

### 4. **Extensibilidade**

- ‚úÖ Sistema de plugins escal√°vel
- ‚úÖ Suporte a m√∫ltiplas linguagens/frameworks
- ‚úÖ Metadados flex√≠veis

## üß™ Testes Realizados

### 1. **Instala√ß√£o de Kit**

```bash
‚úÖ gocrafter kit add /caminho/local/kit    # Kits locais
‚úÖ gocrafter kit add https://github.com/user/kit # Git repositories
```

### 2. **Listagem de Kits**

```bash
‚úÖ gocrafter kit list                      # Lista b√°sica
‚úÖ gocrafter kit list --verbose           # Lista detalhada
```

### 3. **Gera√ß√£o de Projetos**

```bash
‚úÖ gocrafter new test-api --kit sample-kit --author "Test User"
```

### 4. **Substitui√ß√£o de Placeholders**

- ‚úÖ Placeholders b√°sicos funcionando
- ‚úÖ Substitui√ß√£o em nomes de arquivos
- ‚úÖ Substitui√ß√£o em conte√∫do de arquivos
- ‚úÖ Fun√ß√µes de template operacionais

## üì¶ Kit de Exemplo

Foi criado um kit de exemplo funcional (`examples/sample-kit/`) que demonstra:

- API REST com Gin framework
- Estrutura de projeto profissional
- Dockerfile e Makefile
- Documenta√ß√£o completa
- Script de p√≥s-gera√ß√£o
- Configura√ß√£o de ambiente

## üîß Configura√ß√£o

### Diret√≥rios Criados Automaticamente

- `~/.gocrafter/kits/` - Kits instalados
- `~/.gocrafter/cache/` - Cache de downloads

### Comandos de Exemplo Funcionais

```bash
# Adicionar o kit de exemplo
gocrafter kit add /srv/apps/KUBEX/gocrafter/examples/sample-kit

# Listar kits instalados
gocrafter kit list

# Gerar projeto do kit
gocrafter new minha-api --kit sample-kit --author "Meu Nome"

# Ver informa√ß√µes do kit
gocrafter kit info sample-kit
```

## üöÄ Pr√≥ximos Passos Sugeridos

1. **Reposit√≥rio de Kits P√∫blicos**
   - Criar reposit√≥rio oficial de kits
   - Sistema de descoberta de kits

2. **Kits Espec√≠ficos por Linguagem**
   - Kit Python (FastAPI, Django)
   - Kit JavaScript (Node.js, Express)
   - Kit Rust (Actix, Rocket)

3. **Melhorias no Sistema**
   - Versionamento de kits
   - Depend√™ncias entre kits
   - Sistema de ratings/reviews

## üìã Crit√©rios de Sucesso Atendidos

1. ‚úÖ **Modularidade**: F√°cil adi√ß√£o de novos kits sem modificar c√≥digo-fonte
2. ‚úÖ **Simplicidade**: CLI intuitivo com comandos claros
3. ‚úÖ **Robustez**: Gera√ß√£o limpa sem arquivos desnecess√°rios
4. ‚úÖ **Extensibilidade**: Sistema de plugins escal√°vel
5. ‚úÖ **Escolha de Linguagens**: Suporte a m√∫ltiplas linguagens via kits

/// docs/kit-development.md ///
# Kit Development Guide

This guide explains how to create and share your own kits for GoCrafter.

## What is a Kit?

A kit is a pluggable project template that can be installed from external repositories. Unlike built-in templates, kits are distributed separately and can be maintained by the community.

## Kit Structure

A kit must have the following structure:

```
my-kit/
‚îú‚îÄ‚îÄ metadata.yaml       # Kit metadata and configuration
‚îú‚îÄ‚îÄ templates/          # Template files and directories
‚îÇ   ‚îú‚îÄ‚îÄ main.go
‚îÇ   ‚îú‚îÄ‚îÄ go.mod
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ scaffold.sh         # Optional post-generation script
```

### Required Files

#### metadata.yaml

The metadata file defines the kit's properties and requirements:

```yaml
name: "my-golang-kit"
description: "A sample Go project kit"
language: "go"
version: "1.0.0"
author: "Your Name"
repository: "https://github.com/user/my-golang-kit"
dependencies:
  - "go"
  - "make"
  - "docker"
placeholders:
  - "project_name"
  - "author"
  - "license"
  - "description"
  - "port"
tags:
  - "api"
  - "rest"
  - "go"
metadata:
  min_go_version: "1.24.4"
  features:
    - "HTTP server"
    - "Docker support"
    - "Makefile automation"
```

#### templates/

The templates directory contains all the files and directories that will be generated. Files can contain placeholders that will be replaced during generation.

### Optional Files

#### scaffold.sh

A post-generation script that runs after the project is created. This script can:

- Initialize dependencies
- Run setup commands
- Create additional files
- Configure the development environment

```bash
#!/bin/bash
set -e

echo "Setting up {{project_name}}..."

# Initialize Go module
go mod tidy

# Create directories
mkdir -p bin logs

# Install development tools
go install github.com/air-verse/air@latest

echo "Setup completed!"
```

## Placeholder System

GoCrafter supports a powerful placeholder system with the following features:

### Basic Placeholders

Use `{{placeholder_name}}` in your template files:

```go
package main

import "fmt"

func main() {
    fmt.Println("Welcome to {{project_name}}!")
    fmt.Println("Created by {{author}}")
}
```

### Built-in Placeholders

The following placeholders are automatically available:

- `{{project_name}}` - Project name
- `{{author}}` - Author name
- `{{license}}` - License type
- `{{current_year}}` - Current year
- `{{go_version}}` - Go version

### Derived Placeholders

Some placeholders are automatically derived from others:

- `{{package_name}}` - Derived from project_name (lowercase, no hyphens)
- `{{module_name}}` - Derived from project_name (lowercase with hyphens)
- `{{class_name}}` - Derived from project_name (title case)
- `{{const_name}}` - Derived from project_name (uppercase with underscores)

### Template Functions

Use template functions for advanced transformations:

```go
// String manipulation
{{upper project_name}}        // UPPERCASE
{{lower project_name}}        // lowercase
{{title project_name}}        // Title Case
{{kebab project_name}}        // kebab-case
{{snake project_name}}        // snake_case
{{camel project_name}}        // camelCase
{{pascal project_name}}       // PascalCase

// Utilities
{{now}}                       // Current timestamp
{{date "2006-01-02"}}         // Formatted date
{{env "HOME"}}                // Environment variable
{{default "defaultValue" value}} // Default value if empty
```

### Conditional Logic

Use conditional logic in templates:

```go
{{if eq license "MIT"}}
// MIT License specific code
{{else if eq license "Apache-2.0"}}
// Apache License specific code
{{else}}
// Default license code
{{end}}
```

## File Processing

### Template Files

Files with the following extensions are automatically processed as templates:

- Code files: `.go`, `.js`, `.ts`, `.py`, `.rs`, `.java`, `.cpp`, `.c`, `.h`
- Configuration: `.yaml`, `.yml`, `.json`, `.toml`, `.env`
- Documentation: `.md`, `.txt`
- Build files: `Makefile`, `Dockerfile`, `.sh`

### Static Files

Binary files and other non-text files are copied as-is without processing.

### File Path Placeholders

You can use placeholders in file and directory names:

```
templates/
‚îú‚îÄ‚îÄ cmd/{{project_name}}/
‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ internal/{{package_name}}/
‚îÇ   ‚îî‚îÄ‚îÄ service.go
‚îî‚îÄ‚îÄ {{project_name}}.yaml
```

## Best Practices

### 1. Comprehensive Metadata

Provide complete metadata including:

- Clear description
- Version information
- Dependencies list
- Required placeholders
- Relevant tags

### 2. Flexible Placeholders

Design your kit to work with minimal required placeholders:

```yaml
placeholders:
  - "project_name"    # Required
  - "author"          # Optional, has default
  - "license"         # Optional, defaults to MIT
```

### 3. Meaningful Defaults

Use the `default` template function for optional values:

```go
const DefaultPort = "{{default "8080" port}}"
const Author = "{{default "Developer" author}}"
```

### 4. Documentation

Include comprehensive documentation:

- README.md with setup instructions
- Code comments explaining key concepts
- Example usage and API documentation

### 5. Post-Generation Script

Use scaffold.sh for:

- Dependency installation
- Initial build/setup
- Development tool configuration
- Environment validation

### 6. Error Handling

Make your post-generation script robust:

```bash
#!/bin/bash
set -e  # Exit on error

# Check dependencies
if ! command -v go &> /dev/null; then
    echo "Error: Go is not installed"
    exit 1
fi

# Validate Go version
GO_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
if [ "$(printf '%s\n' "1.24.4" "$GO_VERSION" | sort -V | head -n1)" != "1.24.4" ]; then
    echo "Warning: Go version $GO_VERSION may not be supported"
fi
```

## Testing Your Kit

### 1. Local Testing

Test your kit locally before publishing:

```bash
# Add your local kit
gocrafter kit add /path/to/your/kit

# Generate a test project
gocrafter new test-project --kit your-kit-name

# Verify the generated project
cd test-project
make build
make test
```

### 2. Validation

Ensure your kit passes validation:

```bash
# The kit manager automatically validates:
# - metadata.yaml exists and is valid
# - templates/ directory exists
# - Required fields are present
# - Placeholders are properly defined
```

## Publishing Your Kit

### 1. Repository Setup

Create a Git repository with your kit:

```bash
git init
git add .
git commit -m "Initial kit version"
git tag v1.0.0
git push origin main --tags
```

### 2. Distribution

Users can install your kit using:

```bash
# From GitHub
gocrafter kit add https://github.com/user/your-kit

# From other Git repositories
gocrafter kit add https://gitlab.com/user/your-kit

# From archives
gocrafter kit add https://example.com/kits/your-kit.tar.gz
```

### 3. Versioning

Use semantic versioning for your kits:

- `v1.0.0` - Initial release
- `v1.0.1` - Bug fixes
- `v1.1.0` - New features
- `v2.0.0` - Breaking changes

## Example Kit

See the complete example kit in `examples/sample-kit/` for a working reference implementation.

## Troubleshooting

### Common Issues

1. **Kit validation fails**
   - Check metadata.yaml syntax
   - Ensure all required fields are present
   - Verify templates/ directory exists

2. **Placeholders not replaced**
   - Check placeholder names match metadata
   - Ensure file extensions are processed
   - Verify template syntax

3. **Post-generation script fails**
   - Make script executable
   - Use `set -e` for error handling
   - Test script independently

### Debug Mode

Enable debug logging for troubleshooting:

```bash
export GOCRAFTER_LOG_LEVEL=debug
gocrafter kit add your-kit-url
```

## Community

- Share your kits on GitHub with the `gocrafter-kit` topic
- Join discussions in the GoCrafter community
- Contribute improvements to the kit system

Happy kit development! üéâ

/// docs/parts/wrpr-wrapper.md ///
# GoCrafter CLI Wrapper Documentation

## Overview

The `cmd/wrpr.go` file implements a wrapper for the GoCrafter CLI, providing a structured interface for managing application commands and configurations.

## Main Structure

### `GoCrafter` Type

```go
type GoCrafter struct {
    parentCmdName string
    printBanner   bool
}
```

**Fields:**

- `parentCmdName`: Parent command name for example concatenation
- `printBanner`: Flag that controls whether the banner should be displayed

## Interface Methods

### Configuration Methods

- **`Alias()`**: Returns empty string (no alias defined)
- **`ShortDescription()`**: Short description of GoCrafter
- **`LongDescription()`**: Long description of GoCrafter
- **`Usage()`**: Command usage pattern
- **`Examples()`**: List of usage examples
- **`Active()`**: Always returns `true` (active module)
- **`Module()`**: Returns "article" as module name

### Execution Methods

- **`Execute()`**: Executes the main command
- **`Command()`**: Builds and configures the main Cobra command

### Utility Methods

- **`SetParentCmdName()`**: Sets the parent command name
- **`concatenateExamples()`**: Concatenates examples with parent command name

## Main Functionalities

### 1. Cobra Command Configuration

The `Command()` method configures:

- Root command with use, aliases, and version
- Adds subcommands through `cc.ServiceCmdList()`
- Adds version command
- Sets usage definitions for all commands

### 2. Argument Processing

The code processes command line arguments to:

- Check if specific commands are being executed
- Configure short descriptions for commands without them

### 3. Environment Configuration

The `RegX()` function configures the instance based on environment variables:

- `ARTICLE_PRINT_BANNER`: Controls banner display (default: "true")

## Initialization Function

### `RegX()`

```go
func RegX() *GoCrafter
```

**Responsibilities:**

- Reads `GOFORGE_PRINT_BANNER` environment variable
- Creates and returns new `GoCrafter` instance
- Sets default configuration for banner display

## Dependencies

- **Cobra**: CLI framework for Go
- **Internal modules**:
  - `cc`: CLI commands
  - `gl`: Logging system
  - `vs`: Version management

## Design Patterns

- **Wrapper Pattern**: Encapsulates Cobra functionality
- **Factory Pattern**: `RegX()` function for instance creation
- **Interface Segregation**: Specific methods for different CLI aspects

## Notes

- Module name is hardcoded as "article"
- Support for configuration via environment variables
- Integration with logging system for debugging
- Automatic configuration of commands and subcommands

## Usage Example

```go
// Create GoCrafter instance
gocrafter := RegX()

// Execute CLI
if err := gocrafter.Execute(); err != nil {
    log.Fatal(err)
}
```

## Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `ARTICLE_PRINT_BANNER` | Controls banner display | `"true"` |

## Command Structure

```text
article
‚îú‚îÄ‚îÄ [service commands from cc.ServiceCmdList()]
‚îî‚îÄ‚îÄ version (from vs.CliCommand())
```

/// docs/template-development.md ///
# üõ†Ô∏è Template Development Guide

This guide explains how to create custom templates for GoCrafter.

## Table of Contents

- [Template Structure](#template-structure)
- [Template Variables](#template-variables)
- [Creating a Custom Template](#creating-a-custom-template)
- [Template Metadata](#template-metadata)
- [Template Functions](#template-functions)
- [Best Practices](#best-practices)
- [Testing Templates](#testing-templates)
- [Contributing Templates](#contributing-templates)

## Template Structure

A GoCrafter template is a directory containing:

```text
my-template/
‚îú‚îÄ‚îÄ template.json           # Template metadata
‚îú‚îÄ‚îÄ go.mod                 # Go module template
‚îú‚îÄ‚îÄ README.md              # Project documentation
‚îú‚îÄ‚îÄ Makefile              # Build automation
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ main.go           # Main application
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ handler/
‚îî‚îÄ‚îÄ pkg/
```

### File Processing

GoCrafter processes files in two ways:

1. **Template Processing**: Files with template syntax `{{.Variable}}`
2. **Direct Copy**: Binary files and assets

### Supported File Types

Template processing is applied to:
- `.go` files
- `.mod`, `.sum` files
- `.yaml`, `.yml` files
- `.json` files
- `.toml` files
- `.md` files
- `.txt` files
- `.env` files
- `Dockerfile`, `Makefile` files

## Template Variables

Templates have access to these variables:

### Basic Variables

```go
type TemplateVars struct {
    ProjectName    string  // e.g., "my-awesome-api"
    ModuleName     string  // e.g., "github.com/user/my-awesome-api"
    PackageName    string  // e.g., "myawesomeapi"
    DatabaseType   string  // e.g., "postgres", "mysql", "mongodb"
    CacheType      string  // e.g., "redis", "memcached"
    QueueType      string  // e.g., "rabbitmq", "kafka"
    HasDocker      bool    // Docker configuration included
    HasKubernetes  bool    // Kubernetes manifests included
    HasMonitoring  bool    // Monitoring features included
    CIType         string  // e.g., "github", "gitlab"
    Features       []string // Selected features
    Custom         map[string]string // Custom variables
}
```

### Usage in Templates

```go
// go.mod template
module {{.ModuleName}}

go 1.21

// main.go template
package main

import (
    "{{.ModuleName}}/internal/config"
    {{- if .DatabaseType}}
    "{{.ModuleName}}/internal/database"
    {{- end}}
)

func main() {
    // {{.ProjectName}} application
    cfg := config.Load()
    {{- if .DatabaseType}}
    db := database.Connect(cfg)
    {{- end}}
}
```

## Creating a Custom Template

### Step 1: Create Template Directory

```bash
mkdir -p templates/my-custom-template
cd templates/my-custom-template
```

### Step 2: Create Template Metadata

Create `template.json`:

```json
{
  "name": "my-custom-template",
  "description": "Custom template for specialized applications",
  "version": "1.0.0",
  "author": "Your Name",
  "tags": ["custom", "specialized"],
  "features": [
    "Custom feature 1",
    "Custom feature 2",
    "Modern tooling"
  ]
}
```

### Step 3: Create Project Structure

```bash
# Create directories
mkdir -p cmd internal/config internal/handler pkg

# Create main.go
cat > cmd/main.go << 'EOF'
package main

import (
    "fmt"
    "{{.ModuleName}}/internal/config"
)

func main() {
    fmt.Println("Hello from {{.ProjectName}}!")
    cfg := config.Load()
    fmt.Printf("Environment: %s\n", cfg.Environment)
}
EOF
```

### Step 4: Create Configuration

```bash
cat > internal/config/config.go << 'EOF'
package config

import "os"

type Config struct {
    Environment string
    Port        string
    {{- if .DatabaseType}}
    DatabaseURL string
    {{- end}}
}

func Load() *Config {
    return &Config{
        Environment: getEnv("ENVIRONMENT", "development"),
        Port:        getEnv("PORT", "8080"),
        {{- if .DatabaseType}}
        DatabaseURL: getEnv("DATABASE_URL", ""),
        {{- end}}
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}
EOF
```

### Step 5: Create Go Module Template

```bash
cat > go.mod << 'EOF'
module {{.ModuleName}}

go 1.21

require (
    {{- if .DatabaseType}}
    {{- if eq .DatabaseType "postgres"}}
    github.com/lib/pq v1.10.9
    {{- else if eq .DatabaseType "mysql"}}
    github.com/go-sql-driver/mysql v1.7.1
    {{- end}}
    {{- end}}
)
EOF
```

### Step 6: Create Documentation

```bash
cat > README.md << 'EOF'
# {{.ProjectName}}

{{.ProjectName}} is a custom application generated with GoCrafter.

## Features

{{- range .Features}}
- {{.}}
{{- end}}

## Getting Started

```bash
# Install dependencies
go mod download

# Run the application
go run cmd/main.go
```

## Configuration

Set these environment variables:

- `ENVIRONMENT`: Application environment (default: development)
- `PORT`: Server port (default: 8080)
{{- if .DatabaseType}}
- `DATABASE_URL`: Database connection string
{{- end}}
EOF
```

## Template Metadata

The `template.json` file defines template metadata:

```json
{
  "name": "template-name",
  "description": "Template description",
  "version": "1.0.0",
  "author": "Author Name",
  "tags": ["tag1", "tag2"],
  "features": [
    "Feature description 1",
    "Feature description 2"
  ],
  "requirements": {
    "go_version": "1.21",
    "dependencies": [
      "github.com/gin-gonic/gin",
      "github.com/spf13/cobra"
    ]
  }
}
```

### Metadata Fields

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Template name (must match directory) |
| `description` | string | Short description |
| `version` | string | Template version (semver) |
| `author` | string | Template author |
| `tags` | array | Template tags for categorization |
| `features` | array | List of template features |
| `requirements` | object | Requirements and dependencies |

## Template Functions

GoCrafter provides template functions:

### String Functions

```go
{{.ProjectName | lower}}        // Convert to lowercase
{{.ProjectName | upper}}        // Convert to uppercase
{{.ProjectName | title}}        // Convert to title case
```

### Conditional Functions

```go
{{if hasFeature "Authentication"}}
// Include authentication code
{{end}}

{{if contains .Features "JWT"}}
// Include JWT handling
{{end}}
```

### Custom Functions

```go
// Check if a feature is selected
{{if hasFeature "API Documentation"}}
import "github.com/swaggo/swag"
{{end}}

// String manipulation
{{.ModuleName | replace "github.com/" ""}}
```

## Best Practices

### File Organization

1. **Follow Go conventions**: Use standard Go project layout
2. **Separate concerns**: Keep different functionalities in separate packages
3. **Use internal package**: Keep implementation details private

### Template Design

1. **Make it configurable**: Use template variables for customization
2. **Provide defaults**: Always have sensible default values
3. **Document well**: Include comprehensive README and comments

### Variable Usage

```go
// Good: Check if variable exists
{{- if .DatabaseType}}
// Database code here
{{- end}}

// Good: Provide defaults
{{.Port | default "8080"}}

// Avoid: Assuming variables exist
{{.DatabaseType}} // Might be empty
```

### Conditional Blocks

```go
// Database configuration
{{- if .DatabaseType}}
{{- if eq .DatabaseType "postgres"}}
import "github.com/lib/pq"
{{- else if eq .DatabaseType "mysql"}}
import "github.com/go-sql-driver/mysql"
{{- end}}
{{- end}}

// Feature-based inclusion
{{- if hasFeature "Authentication"}}
import "github.com/golang-jwt/jwt/v5"
{{- end}}
```

## Testing Templates

### Manual Testing

```bash
# Generate project with your template
gocrafter new test-project --template my-custom-template

# Verify generated structure
cd test-project
go mod tidy
go build
go test ./...
```

### Automated Testing

Create a test script:

```bash
#!/bin/bash
# test-template.sh

TEMPLATE_NAME="my-custom-template"
TEST_PROJECT="test-${TEMPLATE_NAME}"

echo "Testing template: $TEMPLATE_NAME"

# Clean up previous test
rm -rf "$TEST_PROJECT"

# Generate project
gocrafter new "$TEST_PROJECT" --template "$TEMPLATE_NAME" --quick

# Test the generated project
cd "$TEST_PROJECT"

# Check if it compiles
if go build ./...; then
    echo "‚úÖ Build successful"
else
    echo "‚ùå Build failed"
    exit 1
fi

# Run tests
if go test ./...; then
    echo "‚úÖ Tests passed"
else
    echo "‚ùå Tests failed"
    exit 1
fi

# Clean up
cd ..
rm -rf "$TEST_PROJECT"

echo "‚úÖ Template test completed successfully"
```

### Integration Testing

Test with different configurations:

```bash
# Test with different databases
gocrafter new test-postgres --template my-template --quick
# Select postgres database

gocrafter new test-mysql --template my-template --quick
# Select mysql database

# Test with different features
gocrafter new test-features --template my-template --quick
# Select various features
```

## Contributing Templates

### Template Guidelines

1. **Follow naming conventions**: Use lowercase with hyphens
2. **Provide complete examples**: Include working code
3. **Add comprehensive tests**: Ensure template works correctly
4. **Document thoroughly**: Include detailed README and comments

### Submission Process

1. **Fork the repository**
2. **Create template directory** in `templates/`
3. **Add template files** and metadata
4. **Test thoroughly** with different configurations
5. **Submit pull request** with description

### Template Checklist

- [ ] Template metadata (`template.json`) is complete
- [ ] All template variables are documented
- [ ] Generated code compiles and runs
- [ ] README includes setup instructions
- [ ] Makefile includes common tasks
- [ ] Tests are included and pass
- [ ] Docker configuration (if applicable)
- [ ] CI/CD configuration (if applicable)

### Example Pull Request

```markdown
## Add New Template: GraphQL API

### Description
Adds a new template for GraphQL API servers using gqlgen.

### Features
- GraphQL server with gqlgen
- Schema-first development
- Resolver generation
- Authentication middleware
- Database integration
- Docker support

### Testing
- [x] Generated project compiles
- [x] Tests pass
- [x] Docker build works
- [x] Documentation is complete

### Files Added
- `templates/graphql-api/`
- `templates/graphql-api/template.json`
- `templates/graphql-api/schema.graphql`
- ... (other files)
```

## Advanced Features

### Multi-File Templates

For complex file generation:

```go
// In template file: internal/model/{{.PackageName}}.go
package model

type {{.ProjectName | title}} struct {
    ID   uint   `json:"id"`
    Name string `json:"name"`
}
```

### Environment-Specific Files

```go
// docker-compose.yml (only if Docker is enabled)
{{- if .HasDocker}}
version: '3.8'
services:
  {{.PackageName}}:
    build: .
    ports:
      - "8080:8080"
{{- end}}
```

### Dynamic Dependencies

```go
// go.mod with dynamic dependencies
module {{.ModuleName}}

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    {{- if hasFeature "Authentication"}}
    github.com/golang-jwt/jwt/v5 v5.0.0
    {{- end}}
    {{- if .DatabaseType}}
    {{- if eq .DatabaseType "postgres"}}
    gorm.io/driver/postgres v1.5.0
    gorm.io/gorm v1.25.0
    {{- end}}
    {{- end}}
)
```

---

For more information about template development, see the [GoCrafter documentation](https://github.com/kubex-ecosystem/gocrafter/docs).

/// docs/user-guide.md ///
# üìñ GoCrafter User Guide

This comprehensive guide will help you get the most out of GoCrafter, from basic usage to advanced features.

## Table of Contents

- [Installation](#installation)
- [Basic Usage](#basic-usage)
- [Interactive Mode](#interactive-mode)
- [Quick Mode](#quick-mode)
- [Templates](#templates)
- [Configuration](#configuration)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Installation

### Using Go Install (Recommended)

```bash
go install github.com/kubex-ecosystem/gocrafter@latest
```

### Download Binary

```bash
# Linux
curl -sSL https://github.com/kubex-ecosystem/gocrafter/releases/latest/download/gocrafter-linux-amd64.tar.gz | tar xz

# macOS
curl -sSL https://github.com/kubex-ecosystem/gocrafter/releases/latest/download/gocrafter-darwin-amd64.tar.gz | tar xz

# Windows
curl -sSL https://github.com/kubex-ecosystem/gocrafter/releases/latest/download/gocrafter-windows-amd64.zip -o gocrafter.zip
unzip gocrafter.zip
```

### Build from Source

```bash
git clone https://github.com/kubex-ecosystem/gocrafter.git
cd gocrafter
go build -o gocrafter cmd/main.go cmd/wrpr.go cmd/usage.go
```

## Basic Usage

### Available Commands

```bash
gocrafter --help                    # Show help
gocrafter version                   # Show version
gocrafter list                      # List available templates
gocrafter info <template>           # Show template details
gocrafter new                       # Create new project (interactive)
gocrafter new [name] [flags]        # Create new project (quick)
```

### Your First Project

1. **Interactive Mode (Recommended for beginners):**
   ```bash
   gocrafter new
   ```

2. **Quick Mode:**
   ```bash
   gocrafter new my-api --template api-rest
   ```

3. **Navigate to your project:**
   ```bash
   cd my-api
   ```

4. **Start developing:**
   ```bash
   make run    # Start the application
   make test   # Run tests
   make build  # Build the application
   ```

## Interactive Mode

The interactive mode provides a guided experience for creating projects:

### Step-by-Step Process

1. **Project Information**
   - Project name
   - Go module name

2. **Template Selection**
   - Choose from available templates
   - View descriptions and features

3. **Database Configuration**
   - Select database type
   - Configure cache layer

4. **Feature Selection**
   - Authentication options
   - API documentation
   - Monitoring and metrics
   - Middleware options

5. **DevOps Integration**
   - Docker configuration
   - Kubernetes manifests
   - CI/CD pipeline

6. **Confirmation**
   - Review configuration
   - Confirm and generate

### Example Interactive Session

```bash
$ gocrafter new
üöÄ Welcome to GoCrafter - Go Project Generator!
Let's craft your perfect Go project together...

? What's your project name? blog-api
? What's your Go module name? github.com/myuser/blog-api
? What type of project do you want to create?
  ‚ùØ api-rest - REST API with HTTP server (Gin/Fiber)
    cli-tool - Command-line application with Cobra
    microservice - Microservice with gRPC and HTTP
    grpc-service - Pure gRPC service
    worker - Background worker/job processor
    library - Go library/package

? Which database do you want to use?
  ‚ùØ postgres
    mysql
    mongodb
    sqlite
    none

? Do you want to add a cache layer?
  ‚ùØ redis
    memcached
    none

? Which additional features do you want to include?
  ‚óâ Authentication (JWT)
  ‚óâ API Documentation (Swagger)
  ‚óØ Health Checks
  ‚óâ Metrics (Prometheus)
  ‚óØ Distributed Tracing
  ‚óØ Rate Limiting
  ‚óâ CORS Middleware
  ‚óØ Request Validation

? Include Docker configuration? Yes
? Include Kubernetes manifests? No
? Which CI/CD system do you want to use?
  ‚ùØ github
    gitlab
    jenkins
    azure
    none

üìã Project Configuration Summary:
  Name: blog-api
  Module: github.com/myuser/blog-api
  Template: api-rest
  Database: postgres
  Cache: redis
  Features: Authentication (JWT), API Documentation (Swagger), Metrics (Prometheus), CORS Middleware
  Docker: true
  Kubernetes: false
  CI/CD: github

? Does this look correct? Proceed with project generation? Yes

üöÄ Starting project generation...
‚úÖ Project generated successfully!
üìÅ Location: blog-api
```

## Quick Mode

Quick mode allows for rapid project creation with minimal prompts:

### Basic Quick Mode

```bash
# Create project with default settings
gocrafter new my-project --template api-rest

# Specify module name
gocrafter new my-project --template api-rest
# Then enter module name when prompted
```

### Advanced Quick Mode

```bash
# Create project in specific directory
gocrafter new my-api --template api-rest --output ./projects

# Use configuration file
gocrafter new my-api --config project-config.json

# Quick mode with minimal prompts
gocrafter new my-api --template api-rest --quick
```

### Flags and Options

| Flag | Short | Description |
|------|-------|-------------|
| `--template` | `-t` | Specify template name |
| `--output` | `-o` | Output directory |
| `--config` | `-c` | Configuration file |
| `--quick` | `-q` | Quick mode with minimal prompts |

## Templates

GoCrafter provides several built-in templates for different project types:

### API REST Template

**Description:** Full-featured REST API server with modern Go practices.

**Features:**
- Gin web framework
- Structured logging
- Environment configuration
- Database integration
- Authentication middleware
- API documentation
- Health checks
- Docker support

**Use Cases:**
- Web APIs
- Backend services
- RESTful microservices

**Generated Structure:**
```
my-api/
‚îú‚îÄ‚îÄ cmd/main.go
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ handler/
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îî‚îÄ‚îÄ service/
‚îú‚îÄ‚îÄ pkg/
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ README.md
```

### CLI Tool Template

**Description:** Command-line application with Cobra framework.

**Features:**
- Cobra CLI framework
- Subcommands support
- Configuration management
- Structured logging
- Cross-platform builds

**Use Cases:**
- Command-line utilities
- Development tools
- System administration tools

### Microservice Template

**Description:** Microservice with gRPC and HTTP endpoints.

**Features:**
- gRPC server
- HTTP gateway
- Service discovery
- Health checks
- Metrics collection
- Distributed tracing

**Use Cases:**
- Distributed systems
- Service-oriented architecture
- Cloud-native applications

### gRPC Service Template

**Description:** Pure gRPC service with protocol buffers.

**Features:**
- Protocol buffers
- gRPC server
- Client generation
- Streaming support
- Service mesh ready

**Use Cases:**
- High-performance services
- Inter-service communication
- Real-time applications

### Worker Template

**Description:** Background job processor.

**Features:**
- Queue integration
- Job processing
- Retry mechanisms
- Monitoring hooks
- Graceful shutdown

**Use Cases:**
- Background processing
- Asynchronous tasks
- Data processing pipelines

### Library Template

**Description:** Go library/package template.

**Features:**
- Package structure
- Documentation templates
- Testing framework
- CI/CD workflows
- Version management

**Use Cases:**
- Reusable packages
- Open source libraries
- Internal utilities

## Configuration

### Environment Variables

Projects generated by GoCrafter use environment variables for configuration:

```bash
# Application settings
ENVIRONMENT=development
PORT=8080
LOG_LEVEL=info

# Database settings (if applicable)
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=secret
DB_NAME=myapp

# Cache settings (if applicable)
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=
REDIS_DB=0

# Authentication (if applicable)
JWT_SECRET=your-secret-key
JWT_EXPIRATION=3600
```

### Configuration Files

You can use configuration files for project generation:

**project-config.json:**
```json
{
  "name": "my-awesome-api",
  "module": "github.com/myuser/my-awesome-api",
  "template": "api-rest",
  "database": "postgres",
  "cache": "redis",
  "features": [
    "Authentication (JWT)",
    "API Documentation (Swagger)",
    "Health Checks"
  ],
  "docker": true,
  "kubernetes": false,
  "ci": "github"
}
```

**Usage:**
```bash
gocrafter new --config project-config.json
```

## Advanced Features

### Custom Output Directory

```bash
# Create project in specific directory
gocrafter new my-api --template api-rest --output /path/to/projects

# Create project in subdirectory
gocrafter new my-api --template api-rest --output ./workspace/apis
```

### Template Information

```bash
# List all templates
gocrafter list

# Get detailed template information
gocrafter info api-rest

# Show template structure (if available)
gocrafter info api-rest --show-structure
```

### Batch Project Creation

Create multiple projects using a script:

```bash
#!/bin/bash

# Create multiple microservices
services=("user-service" "order-service" "notification-service")

for service in "${services[@]}"; do
  gocrafter new "$service" \
    --template microservice \
    --output ./microservices \
    --quick
done
```

## Best Practices

### Project Naming

- Use lowercase with hyphens: `my-awesome-api`
- Be descriptive: `user-management-service`
- Avoid special characters: stick to letters, numbers, and hyphens

### Module Naming

- Follow Go module conventions: `github.com/username/project-name`
- Use your actual repository path
- Keep it consistent with your project structure

### Template Selection

- **API REST**: For HTTP APIs and web services
- **CLI Tool**: For command-line applications
- **Microservice**: For distributed systems
- **gRPC Service**: For high-performance inter-service communication
- **Worker**: For background processing
- **Library**: For reusable packages

### Feature Selection

- Start with basic features and add more later
- Consider your deployment environment
- Think about monitoring and observability early

### Development Workflow

1. Generate project with GoCrafter
2. Initialize Git repository
3. Set up development environment
4. Configure database and dependencies
5. Start with tests
6. Implement features incrementally
7. Set up CI/CD pipeline

## Troubleshooting

### Common Issues

#### Template Not Found

**Error:** `template 'api-rest' not found`

**Solution:**
- Check available templates: `gocrafter list`
- Ensure correct template name
- Verify GoCrafter installation

#### Permission Denied

**Error:** `permission denied`

**Solution:**
- Check directory permissions
- Ensure you have write access to output directory
- Run with appropriate permissions

#### Module Import Issues

**Error:** Module import problems in generated project

**Solution:**
- Verify module name is correct
- Run `go mod tidy` in project directory
- Check Go version compatibility

#### Binary Not Found

**Error:** `gocrafter: command not found`

**Solution:**
- Ensure `$GOPATH/bin` is in your `$PATH`
- Verify installation: `which gocrafter`
- Try absolute path to binary

### Getting Help

1. **Check documentation:** Read this guide and README
2. **Search issues:** Look for similar problems on GitHub
3. **Create issue:** Report bugs or request features
4. **Community:** Join discussions and ask questions

### Debug Mode

Enable debug logging for troubleshooting:

```bash
export GOCRAFTER_LOG_LEVEL=debug
gocrafter new my-project --template api-rest
```

## Tips and Tricks

### Aliases

Create shell aliases for common operations:

```bash
# Add to your .bashrc or .zshrc
alias gcnew='gocrafter new'
alias gclist='gocrafter list'
alias gcinfo='gocrafter info'
```

### Templates Directory

Find where templates are stored:

```bash
gocrafter info api-rest --show-path
```

### Quick Project Setup

Create a complete project setup script:

```bash
#!/bin/bash
PROJECT_NAME=$1
TEMPLATE=${2:-api-rest}

echo "Creating project: $PROJECT_NAME with template: $TEMPLATE"

gocrafter new "$PROJECT_NAME" --template "$TEMPLATE" --quick
cd "$PROJECT_NAME"

echo "Setting up Git repository..."
git init
git add .
git commit -m "Initial commit from GoCrafter"

echo "Installing dependencies..."
go mod tidy

echo "Running initial test..."
make test

echo "Project $PROJECT_NAME is ready!"
echo "Next steps:"
echo "  cd $PROJECT_NAME"
echo "  make run"
```

---

For more information, visit the [GoCrafter GitHub repository](https://github.com/kubex-ecosystem/gocrafter).

/// examples/sample-kit/metadata.yaml ///
name: "golang-basic-api"
description: "Basic Go REST API with Gin framework"
language: "go"
version: "1.0.0"
author: "GoCrafter Team"
repository: ""
dependencies:
  - "go"
  - "make"
  - "docker"
placeholders:
  - "project_name"
  - "author"
  - "license"
  - "description"
  - "port"
  - "go_version"
tags:
  - "api"
  - "rest"
  - "gin"
  - "go"

/// examples/sample-kit/scaffold.sh ///
#!/bin/bash

# Post-generation script for golang-basic-api kit
# This script runs after the project is generated

set -e

echo "üöÄ Running post-generation setup for {{project_name}}..."

# Check if Go is installed
if ! command -v go &> /dev/null; then
    echo "‚ùå Go is not installed. Please install Go {{go_version}} or higher."
    exit 1
fi

# Check Go version
GO_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
REQUIRED_VERSION="{{go_version}}"

if [ "$(printf '%s\n' "$REQUIRED_VERSION" "$GO_VERSION" | sort -V | head -n1)" != "$REQUIRED_VERSION" ]; then
    echo "‚ö†Ô∏è  Warning: Go version $GO_VERSION is lower than required $REQUIRED_VERSION"
fi

# Initialize Go module
echo "üì¶ Initializing Go module..."
go mod tidy

# Create necessary directories
echo "üìÅ Creating project directories..."
mkdir -p bin
mkdir -p logs
mkdir -p docs
mkdir -p internal/handler
mkdir -p internal/middleware
mkdir -p internal/model
mkdir -p internal/service
mkdir -p internal/config

# Create .gitignore
echo "üìù Creating .gitignore..."
cat > .gitignore << 'EOF'
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib
bin/
*.test
*.out

# Go workspace file
go.work

# Dependency directories
vendor/

# Go build cache
.cache/

# IDE directories
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Environment files
.env
.env.local
.env.*.local

# Log files
*.log
logs/

# Coverage files
coverage.out
coverage.html

# Air configuration
.air.toml

# Temporary files
tmp/
temp/
EOF

# Create basic project structure files
echo "üèóÔ∏è  Creating project structure..."

# Create internal/config/config.go
cat > internal/config/config.go << 'EOF'
package config

import (
	"os"
	"strconv"
)

type Config struct {
	Port     string
	GinMode  string
	LogLevel string
	AppName  string
	Version  string
}

func New() *Config {
	return &Config{
		Port:     getEnv("PORT", "8080"),
		GinMode:  getEnv("GIN_MODE", "debug"),
		LogLevel: getEnv("LOG_LEVEL", "info"),
		AppName:  getEnv("APP_NAME", "{{project_name}}"),
		Version:  getEnv("APP_VERSION", "1.0.0"),
	}
}

func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

func getEnvAsBool(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if boolValue, err := strconv.ParseBool(value); err == nil {
			return boolValue
		}
	}
	return defaultValue
}
EOF

# Check if make is available
if command -v make &> /dev/null; then
    echo "üîß Running initial build..."
    make deps
    make build
else
    echo "‚ö†Ô∏è  Make is not available. Running go build directly..."
    go build -o bin/{{project_name}} main.go
fi

# Create development tools configuration
echo "‚öôÔ∏è  Creating development configuration..."

# Create .air.toml for hot reloading
cat > .air.toml << 'EOF'
root = "."
testdata_dir = "testdata"
tmp_dir = "tmp"

[build]
  args_bin = []
  bin = "./tmp/main"
  cmd = "go build -o ./tmp/main ."
  delay = 1000
  exclude_dir = ["assets", "tmp", "vendor", "testdata"]
  exclude_file = []
  exclude_regex = ["_test.go"]
  exclude_unchanged = false
  follow_symlink = false
  full_bin = ""
  include_dir = []
  include_ext = ["go", "tpl", "tmpl", "html"]
  include_file = []
  kill_delay = "0s"
  log = "build-errors.log"
  poll = false
  poll_interval = 0
  rerun = false
  rerun_delay = 500
  send_interrupt = false
  stop_on_root = false

[color]
  app = ""
  build = "yellow"
  main = "magenta"
  runner = "green"
  watcher = "cyan"

[log]
  main_only = false
  time = false

[misc]
  clean_on_exit = false

[screen]
  clear_on_rebuild = false
  keep_scroll = true
EOF

echo "‚úÖ Post-generation setup completed successfully!"
echo ""
echo "üìã Next steps:"
echo "   1. cd {{project_name}}"
echo "   2. cp .env.example .env  # Configure environment variables"
echo "   3. make run              # Start the application"
echo "   4. Open http://localhost:{{port}}/health to test"
echo ""
echo "üõ†Ô∏è  Available commands:"
echo "   make help         # Show all available commands"
echo "   make run          # Run the application"
echo "   make test         # Run tests"
echo "   make build        # Build the application"
echo "   make docker-build # Build Docker image"
echo ""
echo "üéâ Happy coding!"

/// examples/sample-kit/templates/README.md ///
# {{project_name}}

{{description}}

## Features

- REST API with Gin framework
- Structured logging with Logrus
- Environment configuration
- Docker support
- Health check endpoint

## Getting Started

### Prerequisites

- Go {{go_version}} or higher
- Make (optional, for build automation)
- Docker (optional, for containerization)

### Installation

1. Clone the repository:

```bash
git clone <repository-url>
cd {{project_name}}
```

2. Install dependencies:

```bash
go mod download
```

3. Create a `.env` file (optional):

```bash
cp .env.example .env
```

### Running the Application

#### Local Development

```bash
# Run directly
go run main.go

# Or using make
make run
```

#### Using Docker

```bash
# Build and run with Docker
make docker-run
```

### API Endpoints

- `GET /health` - Health check endpoint
- `GET /api/v1/hello?name=<name>` - Hello world endpoint
- `GET /api/v1/info` - Project information

### Examples

```bash
# Health check
curl http://localhost:{{port}}/health

# Hello endpoint
curl http://localhost:{{port}}/api/v1/hello?name=Developer

# Project info
curl http://localhost:{{port}}/api/v1/info
```

## Development

### Building

```bash
# Build binary
make build

# Build for different platforms
make build-linux
make build-windows
make build-darwin
```

### Testing

```bash
# Run tests
make test

# Run tests with coverage
make test-coverage
```

### Linting

```bash
# Run linter
make lint
```

## Docker

### Build Image

```bash
make docker-build
```

### Run Container

```bash
make docker-run
```

## Configuration

Environment variables:

- `PORT` - Server port (default: {{port}})
- `GIN_MODE` - Gin mode (debug, release, test)
- `LOG_LEVEL` - Log level (debug, info, warn, error)

## License

This project is licensed under the {{license}} License - see the [LICENSE](LICENSE) file for details.

## Author

{{author}}

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

/// examples/sample-kit/templates/main.go ///
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	"github.com/sirupsen/logrus"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		logrus.Info("No .env file found")
	}

	// Setup logging
	logrus.SetLevel(logrus.InfoLevel)
	logrus.SetFormatter(&logrus.JSONFormatter{})

	// Get port from environment
	port := os.Getenv("PORT")
	if port == "" {
		port = "{{port}}"
	}

	// Setup Gin router
	r := gin.Default()

	// Add middleware
	r.Use(gin.Logger())
	r.Use(gin.Recovery())

	// Routes
	setupRoutes(r)

	// Start server
	logrus.Infof("Starting {{project_name}} server on port %s", port)
	if err := http.ListenAndServe(":"+port, r); err != nil {
		log.Fatal("Failed to start server:", err)
	}
}

func setupRoutes(r *gin.Engine) {
	// Health check
	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":  "ok",
			"service": "{{project_name}}",
			"version": "1.0.0",
		})
	})

	// API v1 routes
	v1 := r.Group("/api/v1")
	{
		v1.GET("/hello", func(c *gin.Context) {
			name := c.DefaultQuery("name", "World")
			c.JSON(http.StatusOK, gin.H{
				"message": fmt.Sprintf("Hello, %s!", name),
			})
		})

		v1.GET("/info", func(c *gin.Context) {
			c.JSON(http.StatusOK, gin.H{
				"project":     "{{project_name}}",
				"description": "{{description}}",
				"author":      "{{author}}",
				"license":     "{{license}}",
				"go_version":  "{{go_version}}",
			})
		})
	}
}

/// gocrafter.go ///
package gocrafter

import "github.com/spf13/cobra"

// GoCrafter is a Go project scaffolding and templating tool.
// It provides a structured way to generate Go projects with best practices,
// modern tooling, and customizable templates.

type GoCrafter interface {
	// Alias returns the alias for the command.
	Alias() string
	// ShortDescription returns a brief description of the command.
	ShortDescription() string
	// LongDescription returns a detailed description of the command.
	LongDescription() string
	// Usage returns the usage string for the command.
	Usage() string
	// Examples returns a list of example usages for the command.
	Examples() []string
	// Active returns true if the command is active and should be executed.
	Active() bool
	// Module returns the name of the module.
	Module() string
	// Execute runs the command and returns an error if it fails.
	Execute() error
	// Command returns the cobra.Command associated with this module.
	Command() *cobra.Command
}

/// internal/generator/config.go ///
package generator

import (
	"encoding/json"
	"fmt"
	"path/filepath"
	"strings"
)

// ProjectConfig holds the configuration for generating a new project
type ProjectConfig struct {
	Name       string            `json:"name"`
	Module     string            `json:"module"`
	Template   string            `json:"template"`
	Database   string            `json:"database,omitempty"`
	Cache      string            `json:"cache,omitempty"`
	Queue      string            `json:"queue,omitempty"`
	Monitoring []string          `json:"monitoring,omitempty"`
	Docker     bool              `json:"docker"`
	Kubernetes bool              `json:"kubernetes"`
	CI         string            `json:"ci,omitempty"`
	Features   []string          `json:"features,omitempty"`
	Custom     map[string]string `json:"custom,omitempty"`
	OutputDir  string            `json:"output_dir,omitempty"`
}

// TemplateVars contains all variables that will be replaced in templates
type TemplateVars struct {
	ProjectName   string
	ModuleName    string
	PackageName   string
	DatabaseType  string
	CacheType     string
	QueueType     string
	HasDocker     bool
	HasKubernetes bool
	HasMonitoring bool
	CIType        string
	Features      []string
	Custom        map[string]string
}

// NewProjectConfig creates a new project configuration with defaults
func NewProjectConfig() *ProjectConfig {
	return &ProjectConfig{
		Docker:     true,
		Kubernetes: false,
		Features:   []string{},
		Custom:     make(map[string]string),
	}
}

// Validate checks if the configuration is valid
func (c *ProjectConfig) Validate() error {
	if c.Name == "" {
		return fmt.Errorf("project name cannot be empty")
	}

	if c.Module == "" {
		return fmt.Errorf("module name cannot be empty")
	}

	if c.Template == "" {
		return fmt.Errorf("template cannot be empty")
	}

	// Validate project name (should be valid for directory names)
	if strings.ContainsAny(c.Name, "/\\:*?\"<>|") {
		return fmt.Errorf("project name contains invalid characters")
	}

	return nil
}

// ToTemplateVars converts the config to template variables
func (c *ProjectConfig) ToTemplateVars() *TemplateVars {
	packageName := strings.ReplaceAll(c.Name, "-", "")
	packageName = strings.ReplaceAll(packageName, "_", "")
	packageName = strings.ToLower(packageName)

	return &TemplateVars{
		ProjectName:   c.Name,
		ModuleName:    c.Module,
		PackageName:   packageName,
		DatabaseType:  c.Database,
		CacheType:     c.Cache,
		QueueType:     c.Queue,
		HasDocker:     c.Docker,
		HasKubernetes: c.Kubernetes,
		HasMonitoring: len(c.Monitoring) > 0,
		CIType:        c.CI,
		Features:      c.Features,
		Custom:        c.Custom,
	}
}

// GetOutputPath returns the full output path for the project
func (c *ProjectConfig) GetOutputPath() string {
	if c.OutputDir != "" {
		return filepath.Join(c.OutputDir, c.Name)
	}
	return c.Name
}

// ToJSON converts the config to JSON string
func (c *ProjectConfig) ToJSON() (string, error) {
	data, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return "", err
	}
	return string(data), nil
}

// FromJSON creates a config from JSON string
func FromJSON(jsonStr string) (*ProjectConfig, error) {
	config := NewProjectConfig()
	err := json.Unmarshal([]byte(jsonStr), config)
	if err != nil {
		return nil, err
	}
	return config, nil
}

// SupportedTemplates returns the list of supported templates
func SupportedTemplates() []string {
	return []string{
		"api-rest",
		"cli-tool",
		"microservice",
		"grpc-service",
		"worker",
		"library",
	}
}

// SupportedDatabases returns the list of supported databases
func SupportedDatabases() []string {
	return []string{
		"postgres",
		"mysql",
		"mongodb",
		"sqlite",
		"redis",
	}
}

// SupportedCaches returns the list of supported cache systems
func SupportedCaches() []string {
	return []string{
		"redis",
		"memcached",
		"in-memory",
	}
}

// SupportedQueues returns the list of supported queue systems
func SupportedQueues() []string {
	return []string{
		"rabbitmq",
		"kafka",
		"redis",
		"nats",
	}
}

// SupportedCISystems returns the list of supported CI systems
func SupportedCISystems() []string {
	return []string{
		"github",
		"gitlab",
		"jenkins",
		"azure",
	}
}

/// internal/generator/generator.go ///
package generator

import (
	"bytes"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	gl "github.com/kubex-ecosystem/gocrafter/logger"
)

// Generator handles project generation from templates
type Generator struct {
	config        *ProjectConfig
	templateVars  *TemplateVars
	templatesPath string
}

// NewGenerator creates a new project generator
func NewGenerator(config *ProjectConfig, templatesPath string) *Generator {
	return &Generator{
		config:        config,
		templateVars:  config.ToTemplateVars(),
		templatesPath: templatesPath,
	}
}

// Generate creates a new project based on the configuration
func (g *Generator) Generate() error {
	gl.Log("Info", fmt.Sprintf("Starting project generation: %s (Template: %s)", g.config.Name, g.config.Template))

	// Validate configuration
	if err := g.config.Validate(); err != nil {
		return fmt.Errorf("invalid configuration: %w", err)
	}

	// Create output directory
	outputPath := g.config.GetOutputPath()
	if err := g.createOutputDirectory(outputPath); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Get template path
	templatePath := filepath.Join(g.templatesPath, g.config.Template)
	if !g.templateExists(templatePath) {
		return fmt.Errorf("template '%s' not found", g.config.Template)
	}

	// Generate project from template
	if err := g.generateFromTemplate(templatePath, outputPath); err != nil {
		return fmt.Errorf("failed to generate project: %w", err)
	}

	// Post-generation tasks
	if err := g.runPostGeneration(outputPath); err != nil {
		gl.Log("warn", fmt.Sprintf("Post-generation tasks failed: %v", err))
	}

	gl.Log("info", fmt.Sprintf("Project generated successfully: %s", outputPath))
	return nil
}

func (g *Generator) createOutputDirectory(outputPath string) error {
	// Check if directory already exists
	if _, err := os.Stat(outputPath); err == nil {
		return fmt.Errorf("directory '%s' already exists", outputPath)
	}

	// Create directory with all parent directories
	return os.MkdirAll(outputPath, 0755)
}

func (g *Generator) templateExists(templatePath string) bool {
	info, err := os.Stat(templatePath)
	if err != nil {
		return false
	}
	return info.IsDir()
}

func (g *Generator) generateFromTemplate(templatePath, outputPath string) error {
	return filepath.WalkDir(templatePath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Get relative path from template root
		relPath, err := filepath.Rel(templatePath, path)
		if err != nil {
			return err
		}

		// Skip template root
		if relPath == "." {
			return nil
		}

		// Process path with template variables
		processedPath := g.processPath(relPath)
		targetPath := filepath.Join(outputPath, processedPath)

		if d.IsDir() {
			// Create directory
			return os.MkdirAll(targetPath, 0755)
		}

		// Process file
		return g.processFile(path, targetPath)
	})
}

func (g *Generator) processPath(path string) string {
	// Replace template variables in path
	processed := strings.ReplaceAll(path, "{{.ProjectName}}", g.templateVars.ProjectName)
	processed = strings.ReplaceAll(processed, "{{.PackageName}}", g.templateVars.PackageName)
	processed = strings.ReplaceAll(processed, "{{.ModuleName}}", g.templateVars.ModuleName)
	return processed
}

func (g *Generator) processFile(sourcePath, targetPath string) error {
	// Read source file
	content, err := os.ReadFile(sourcePath)
	if err != nil {
		return err
	}

	// Check if file should be processed as template
	if g.shouldProcessAsTemplate(sourcePath) {
		processedContent, err := g.processTemplate(string(content))
		if err != nil {
			return fmt.Errorf("failed to process template %s: %w", sourcePath, err)
		}
		content = []byte(processedContent)
	}

	// Write target file
	if err := os.MkdirAll(filepath.Dir(targetPath), 0755); err != nil {
		return err
	}

	return os.WriteFile(targetPath, content, 0644)
}

func (g *Generator) shouldProcessAsTemplate(filePath string) bool {
	// Process certain file types as templates
	ext := strings.ToLower(filepath.Ext(filePath))
	templateExtensions := []string{
		".go", ".mod", ".sum", ".yaml", ".yml", ".json", ".toml",
		".md", ".txt", ".env", ".dockerfile", ".makefile",
	}

	for _, templateExt := range templateExtensions {
		if ext == templateExt {
			return true
		}
	}

	// Also check if filename indicates it's a template
	base := strings.ToLower(filepath.Base(filePath))
	templateFiles := []string{
		"makefile", "dockerfile", "readme", "license", "gitignore",
	}

	for _, templateFile := range templateFiles {
		if strings.Contains(base, templateFile) {
			return true
		}
	}

	return false
}

func (g *Generator) processTemplate(content string) (string, error) {
	// Create template with helper functions
	tmpl := template.New("project").Funcs(template.FuncMap{
		"lower":    strings.ToLower,
		"upper":    strings.ToUpper,
		"title":    strings.Title,
		"contains": strings.Contains,
		"hasFeature": func(feature string) bool {
			for _, f := range g.templateVars.Features {
				if strings.Contains(strings.ToLower(f), strings.ToLower(feature)) {
					return true
				}
			}
			return false
		},
	})

	// Parse template
	tmpl, err := tmpl.Parse(content)
	if err != nil {
		return "", err
	}

	// Execute template
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, g.templateVars)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

func (g *Generator) runPostGeneration(outputPath string) error {
	gl.Log("info", fmt.Sprintf("Running post-generation tasks: %s", outputPath))

	// Initialize Go module
	if err := g.initGoModule(outputPath); err != nil {
		return fmt.Errorf("failed to initialize Go module: %w", err)
	}

	// Run go mod tidy
	if err := g.runGoModTidy(outputPath); err != nil {
		return fmt.Errorf("failed to run go mod tidy: %w", err)
	}

	// Format Go code
	if err := g.formatGoCode(outputPath); err != nil {
		return fmt.Errorf("failed to format Go code: %w", err)
	}

	return nil
}

func (g *Generator) initGoModule(outputPath string) error {
	if g.config.Module == "" {
		return nil
	}

	// Check if go.mod already exists
	goModPath := filepath.Join(outputPath, "go.mod")
	if _, err := os.Stat(goModPath); err == nil {
		gl.Log("info", "go.mod already exists, skipping module initialization")
		return nil
	}

	gl.Log("info", fmt.Sprintf("Initializing Go module: %s", g.config.Module))
	return nil // go mod init will be handled by the template
}

func (g *Generator) runGoModTidy(outputPath string) error {
	gl.Log("info", fmt.Sprintf("Running go mod tidy: %s", outputPath))
	// This would execute: go mod tidy in the output directory
	// For now, we'll leave this as a placeholder since we want to generate templates first
	return nil
}

func (g *Generator) formatGoCode(outputPath string) error {
	gl.Log("info", fmt.Sprintf("Formatting Go code: %s", outputPath))
	// This would execute: gofmt -w . in the output directory
	// For now, we'll leave this as a placeholder
	return nil
}

// GetTemplateInfo returns information about a template
func GetTemplateInfo(templatesPath, templateName string) (*TemplateInfo, error) {
	templatePath := filepath.Join(templatesPath, templateName)

	if !templateExists(templatePath) {
		return nil, fmt.Errorf("template '%s' not found", templateName)
	}

	// Read template metadata if it exists
	metadataPath := filepath.Join(templatePath, "template.json")
	if _, err := os.Stat(metadataPath); err == nil {
		// Template has metadata file
		return readTemplateMetadata(metadataPath)
	}

	// Default template info
	return &TemplateInfo{
		Name:        templateName,
		Description: fmt.Sprintf("Template for %s projects", templateName),
		Version:     "1.0.0",
	}, nil
}

// TemplateInfo contains information about a template
type TemplateInfo struct {
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Version     string   `json:"version"`
	Author      string   `json:"author,omitempty"`
	Tags        []string `json:"tags,omitempty"`
	Features    []string `json:"features,omitempty"`
}

func templateExists(templatePath string) bool {
	info, err := os.Stat(templatePath)
	if err != nil {
		return false
	}
	return info.IsDir()
}

func readTemplateMetadata(metadataPath string) (*TemplateInfo, error) {
	// This would read and parse the template.json file
	// For now, return a default
	return &TemplateInfo{
		Name:        "unknown",
		Description: "Template",
		Version:     "1.0.0",
	}, nil
}

/// internal/generator/kit_generator.go ///
package generator

import (
	"fmt"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/kubex-ecosystem/gocrafter/internal/types"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
)

// KitGenerator generates projects from kits
type KitGenerator struct {
	kitManager *KitManagerImpl
	replacer   *PlaceholderReplacer
}

// NewKitGenerator creates a new kit-based project generator
func NewKitGenerator(kitManager *KitManagerImpl) *KitGenerator {
	return &KitGenerator{
		kitManager: kitManager,
		replacer:   NewPlaceholderReplacer(),
	}
}

// GenerateFromKit generates a project from a kit
func (kg *KitGenerator) GenerateFromKit(req *types.GenerationRequest) error {
	gl.Log("info", fmt.Sprintf("Generating project '%s' from kit '%s'", req.ProjectName, req.KitName))

	// Get kit
	kit, err := kg.kitManager.GetKit(req.KitName)
	if err != nil {
		return fmt.Errorf("failed to get kit: %w", err)
	}

	// Validate output path
	if err := kg.validateOutputPath(req.OutputPath); err != nil {
		return fmt.Errorf("invalid output path: %w", err)
	}

	// Setup placeholders
	kg.replacer.SetPlaceholdersFromRequest(req)

	// Add kit-specific placeholders
	if err := kg.setupKitPlaceholders(kit, req); err != nil {
		return fmt.Errorf("failed to setup kit placeholders: %w", err)
	}

	// Generate project structure
	templatesPath := filepath.Join(kit.LocalPath, "templates")
	if err := kg.generateFromTemplates(templatesPath, req.OutputPath); err != nil {
		return fmt.Errorf("failed to generate from templates: %w", err)
	}

	// Run post-generation script if exists
	if err := kg.runPostGenerationScript(kit.LocalPath, req.OutputPath); err != nil {
		gl.Log("warn", fmt.Sprintf("Post-generation script failed: %v", err))
	}

	gl.Log("info", fmt.Sprintf("Project '%s' generated successfully at: %s", req.ProjectName, req.OutputPath))
	return nil
}

// ValidateGenerationRequest validates a generation request
func (kg *KitGenerator) ValidateGenerationRequest(req *types.GenerationRequest) error {
	// Validate required fields
	if req.KitName == "" {
		return fmt.Errorf("kit name is required")
	}
	if req.ProjectName == "" {
		return fmt.Errorf("project name is required")
	}
	if req.OutputPath == "" {
		return fmt.Errorf("output path is required")
	}

	// Check if kit exists
	_, err := kg.kitManager.GetKit(req.KitName)
	if err != nil {
		return fmt.Errorf("kit validation failed: %w", err)
	}

	return nil
}

// GetKitPlaceholders returns all placeholders required by a kit
func (kg *KitGenerator) GetKitPlaceholders(kitName string) ([]string, error) {
	kit, err := kg.kitManager.GetKit(kitName)
	if err != nil {
		return nil, fmt.Errorf("failed to get kit: %w", err)
	}

	// Get placeholders from kit metadata
	placeholders := make([]string, len(kit.Placeholders))
	copy(placeholders, kit.Placeholders)

	// Extract additional placeholders from templates
	templatePlaceholders, err := ExtractPlaceholdersFromKit(kit.LocalPath)
	if err != nil {
		gl.Log("warn", fmt.Sprintf("Failed to extract placeholders from templates: %v", err))
	} else {
		// Merge with metadata placeholders
		seen := make(map[string]bool)
		for _, p := range placeholders {
			seen[p] = true
		}

		for _, p := range templatePlaceholders {
			if !seen[p] {
				placeholders = append(placeholders, p)
				seen[p] = true
			}
		}
	}

	return placeholders, nil
}

// Private methods

func (kg *KitGenerator) validateOutputPath(outputPath string) error {
	// Check if path already exists
	if _, err := os.Stat(outputPath); err == nil {
		return fmt.Errorf("output path '%s' already exists", outputPath)
	}

	// Check if parent directory exists and is writable
	parentDir := filepath.Dir(outputPath)
	if info, err := os.Stat(parentDir); err != nil {
		if os.IsNotExist(err) {
			// Try to create parent directories
			if err := os.MkdirAll(parentDir, 0755); err != nil {
				return fmt.Errorf("failed to create parent directories: %w", err)
			}
		} else {
			return fmt.Errorf("failed to access parent directory: %w", err)
		}
	} else if !info.IsDir() {
		return fmt.Errorf("parent path is not a directory: %s", parentDir)
	}

	return nil
}

func (kg *KitGenerator) setupKitPlaceholders(kit *types.Kit, req *types.GenerationRequest) error {
	// Set kit metadata as placeholders
	kg.replacer.SetPlaceholder("kit_name", kit.Name)
	kg.replacer.SetPlaceholder("kit_version", kit.Version)
	kg.replacer.SetPlaceholder("kit_author", kit.Author)

	// Set default values for common placeholders if not provided
	kg.setDefaultPlaceholders(req)

	return nil
}

func (kg *KitGenerator) setDefaultPlaceholders(req *types.GenerationRequest) {
	defaults := map[string]string{
		"author":      "Developer",
		"license":     "MIT",
		"description": fmt.Sprintf("A project generated from kit %s", req.KitName),
		"version":     "1.0.0",
	}

	// Only set defaults if not already provided
	provided := make(map[string]bool)
	for _, p := range req.Placeholders {
		provided[p.Name] = true
	}

	for name, value := range defaults {
		if !provided[name] {
			kg.replacer.SetPlaceholder(name, value)
		}
	}
}

func (kg *KitGenerator) generateFromTemplates(templatesPath, outputPath string) error {
	return filepath.WalkDir(templatesPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Get relative path from templates root
		relPath, err := filepath.Rel(templatesPath, path)
		if err != nil {
			return err
		}

		// Skip templates root
		if relPath == "." {
			return nil
		}

		// Process path with placeholders
		processedPath := kg.replacer.ProcessPath(relPath)
		targetPath := filepath.Join(outputPath, processedPath)

		if d.IsDir() {
			// Create directory
			return os.MkdirAll(targetPath, 0755)
		}

		// Process file
		return kg.processTemplateFile(path, targetPath)
	})
}

func (kg *KitGenerator) processTemplateFile(sourcePath, targetPath string) error {
	// Read source file
	content, err := os.ReadFile(sourcePath)
	if err != nil {
		return fmt.Errorf("failed to read source file: %w", err)
	}

	// Process content with placeholders if it's a template file
	processedContent := string(content)
	if kg.shouldProcessAsTemplate(sourcePath) {
		processedContent, err = kg.replacer.ProcessContent(string(content))
		if err != nil {
			return fmt.Errorf("failed to process template content: %w", err)
		}
	}

	// Ensure target directory exists
	if err := os.MkdirAll(filepath.Dir(targetPath), 0755); err != nil {
		return fmt.Errorf("failed to create target directory: %w", err)
	}

	// Write processed content to target file
	if err := os.WriteFile(targetPath, []byte(processedContent), 0644); err != nil {
		return fmt.Errorf("failed to write target file: %w", err)
	}

	gl.Log("debug", fmt.Sprintf("Generated file: %s", targetPath))
	return nil
}

func (kg *KitGenerator) shouldProcessAsTemplate(filePath string) bool {
	// Check file extension
	ext := strings.ToLower(filepath.Ext(filePath))
	templateExtensions := []string{
		".go", ".mod", ".sum", ".yaml", ".yml", ".json", ".toml",
		".md", ".txt", ".env", ".dockerfile", ".makefile", ".sh",
		".js", ".ts", ".jsx", ".tsx", ".css", ".scss", ".html",
		".py", ".rs", ".java", ".kt", ".cpp", ".c", ".h",
	}

	for _, templateExt := range templateExtensions {
		if ext == templateExt {
			return true
		}
	}

	// Check filename patterns
	base := strings.ToLower(filepath.Base(filePath))
	templateFiles := []string{
		"makefile", "dockerfile", "readme", "license", "gitignore",
		"changelog", "contributing", "notice", "authors",
	}

	for _, templateFile := range templateFiles {
		if strings.Contains(base, templateFile) {
			return true
		}
	}

	// Check for .tpl extension
	if strings.HasSuffix(filePath, ".tpl") {
		return true
	}

	return false
}

func (kg *KitGenerator) runPostGenerationScript(kitPath, outputPath string) error {
	scriptPath := filepath.Join(kitPath, "scaffold.sh")

	// Check if script exists
	if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
		return nil // No script to run
	}

	gl.Log("info", "Running post-generation script...")

	// Make script executable
	if err := os.Chmod(scriptPath, 0755); err != nil {
		return fmt.Errorf("failed to make script executable: %w", err)
	}

	// Run script in the output directory
	cmd := exec.Command("/bin/bash", scriptPath)
	cmd.Dir = outputPath
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// Set environment variables for the script
	cmd.Env = append(os.Environ(),
		fmt.Sprintf("GOCRAFTER_PROJECT_PATH=%s", outputPath),
		fmt.Sprintf("GOCRAFTER_KIT_PATH=%s", kitPath),
	)

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("post-generation script failed: %w", err)
	}

	gl.Log("info", "Post-generation script completed successfully")
	return nil
}

/// internal/generator/kit_manager.go ///
package generator

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/kubex-ecosystem/gocrafter/internal/types"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
	"gopkg.in/yaml.v3"
)

// KitManagerImpl implements the KitManager interface
type KitManagerImpl struct {
	config   *types.KitConfig
	kitsPath string
}

// NewKitManager creates a new kit manager instance
func NewKitManager(config *types.KitConfig) (*KitManagerImpl, error) {
	if config == nil {
		// Default configuration
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return nil, fmt.Errorf("failed to get user home directory: %w", err)
		}

		config = &types.KitConfig{
			KitsPath:    filepath.Join(homeDir, ".gocrafter", "kits"),
			CachePath:   filepath.Join(homeDir, ".gocrafter", "cache"),
			AutoUpdate:  false,
			MaxCacheAge: 7,
		}
	}

	// Ensure directories exist
	if err := os.MkdirAll(config.KitsPath, 0755); err != nil {
		return nil, fmt.Errorf("failed to create kits directory: %w", err)
	}
	if err := os.MkdirAll(config.CachePath, 0755); err != nil {
		return nil, fmt.Errorf("failed to create cache directory: %w", err)
	}

	return &KitManagerImpl{
		config:   config,
		kitsPath: config.KitsPath,
	}, nil
}

// AddKit adds a new kit from repository URL
func (km *KitManagerImpl) AddKit(repoURL string) error {
	gl.Log("info", fmt.Sprintf("Adding kit from repository: %s", repoURL))

	// Parse repository URL to extract kit name
	kitName := km.extractKitNameFromURL(repoURL)
	if kitName == "" {
		return fmt.Errorf("could not extract kit name from URL: %s", repoURL)
	}

	kitPath := filepath.Join(km.kitsPath, kitName)

	// Check if kit already exists
	if _, err := os.Stat(kitPath); err == nil {
		return fmt.Errorf("kit '%s' already exists. Use update command to update it", kitName)
	}

	// Clone or download the kit
	if err := km.downloadKit(repoURL, kitPath); err != nil {
		return fmt.Errorf("failed to download kit: %w", err)
	}

	// Validate kit structure
	if err := km.ValidateKit(kitPath); err != nil {
		// Clean up on validation failure
		os.RemoveAll(kitPath)
		return fmt.Errorf("kit validation failed: %w", err)
	}

	gl.Log("info", fmt.Sprintf("Kit '%s' added successfully", kitName))
	return nil
}

// RemoveKit removes a kit by name
func (km *KitManagerImpl) RemoveKit(name string) error {
	kitPath := filepath.Join(km.kitsPath, name)

	if _, err := os.Stat(kitPath); os.IsNotExist(err) {
		return fmt.Errorf("kit '%s' not found", name)
	}

	if err := os.RemoveAll(kitPath); err != nil {
		return fmt.Errorf("failed to remove kit '%s': %w", name, err)
	}

	gl.Log("info", fmt.Sprintf("Kit '%s' removed successfully", name))
	return nil
}

// ListKits returns all available kits
func (km *KitManagerImpl) ListKits() ([]types.Kit, error) {
	var kits []types.Kit

	entries, err := os.ReadDir(km.kitsPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read kits directory: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		kitPath := filepath.Join(km.kitsPath, entry.Name())
		kit, err := km.loadKitMetadata(kitPath)
		if err != nil {
			gl.Log("warn", fmt.Sprintf("Failed to load kit metadata for '%s': %v", entry.Name(), err))
			continue
		}

		kit.LocalPath = kitPath
		kits = append(kits, *kit)
	}

	return kits, nil
}

// GetKit returns a specific kit by name
func (km *KitManagerImpl) GetKit(name string) (*types.Kit, error) {
	kitPath := filepath.Join(km.kitsPath, name)

	if _, err := os.Stat(kitPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("kit '%s' not found", name)
	}

	kit, err := km.loadKitMetadata(kitPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load kit metadata: %w", err)
	}

	kit.LocalPath = kitPath
	return kit, nil
}

// UpdateKit updates an existing kit
func (km *KitManagerImpl) UpdateKit(name string) error {
	kit, err := km.GetKit(name)
	if err != nil {
		return err
	}

	if kit.Repository == "" {
		return fmt.Errorf("kit '%s' has no repository URL configured", name)
	}

	// Backup current kit
	backupPath := filepath.Join(km.config.CachePath, fmt.Sprintf("%s_backup_%d", name, time.Now().Unix()))
	if err := km.copyDir(kit.LocalPath, backupPath); err != nil {
		return fmt.Errorf("failed to create backup: %w", err)
	}

	// Remove current kit
	if err := os.RemoveAll(kit.LocalPath); err != nil {
		return fmt.Errorf("failed to remove current kit: %w", err)
	}

	// Download updated kit
	if err := km.downloadKit(kit.Repository, kit.LocalPath); err != nil {
		// Restore backup on failure
		km.copyDir(backupPath, kit.LocalPath)
		return fmt.Errorf("failed to download updated kit: %w", err)
	}

	// Validate updated kit
	if err := km.ValidateKit(kit.LocalPath); err != nil {
		// Restore backup on validation failure
		km.copyDir(backupPath, kit.LocalPath)
		return fmt.Errorf("updated kit validation failed: %w", err)
	}

	// Clean up backup
	os.RemoveAll(backupPath)

	gl.Log("info", fmt.Sprintf("Kit '%s' updated successfully", name))
	return nil
}

// ValidateKit validates kit structure and metadata
func (km *KitManagerImpl) ValidateKit(kitPath string) error {
	// Check if metadata.yaml exists
	metadataPath := filepath.Join(kitPath, "metadata.yaml")
	if _, err := os.Stat(metadataPath); os.IsNotExist(err) {
		return fmt.Errorf("metadata.yaml not found in kit")
	}

	// Load and validate metadata
	_, err := km.loadKitMetadata(kitPath)
	if err != nil {
		return fmt.Errorf("invalid metadata: %w", err)
	}

	// Check if templates directory exists
	templatesPath := filepath.Join(kitPath, "templates")
	if info, err := os.Stat(templatesPath); err != nil || !info.IsDir() {
		return fmt.Errorf("templates directory not found in kit")
	}

	return nil
}

// Helper methods

func (km *KitManagerImpl) extractKitNameFromURL(repoURL string) string {
	// Extract kit name from various URL formats
	if strings.Contains(repoURL, "github.com") {
		parts := strings.Split(repoURL, "/")
		if len(parts) >= 2 {
			name := parts[len(parts)-1]
			// Remove .git extension if present
			return strings.TrimSuffix(name, ".git")
		}
	}

	// Fallback: use last part of URL path
	parts := strings.Split(strings.TrimSuffix(repoURL, "/"), "/")
	if len(parts) > 0 {
		return strings.TrimSuffix(parts[len(parts)-1], ".git")
	}

	return ""
}

func (km *KitManagerImpl) downloadKit(repoURL, targetPath string) error {
	// Check if it's a local path
	if km.isLocalPath(repoURL) {
		return km.copyLocalKit(repoURL, targetPath)
	}

	// Try git clone first
	if err := km.gitClone(repoURL, targetPath); err == nil {
		return nil
	}

	// Fallback to HTTP download for archive formats
	return km.httpDownload(repoURL, targetPath)
}

func (km *KitManagerImpl) isLocalPath(path string) bool {
	// Check if it's a local file system path
	if strings.HasPrefix(path, "/") || strings.HasPrefix(path, "./") || strings.HasPrefix(path, "../") {
		return true
	}
	// Check if it's a Windows path
	if len(path) > 1 && path[1] == ':' {
		return true
	}
	return false
}

func (km *KitManagerImpl) copyLocalKit(sourcePath, targetPath string) error {
	// Check if source exists
	if _, err := os.Stat(sourcePath); os.IsNotExist(err) {
		return fmt.Errorf("source path does not exist: %s", sourcePath)
	}

	// Copy the entire directory
	return km.copyDir(sourcePath, targetPath)
}

func (km *KitManagerImpl) gitClone(repoURL, targetPath string) error {
	cmd := exec.Command("git", "clone", repoURL, targetPath)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("git clone failed: %w", err)
	}

	// Remove .git directory to save space
	gitDir := filepath.Join(targetPath, ".git")
	os.RemoveAll(gitDir)

	return nil
}

func (km *KitManagerImpl) httpDownload(repoURL, targetPath string) error {
	// This is a simplified implementation for tar.gz archives
	if !strings.HasSuffix(repoURL, ".tar.gz") {
		return fmt.Errorf("unsupported archive format, only .tar.gz supported for HTTP download")
	}

	resp, err := http.Get(repoURL)
	if err != nil {
		return fmt.Errorf("failed to download archive: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download archive: HTTP %d", resp.StatusCode)
	}

	// Extract tar.gz
	return km.extractTarGz(resp.Body, targetPath)
}

func (km *KitManagerImpl) extractTarGz(src io.Reader, targetPath string) error {
	gzr, err := gzip.NewReader(src)
	if err != nil {
		return err
	}
	defer gzr.Close()

	tr := tar.NewReader(gzr)

	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}

		path := filepath.Join(targetPath, header.Name)

		switch header.Typeflag {
		case tar.TypeDir:
			if err := os.MkdirAll(path, 0755); err != nil {
				return err
			}
		case tar.TypeReg:
			if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
				return err
			}

			file, err := os.Create(path)
			if err != nil {
				return err
			}

			if _, err := io.Copy(file, tr); err != nil {
				file.Close()
				return err
			}
			file.Close()
		}
	}

	return nil
}

func (km *KitManagerImpl) loadKitMetadata(kitPath string) (*types.Kit, error) {
	metadataPath := filepath.Join(kitPath, "metadata.yaml")
	data, err := os.ReadFile(metadataPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read metadata file: %w", err)
	}

	var kit types.Kit
	if err := yaml.Unmarshal(data, &kit); err != nil {
		return nil, fmt.Errorf("failed to parse metadata YAML: %w", err)
	}

	// Validate required fields
	if kit.Name == "" {
		return nil, fmt.Errorf("kit name is required in metadata")
	}
	if kit.Description == "" {
		return nil, fmt.Errorf("kit description is required in metadata")
	}

	return &kit, nil
}

func (km *KitManagerImpl) copyDir(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}

		dstPath := filepath.Join(dst, relPath)

		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode())
		}

		srcFile, err := os.Open(path)
		if err != nil {
			return err
		}
		defer srcFile.Close()

		if err := os.MkdirAll(filepath.Dir(dstPath), 0755); err != nil {
			return err
		}

		dstFile, err := os.Create(dstPath)
		if err != nil {
			return err
		}
		defer dstFile.Close()

		_, err = io.Copy(dstFile, srcFile)
		return err
	})
}

/// internal/generator/replacer.go ///
package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"time"

	"github.com/kubex-ecosystem/gocrafter/internal/types"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
)

// PlaceholderReplacer handles placeholder replacement in templates
type PlaceholderReplacer struct {
	placeholders map[string]string
	funcMap      template.FuncMap
}

// NewPlaceholderReplacer creates a new placeholder replacer
func NewPlaceholderReplacer() *PlaceholderReplacer {
	pr := &PlaceholderReplacer{
		placeholders: make(map[string]string),
		funcMap:      make(template.FuncMap),
	}

	// Add default template functions
	pr.setupDefaultFunctions()
	return pr
}

// SetPlaceholder sets a placeholder value
func (pr *PlaceholderReplacer) SetPlaceholder(name, value string) {
	pr.placeholders[name] = value
}

// SetPlaceholders sets multiple placeholders from a map
func (pr *PlaceholderReplacer) SetPlaceholders(placeholders map[string]string) {
	for name, value := range placeholders {
		pr.placeholders[name] = value
	}
}

// SetPlaceholdersFromRequest sets placeholders from a generation request
func (pr *PlaceholderReplacer) SetPlaceholdersFromRequest(req *types.GenerationRequest) {
	// Set basic placeholders
	pr.SetPlaceholder("project_name", req.ProjectName)
	pr.SetPlaceholder("current_year", fmt.Sprintf("%d", time.Now().Year()))

	// Set placeholders from request
	for _, placeholder := range req.Placeholders {
		pr.SetPlaceholder(placeholder.Name, placeholder.Value)
	}

	// Set derived placeholders
	pr.setDerivedPlaceholders(req.ProjectName)
}

// ProcessContent processes content with placeholder replacement
func (pr *PlaceholderReplacer) ProcessContent(content string) (string, error) {
	// First pass: simple string replacement for basic placeholders
	processed := pr.simpleReplace(content)

	// Second pass: template processing for complex expressions
	return pr.templateProcess(processed)
}

// ProcessPath processes a file path with placeholder replacement
func (pr *PlaceholderReplacer) ProcessPath(path string) string {
	return pr.simpleReplace(path)
}

// GetMissingPlaceholders returns placeholders found in content but not defined
func (pr *PlaceholderReplacer) GetMissingPlaceholders(content string) []string {
	var missing []string
	seen := make(map[string]bool)

	// Find all placeholder patterns
	re := regexp.MustCompile(`\{\{([^}]+)\}\}`)
	matches := re.FindAllStringSubmatch(content, -1)

	for _, match := range matches {
		if len(match) > 1 {
			placeholder := strings.TrimSpace(match[1])

			// Skip template functions and complex expressions
			if strings.Contains(placeholder, " ") || strings.Contains(placeholder, ".") {
				continue
			}

			if _, exists := pr.placeholders[placeholder]; !exists && !seen[placeholder] {
				missing = append(missing, placeholder)
				seen[placeholder] = true
			}
		}
	}

	return missing
}

// Private methods

func (pr *PlaceholderReplacer) setupDefaultFunctions() {
	pr.funcMap = template.FuncMap{
		// String manipulation
		"upper":    strings.ToUpper,
		"lower":    strings.ToLower,
		"title":    strings.Title,
		"trim":     strings.TrimSpace,
		"replace":  strings.ReplaceAll,
		"contains": strings.Contains,
		"hasPrefix": strings.HasPrefix,
		"hasSuffix": strings.HasSuffix,

		// Path manipulation
		"base":     filepath.Base,
		"dir":      filepath.Dir,
		"ext":      filepath.Ext,
		"join":     filepath.Join,

		// Conversion
		"kebab": func(s string) string {
			return strings.ToLower(strings.ReplaceAll(s, " ", "-"))
		},
		"snake": func(s string) string {
			return strings.ToLower(strings.ReplaceAll(s, " ", "_"))
		},
		"camel": func(s string) string {
			words := strings.Fields(s)
			if len(words) == 0 {
				return s
			}
			result := strings.ToLower(words[0])
			for _, word := range words[1:] {
				result += strings.Title(strings.ToLower(word))
			}
			return result
		},
		"pascal": func(s string) string {
			words := strings.Fields(s)
			var result strings.Builder
			for _, word := range words {
				result.WriteString(strings.Title(strings.ToLower(word)))
			}
			return result.String()
		},

		// Utilities
		"now": func() string {
			return time.Now().Format("2006-01-02 15:04:05")
		},
		"date": func(format string) string {
			return time.Now().Format(format)
		},
		"env": os.Getenv,
		"default": func(defaultValue string, value string) string {
			if value == "" {
				return defaultValue
			}
			return value
		},
	}
}

func (pr *PlaceholderReplacer) setDerivedPlaceholders(projectName string) {
	if projectName == "" {
		return
	}

	// Set derived values
	pr.SetPlaceholder("package_name", strings.ToLower(strings.ReplaceAll(projectName, "-", "")))
	pr.SetPlaceholder("module_name", strings.ToLower(strings.ReplaceAll(projectName, " ", "-")))
	pr.SetPlaceholder("class_name", strings.Title(strings.ReplaceAll(projectName, "-", " ")))
	pr.SetPlaceholder("const_name", strings.ToUpper(strings.ReplaceAll(projectName, "-", "_")))

	// Go-specific placeholders
	if goVersion := os.Getenv("GO_VERSION"); goVersion != "" {
		pr.SetPlaceholder("go_version", goVersion)
	} else {
		pr.SetPlaceholder("go_version", "1.24") // Default Go version
	}
}

func (pr *PlaceholderReplacer) simpleReplace(content string) string {
	result := content

	for name, value := range pr.placeholders {
		// Replace {{placeholder_name}} patterns
		pattern := fmt.Sprintf("{{%s}}", name)
		result = strings.ReplaceAll(result, pattern, value)

		// Also support {{.placeholder_name}} patterns for template compatibility
		dotPattern := fmt.Sprintf("{{.%s}}", name)
		result = strings.ReplaceAll(result, dotPattern, value)
	}

	return result
}

func (pr *PlaceholderReplacer) templateProcess(content string) (string, error) {
	// Create template with custom functions
	tmpl := template.New("content").Funcs(pr.funcMap)

	// Parse template
	tmpl, err := tmpl.Parse(content)
	if err != nil {
		// If template parsing fails, return original content with a warning
		gl.Log("warn", fmt.Sprintf("Template parsing failed, using simple replacement: %v", err))
		return content, nil
	}

	// Execute template with placeholders as data
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, pr.placeholders); err != nil {
		// If template execution fails, return original content with a warning
		gl.Log("warn", fmt.Sprintf("Template execution failed, using simple replacement: %v", err))
		return content, nil
	}

	return buf.String(), nil
}

// ExtractPlaceholdersFromKit extracts all placeholders from a kit's templates
func ExtractPlaceholdersFromKit(kitPath string) ([]string, error) {
	var placeholders []string
	seen := make(map[string]bool)

	templatesPath := filepath.Join(kitPath, "templates")

	err := filepath.Walk(templatesPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		// Read file content
		content, err := os.ReadFile(path)
		if err != nil {
			gl.Log("warn", fmt.Sprintf("Failed to read file %s: %v", path, err))
			return nil // Continue walking
		}

		// Extract placeholders from content
		re := regexp.MustCompile(`\{\{([^}]+)\}\}`)
		matches := re.FindAllStringSubmatch(string(content), -1)

		for _, match := range matches {
			if len(match) > 1 {
				placeholder := strings.TrimSpace(match[1])

				// Clean up placeholder name (remove dots, spaces, etc.)
				placeholder = strings.TrimPrefix(placeholder, ".")
				if idx := strings.Index(placeholder, " "); idx != -1 {
					placeholder = placeholder[:idx]
				}

				if placeholder != "" && !seen[placeholder] {
					placeholders = append(placeholders, placeholder)
					seen[placeholder] = true
				}
			}
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to walk templates directory: %w", err)
	}

	return placeholders, nil
}

/// internal/prompt/interactive.go ///
package prompt

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/AlecAivazis/survey/v2"
	"github.com/kubex-ecosystem/gocrafter/internal/generator"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
)

// InteractivePrompt handles interactive configuration prompts
type InteractivePrompt struct {
	config *generator.ProjectConfig
}

// NewInteractivePrompt creates a new interactive prompt handler
func NewInteractivePrompt() *InteractivePrompt {
	return &InteractivePrompt{
		config: generator.NewProjectConfig(),
	}
}

// Run executes the interactive prompt flow
func (p *InteractivePrompt) Run() (*generator.ProjectConfig, error) {
	gl.Log("info", "Starting interactive project setup")
	// Print welcome message
	// This is a placeholder for the logger, replace with actual logger if needed
	gl.Log("info", "üöÄ Welcome to GoCrafter - Go Project Generator!")
	gl.Log("info", "Let's craft your perfect Go project together...")

	// Project basic info
	if err := p.promptProjectInfo(); err != nil {
		return nil, err
	}

	// Template selection
	if err := p.promptTemplate(); err != nil {
		return nil, err
	}

	// Database selection
	if err := p.promptDatabase(); err != nil {
		return nil, err
	}

	// Additional features
	if err := p.promptFeatures(); err != nil {
		return nil, err
	}

	// DevOps configuration
	if err := p.promptDevOps(); err != nil {
		return nil, err
	}

	// Final confirmation
	if err := p.confirmConfiguration(); err != nil {
		return nil, err
	}

	return p.config, nil
}

func (p *InteractivePrompt) promptProjectInfo() error {
	questions := []*survey.Question{
		{
			Name: "name",
			Prompt: &survey.Input{
				Message: "What's your project name?",
				Help:    "This will be used as the directory name and default package name",
			},
			Validate: survey.Required,
		},
		{
			Name: "module",
			Prompt: &survey.Input{
				Message: "What's your Go module name?",
				Help:    "e.g., github.com/username/project-name",
			},
			Validate: survey.Required,
		},
	}

	answers := struct {
		Name   string
		Module string
	}{}

	err := survey.Ask(questions, &answers)
	if err != nil {
		return err
	}

	p.config.Name = answers.Name
	p.config.Module = answers.Module

	return nil
}

func (p *InteractivePrompt) promptTemplate() error {
	templates := generator.SupportedTemplates()
	templateDescriptions := map[string]string{
		"api-rest":     "REST API with HTTP server (Gin/Fiber)",
		"cli-tool":     "Command-line application with Cobra",
		"microservice": "Microservice with gRPC and HTTP",
		"grpc-service": "Pure gRPC service",
		"worker":       "Background worker/job processor",
		"library":      "Go library/package",
	}

	options := make([]string, len(templates))
	for i, tmpl := range templates {
		desc := templateDescriptions[tmpl]
		options[i] = fmt.Sprintf("%s - %s", tmpl, desc)
	}

	var selected string
	prompt := &survey.Select{
		Message: "What type of project do you want to create?",
		Options: options,
		Help:    "Choose the template that best fits your project needs",
	}

	err := survey.AskOne(prompt, &selected)
	if err != nil {
		return err
	}

	// Extract template name from selection
	p.config.Template = strings.Split(selected, " - ")[0]

	return nil
}

func (p *InteractivePrompt) promptDatabase() error {
	// Only ask for database if it's relevant for the template
	if p.config.Template == "library" || p.config.Template == "cli-tool" {
		return nil
	}

	databases := generator.SupportedDatabases()
	databases = append([]string{"none"}, databases...)

	var selected string
	prompt := &survey.Select{
		Message: "Which database do you want to use?",
		Options: databases,
		Help:    "Select 'none' if you don't need a database",
	}

	err := survey.AskOne(prompt, &selected)
	if err != nil {
		return err
	}

	if selected != "none" {
		p.config.Database = selected

		// Ask for cache if database is selected
		caches := generator.SupportedCaches()
		caches = append([]string{"none"}, caches...)

		var cacheSelected string
		cachePrompt := &survey.Select{
			Message: "Do you want to add a cache layer?",
			Options: caches,
		}

		err = survey.AskOne(cachePrompt, &cacheSelected)
		if err != nil {
			return err
		}

		if cacheSelected != "none" {
			p.config.Cache = cacheSelected
		}
	}

	return nil
}

func (p *InteractivePrompt) promptFeatures() error {
	features := []string{
		"Authentication (JWT)",
		"API Documentation (Swagger)",
		"Health Checks",
		"Metrics (Prometheus)",
		"Distributed Tracing",
		"Rate Limiting",
		"CORS Middleware",
		"Request Validation",
		"Logging Middleware",
		"Recovery Middleware",
	}

	var selected []string
	prompt := &survey.MultiSelect{
		Message: "Which additional features do you want to include?",
		Options: features,
		Help:    "Select all features you want to include in your project",
	}

	err := survey.AskOne(prompt, &selected)
	if err != nil {
		return err
	}

	p.config.Features = selected

	return nil
}

func (p *InteractivePrompt) promptDevOps() error {
	// Docker
	var includeDocker bool
	dockerPrompt := &survey.Confirm{
		Message: "Include Docker configuration?",
		Default: true,
		Help:    "Includes Dockerfile and docker-compose.yml",
	}

	err := survey.AskOne(dockerPrompt, &includeDocker)
	if err != nil {
		return err
	}
	p.config.Docker = includeDocker

	// Kubernetes
	if includeDocker {
		var includeK8s bool
		k8sPrompt := &survey.Confirm{
			Message: "Include Kubernetes manifests?",
			Default: false,
			Help:    "Includes deployment, service, and configmap YAML files",
		}

		err = survey.AskOne(k8sPrompt, &includeK8s)
		if err != nil {
			return err
		}
		p.config.Kubernetes = includeK8s
	}

	// CI/CD
	ciSystems := generator.SupportedCISystems()
	ciSystems = append([]string{"none"}, ciSystems...)

	var selectedCI string
	ciPrompt := &survey.Select{
		Message: "Which CI/CD system do you want to use?",
		Options: ciSystems,
		Help:    "This will generate appropriate workflow files",
	}

	err = survey.AskOne(ciPrompt, &selectedCI)
	if err != nil {
		return err
	}

	if selectedCI != "none" {
		p.config.CI = selectedCI
	}

	return nil
}

func (p *InteractivePrompt) confirmConfiguration() error {
	// Print summary of the configuration
	gl.Log("info", "üìã Project Configuration Summary:")
	gl.Log("info", "  Name: %s\n", p.config.Name)
	gl.Log("info", "  Module: %s\n", p.config.Module)
	gl.Log("info", "  Template: %s\n", p.config.Template)
	if p.config.Database != "" {
		gl.Log("info", fmt.Sprintf("  Database: %s\n", p.config.Database))
	}
	if p.config.Cache != "" {
		gl.Log("info", fmt.Sprintf("  Cache: %s\n", p.config.Cache))
	}
	if len(p.config.Features) > 0 {
		gl.Log("info", fmt.Sprintf("  Features: %s\n", strings.Join(p.config.Features, ", ")))
	}
	gl.Log("info", fmt.Sprintf("  Docker: %t\n", p.config.Docker))
	gl.Log("info", fmt.Sprintf("  Kubernetes: %t\n", p.config.Kubernetes))
	if p.config.CI != "" {
		gl.Log("info", fmt.Sprintf("  CI/CD: %s\n", p.config.CI))
	}

	gl.Log("info", fmt.Sprintf("  Output Directory: %s\n", filepath.Join(".", p.config.Name)))

	var confirm bool
	confirmPrompt := &survey.Confirm{
		Message: "Does this look correct? Proceed with project generation?",
		Default: true,
	}

	err := survey.AskOne(confirmPrompt, &confirm)
	if err != nil {
		return err
	}

	if !confirm {
		return fmt.Errorf("project generation cancelled by user")
	}

	return nil
}

// QuickPrompt runs a simplified prompt for quick project generation
func QuickPrompt(template string) (*generator.ProjectConfig, error) {
	config := generator.NewProjectConfig()
	config.Template = template

	questions := []*survey.Question{
		{
			Name: "name",
			Prompt: &survey.Input{
				Message: "Project name:",
			},
			Validate: survey.Required,
		},
		{
			Name: "module",
			Prompt: &survey.Input{
				Message: "Module name:",
			},
			Validate: survey.Required,
		},
	}

	answers := struct {
		Name   string
		Module string
	}{}

	err := survey.Ask(questions, &answers)
	if err != nil {
		return nil, err
	}

	config.Name = answers.Name
	config.Module = answers.Module

	return config, nil
}

/// internal/prompt/kit.go ///
package prompt

import (
	"fmt"
	"strings"

	"github.com/AlecAivazis/survey/v2"
	"github.com/kubex-ecosystem/gocrafter/internal/types"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
)

// KitPrompt handles prompting for kit-specific placeholders
type KitPrompt struct{}

// NewKitPrompt creates a new kit prompt instance
func NewKitPrompt() *KitPrompt {
	return &KitPrompt{}
}

// PromptForPlaceholders prompts the user for placeholder values
func (kp *KitPrompt) PromptForPlaceholders(required []string, existing []types.PlaceholderValue) ([]types.PlaceholderValue, error) {
	// Create a map of existing values for quick lookup
	existingMap := make(map[string]string)
	for _, pv := range existing {
		existingMap[pv.Name] = pv.Value
	}

	var results []types.PlaceholderValue

	// Filter out placeholders that already have values
	var missingPlaceholders []string
	for _, placeholder := range required {
		if _, exists := existingMap[placeholder]; !exists {
			missingPlaceholders = append(missingPlaceholders, placeholder)
		}
	}

	if len(missingPlaceholders) == 0 {
		return results, nil
	}

	gl.Log("info", "üîß Configure Kit Placeholders")
	gl.Log("info", "")

	// Prompt for each missing placeholder
	for _, placeholder := range missingPlaceholders {
		value, err := kp.promptForSinglePlaceholder(placeholder)
		if err != nil {
			return nil, fmt.Errorf("failed to prompt for placeholder '%s': %w", placeholder, err)
		}

		if value != "" {
			results = append(results, types.PlaceholderValue{
				Name:  placeholder,
				Value: value,
			})
		}
	}

	return results, nil
}

// promptForSinglePlaceholder prompts for a single placeholder value
func (kp *KitPrompt) promptForSinglePlaceholder(placeholder string) (string, error) {
	// Get default value and prompt message based on placeholder name
	defaultValue, promptMessage := kp.getPlaceholderDefaults(placeholder)

	var value string
	prompt := &survey.Input{
		Message: promptMessage,
		Default: defaultValue,
	}

	if err := survey.AskOne(prompt, &value); err != nil {
		return "", err
	}

	return strings.TrimSpace(value), nil
}

// getPlaceholderDefaults returns default values and prompt messages for common placeholders
func (kp *KitPrompt) getPlaceholderDefaults(placeholder string) (string, string) {
	switch strings.ToLower(placeholder) {
	case "author":
		return "", "Author name:"
	case "license":
		return "MIT", "License (MIT, Apache-2.0, GPL-3.0, etc.):"
	case "description":
		return "", "Project description:"
	case "version":
		return "1.0.0", "Initial version:"
	case "email":
		return "", "Author email:"
	case "repository", "repo":
		return "", "Repository URL:"
	case "homepage", "url":
		return "", "Project homepage:"
	case "keywords":
		return "", "Keywords (comma-separated):"
	case "database", "db":
		return "sqlite", "Database type (sqlite, mysql, postgres, etc.):"
	case "framework":
		return "", "Framework to use:"
	case "port":
		return "8080", "Default port:"
	case "host":
		return "localhost", "Default host:"
	case "namespace":
		return "", "Namespace:"
	case "package":
		return "", "Package name:"
	case "module":
		return "", "Module name:"
	case "go_version":
		return "1.24", "Go version:"
	case "node_version":
		return "18", "Node.js version:"
	case "python_version":
		return "3.9", "Python version:"
	case "java_version":
		return "17", "Java version:"
	case "api_version":
		return "v1", "API version:"
	case "service_name":
		return "", "Service name:"
	case "organization", "org":
		return "", "Organization name:"
	case "team":
		return "", "Team name:"
	case "environment", "env":
		return "development", "Environment (development, staging, production):"
	case "region":
		return "us-east-1", "AWS region:"
	case "cluster":
		return "", "Cluster name:"
	case "domain":
		return "", "Domain name:"
	case "subdomain":
		return "", "Subdomain:"
	case "protocol":
		return "http", "Protocol (http, https):"
	case "container_registry":
		return "docker.io", "Container registry:"
	case "image_name":
		return "", "Docker image name:"
	case "dockerfile":
		return "Dockerfile", "Dockerfile name:"
	case "makefile":
		return "Makefile", "Makefile name:"
	case "ci_provider":
		return "github", "CI provider (github, gitlab, jenkins, etc.):"
	case "monitoring":
		return "prometheus", "Monitoring system (prometheus, datadog, etc.):"
	case "logging":
		return "logrus", "Logging library:"
	case "testing_framework":
		return "testify", "Testing framework:"
	case "orm":
		return "gorm", "ORM library:"
	case "router":
		return "gin", "HTTP router (gin, echo, mux, etc.):"
	case "cache":
		return "redis", "Cache system (redis, memcached, etc.):"
	case "queue":
		return "redis", "Queue system (redis, rabbitmq, kafka, etc.):"
	case "storage":
		return "local", "Storage type (local, s3, gcs, etc.):"
	default:
		// For unknown placeholders, create a generic prompt
		promptMessage := fmt.Sprintf("%s:", kp.humanizePlaceholderName(placeholder))
		return "", promptMessage
	}
}

// humanizePlaceholderName converts placeholder names to human-readable format
func (kp *KitPrompt) humanizePlaceholderName(placeholder string) string {
	// Replace underscores and hyphens with spaces
	humanized := strings.ReplaceAll(placeholder, "_", " ")
	humanized = strings.ReplaceAll(humanized, "-", " ")

	// Capitalize first letter of each word
	words := strings.Fields(humanized)
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
		}
	}

	return strings.Join(words, " ")
}

// PromptForKitSelection prompts user to select from available kits
func (kp *KitPrompt) PromptForKitSelection(kits []types.Kit) (*types.Kit, error) {
	if len(kits) == 0 {
		return nil, fmt.Errorf("no kits available")
	}

	// Create options for selection
	var options []string
	kitMap := make(map[string]*types.Kit)

	for i := range kits {
		option := fmt.Sprintf("%s - %s", kits[i].Name, kits[i].Description)
		if kits[i].Language != "" {
			option += fmt.Sprintf(" (%s)", kits[i].Language)
		}
		options = append(options, option)
		kitMap[option] = &kits[i]
	}

	var selected string
	prompt := &survey.Select{
		Message: "Select a kit:",
		Options: options,
	}

	if err := survey.AskOne(prompt, &selected); err != nil {
		return nil, err
	}

	return kitMap[selected], nil
}

// ConfirmGeneration asks for final confirmation before generating
func (kp *KitPrompt) ConfirmGeneration(kitName, projectName, outputPath string, placeholders []types.PlaceholderValue) (bool, error) {
	gl.Log("info", "")
	gl.Log("info", "üìã Generation Summary:")
	gl.Log("info", fmt.Sprintf("   Kit: %s", kitName))
	gl.Log("info", fmt.Sprintf("   Project: %s", projectName))
	gl.Log("info", fmt.Sprintf("   Output: %s", outputPath))

	if len(placeholders) > 0 {
		gl.Log("info", "   Placeholders:")
		for _, p := range placeholders {
			if p.Value != "" {
				gl.Log("info", fmt.Sprintf("     %s: %s", p.Name, p.Value))
			}
		}
	}

	gl.Log("info", "")

	var confirm bool
	prompt := &survey.Confirm{
		Message: "Generate project with these settings?",
		Default: true,
	}

	if err := survey.AskOne(prompt, &confirm); err != nil {
		return false, err
	}

	return confirm, nil
}

/// internal/types/kit.go ///
package types

import (
	"time"
)

// Kit represents a pluggable project kit
type Kit struct {
	Name         string            `yaml:"name"`
	Description  string            `yaml:"description"`
	Language     string            `yaml:"language"`
	Version      string            `yaml:"version"`
	Author       string            `yaml:"author"`
	Repository   string            `yaml:"repository"`
	Dependencies []string          `yaml:"dependencies"`
	Placeholders []string          `yaml:"placeholders"`
	Tags         []string          `yaml:"tags"`
	LocalPath    string            `yaml:"-"` // Path where kit is stored locally
	InstallDate  time.Time         `yaml:"-"` // When kit was installed
	Metadata     map[string]string `yaml:"metadata,omitempty"`
}

// KitManager handles kit operations
type KitManager interface {
	// AddKit adds a new kit from repository URL
	AddKit(repoURL string) error
	// RemoveKit removes a kit by name
	RemoveKit(name string) error
	// ListKits returns all available kits
	ListKits() ([]Kit, error)
	// GetKit returns a specific kit by name
	GetKit(name string) (*Kit, error)
	// UpdateKit updates an existing kit
	UpdateKit(name string) error
	// ValidateKit validates kit structure and metadata
	ValidateKit(kitPath string) error
}

// KitConfig represents the configuration for kit management
type KitConfig struct {
	KitsPath    string `yaml:"kits_path"`
	CachePath   string `yaml:"cache_path"`
	AutoUpdate  bool   `yaml:"auto_update"`
	MaxCacheAge int    `yaml:"max_cache_age_days"`
}

// PlaceholderValue represents a placeholder and its value
type PlaceholderValue struct {
	Name        string `yaml:"name"`
	Value       string `yaml:"value"`
	Description string `yaml:"description"`
	Required    bool   `yaml:"required"`
	Default     string `yaml:"default"`
}

// GenerationRequest represents a request to generate a project from a kit
type GenerationRequest struct {
	KitName      string             `yaml:"kit_name"`
	ProjectName  string             `yaml:"project_name"`
	OutputPath   string             `yaml:"output_path"`
	Placeholders []PlaceholderValue `yaml:"placeholders"`
	Options      map[string]string  `yaml:"options"`
}

/// logger/logger.go ///
package logger

import (
	"fmt"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
	"time"

	l "github.com/kubex-ecosystem/logz"
)

type gLog struct {
	l.Logger
	gLogLevel LogType
}

var (
	// debug is a boolean that indicates whether to log debug messages.
	debug bool
	// g is the global logger instance.
	g *gLog = &gLog{
		Logger:    l.GetLogger("GoCrafter"),
		gLogLevel: LogTypeInfo,
	}
)

func init() {
	// Set the debug flag to true for testing purposes.
	debug = false
	// Initialize the global logger instance with a default logger.
	if g.Logger == nil {
		g = &gLog{
			Logger:    l.GetLogger("GoCrafter"),
			gLogLevel: LogTypeInfo,
		}
	}
}

type LogType string

const (
	LogTypeNotice  LogType = "notice"
	LogTypeInfo    LogType = "info"
	LogTypeDebug   LogType = "debug"
	LogTypeError   LogType = "error"
	LogTypeWarn    LogType = "warn"
	LogTypeFatal   LogType = "fatal"
	LogTypePanic   LogType = "panic"
	LogTypeSuccess LogType = "success"
)

// SetDebug is a function that sets the debug flag for logging.
func SetDebug(d bool) { debug = d }

// LogObjLogger is a function that logs messages with the specified log type.
func LogObjLogger[T any](obj *T, logType string, messages ...string) {
	if obj == nil {
		g.ErrorCtx(fmt.Sprintf("log object (%s) is nil", reflect.TypeFor[T]()), map[string]any{
			"context":  "Log",
			"logType":  logType,
			"object":   obj,
			"msg":      messages,
			"showData": true,
		})
		return
	}
	var lgr l.Logger
	if objValueLogger := reflect.ValueOf(obj).Elem().MethodByName("GetLogger"); !objValueLogger.IsValid() {
		if objValueLogger = reflect.ValueOf(obj).Elem().FieldByName("Logger"); !objValueLogger.IsValid() {
			g.ErrorCtx(fmt.Sprintf("log object (%s) does not have a logger field", reflect.TypeFor[T]()), map[string]any{
				"context":  "Log",
				"logType":  logType,
				"object":   obj,
				"msg":      messages,
				"showData": true,
			})
			return
		} else {
			lgrC := objValueLogger.Convert(reflect.TypeFor[l.Logger]())
			if lgrC.IsNil() {
				lgrC = reflect.ValueOf(g.Logger)
			}
			if lgr = lgrC.Interface().(l.Logger); lgr == nil {
				lgr = g.Logger
			}
		}
	} else {
		lgr = g.Logger
	}
	// First level of caller information is the Logger.go itself, so we skip it by using skip=2
	funcName, file, line, ok := getCallerInfo(2)
	if !ok {
		lgr.ErrorCtx("Log: unable to get caller information", nil)
		return
	}
	ctxMessageMap := map[string]any{
		"context":  funcName,
		"file":     file,
		"line":     line,
		"showData": debug,
	}
	fullMessage := strings.Join(messages, " ")
	logType = strings.ToLower(logType)
	if logType != "" {
		if reflect.TypeOf(logType).ConvertibleTo(reflect.TypeFor[LogType]()) {
			lType := LogType(logType)
			ctxMessageMap["logType"] = logType
			logging(lgr, lType, fullMessage, ctxMessageMap)
		} else {
			lgr.ErrorCtx(fmt.Sprintf("logType (%s) is not valid", logType), ctxMessageMap)
		}
	} else {
		lgr.InfoCtx(fullMessage, ctxMessageMap)
	}
}

// Log is a function that logs messages with the specified log type and caller information.
func Log(logType string, messages ...any) {
	// First level of caller information is the Logger.go itself, so we skip it by using skip=2
	funcName, file, line, ok := getCallerInfo(2)
	if !ok {
		g.ErrorCtx("Log: unable to get caller information", nil)
		return
	}
	ctxMessageMap := map[string]any{
		"context":  funcName,
		"file":     file,
		"line":     line,
		"showData": debug,
	}
	fullMessage := ""
	if len(messages) > 0 {
		fullMessage = fmt.Sprintf("%v", messages[0:])
	}
	logType = strings.ToLower(logType)
	if logType != "" {
		if reflect.TypeOf(logType).ConvertibleTo(reflect.TypeFor[LogType]()) {
			lType := LogType(logType)
			ctxMessageMap["logType"] = logType
			logging(g.Logger, lType, fullMessage, ctxMessageMap)
		} else {
			g.ErrorCtx(fmt.Sprintf("logType (%s) is not valid", logType), ctxMessageMap)
		}
	} else {
		g.InfoCtx(fullMessage, ctxMessageMap)
	}
}

// logging is a helper function that logs messages with the specified log type.
func logging(lgr l.Logger, lType LogType, fullMessage string, ctxMessageMap map[string]interface{}) {
	debugCtx := debug
	if !debugCtx {
		if lType == "error" || lType == "fatal" || lType == "panic" || lType == "debug" {
			// If debug is false, set the debug value based on the logType
			debugCtx = true
		} else {
			debugCtx = false
		}
	}
	ctxMessageMap["showData"] = debugCtx
	switch lType {
	case LogTypeInfo:
		fmt.Print("  ")
		lgr.InfoCtx(fullMessage, ctxMessageMap)
		break
	case LogTypeDebug:
		lgr.DebugCtx(fullMessage, ctxMessageMap)
		break
	case LogTypeError:
		lgr.ErrorCtx(fullMessage, ctxMessageMap)
		break
	case LogTypeWarn:
		lgr.WarnCtx(fullMessage, ctxMessageMap)
		break
	case LogTypeNotice:
		lgr.NoticeCtx(fullMessage, ctxMessageMap)
		break
	case LogTypeSuccess:
		lgr.SuccessCtx(fullMessage, ctxMessageMap)
		break
	case LogTypeFatal:
		lgr.FatalCtx(fullMessage, ctxMessageMap)
		break
	case LogTypePanic:
		lgr.FatalCtx(fullMessage, ctxMessageMap)
		break
	default:
		lgr.InfoCtx(fullMessage, ctxMessageMap)
		break
	}
	debugCtx = debug
}

// getCallerInfo extracts caller information and formats it appropriately
func getCallerInfo(skip int) (string, string, int, bool) {
	pc, file, line, ok := runtime.Caller(skip)
	if !ok {
		return "unknown", "unknown", 0, false
	}

	funcName := runtime.FuncForPC(pc).Name()
	if funcName == "" {
		funcName = "unknown"
	}

	// Simplify function name (remove package path)
	if lastSlash := strings.LastIndex(funcName, "/"); lastSlash >= 0 {
		if lastSlash+1 < len(funcName) {
			funcName = funcName[lastSlash+1:]
		} else {
			funcName = "unknown"
		}
	}

	// Format file path based on debug mode
	formattedFile := ""

	if debug {
		formattedFile += file
	} else {
		fileParts := strings.Split(filepath.Clean(filepath.Base(file)), "/")
		if len(fileParts) > 0 {
			// Use the last part of the file path
			formattedFile = fileParts[len(fileParts)-1]
		} else {
			formattedFile = filepath.Clean(filepath.Base(file))
		}
		// Extract just the filename without extension
		fileName := filepath.Base(file)
		if ext := filepath.Ext(fileName); ext != "" {
			// Remove function name extension if it exists
			fileName = strings.TrimSuffix(fileName, ext)
		}
	}
	if debug {
		return formattedFile, formattedFile, line, ok
	}
	timeStampTime := time.Now().Format("2006-01-02 15:04:05")
	timeStampStr := fmt.Sprintf("%s", timeStampTime)
	return timeStampStr, "", line, ok
}

/// support/composer.sh ///
#!/bin/bash

# Define o diret√≥rio base
BASE_DIR="lib"

# Lista de arquivos a serem criados
FILES=(
  "config.sh"
  "utils.sh"
  "platform.sh"
  "build.sh"
  "validate.sh"
  "install_funcs.sh"
  "info.sh"
)

# Cria o diret√≥rio base, se ainda n√£o existir
mkdir -p "$BASE_DIR"

# Cria os arquivos dentro do diret√≥rio
for file in "${FILES[@]}"; do
  FILE_PATH="$BASE_DIR/$file"
  if [[ ! -f "$FILE_PATH" ]]; then
    touch "$FILE_PATH"
    printf '%s' "#!/bin/bash" | tee "$FILE_PATH" >/dev/null
    printf '%s' "# $file - script placeholder" | tee -a "$FILE_PATH" >/dev/null
    chmod +x "$FILE_PATH"
    echo "Criado: $FILE_PATH"
  else
    echo "J√° existe: $FILE_PATH"
  fi
done


/// support/config.sh ///
#!/usr/bin/env bash

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

# Define o diret√≥rio raiz (assumindo que este script est√° em lib/ no root)
_ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
_APP_NAME="${APP_NAME:-$(basename "${_ROOT_DIR}")}"
_PROJECT_NAME="$_APP_NAME"
_OWNER="${OWNER:-rafa-mori}"
# Tenta ler a vers√£o, ou define um fallback
_VERSION=$(cat "$_ROOT_DIR/version/CLI_VERSION" 2>/dev/null || echo "v0.0.0")
# Extrai a vers√£o do Go do go.mod (certifique-se de que este arquivo exista na raiz)
_VERSION_GO=$(grep '^go ' "$_ROOT_DIR/go.mod" | awk '{print $2}')

_LICENSE="MIT"

_ABOUT="################################################################################
  Este script instala o projeto ${_PROJECT_NAME}, vers√£o ${_VERSION}.
  OS suportados: Linux, MacOS, Windows
  Arquiteturas suportadas: amd64, arm64, 386
  Fonte: https://github.com/${_OWNER}/${_PROJECT_NAME}
  Binary Release: https://github.com/${_OWNER}/${_PROJECT_NAME}/releases/latest
  License: ${_LICENSE}
  Notas:
    - [version] √© opcional; se omitido, a √∫ltima vers√£o ser√° utilizada.
    - Se executado localmente, o script tentar√° resolver a vers√£o pelos tags do reposit√≥rio.
    - Instala em ~/.local/bin para usu√°rio n√£o-root ou em /usr/local/bin para root.
    - Adiciona o diret√≥rio de instala√ß√£o √† vari√°vel PATH.
    - Instala o UPX se necess√°rio, ou compila o bin√°rio (build) conforme o comando.
    - Faz download do bin√°rio via URL de release ou efetua limpeza de artefatos.
    - Verifica depend√™ncias e vers√£o do Go.
################################################################################"

_BANNER="################################################################################

            ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
            ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù
            ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
            ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"

# Caminhos para a compila√ß√£o
_CMD_PATH="$_ROOT_DIR/cmd"
_BUILD_PATH="$(dirname "$_CMD_PATH")"
_BINARY="$_BUILD_PATH/$_APP_NAME"

# Diret√≥rios de instala√ß√£o
_LOCAL_BIN="${HOME:-"~"}/.local/bin"
_GLOBAL_BIN="/usr/local/bin"

# Caso queira, defina o OWNER (use no get_release_url)
_OWNER="rafa-mori"

/// support/info.sh ///
#!/usr/bin/env bash
# lib/info.sh ‚Äì Fun√ß√µes para exibir banners e resumo de instala√ß√£o

show_about() {
    printf '%s\n\n' "${_ABOUT:-}"
}

show_banner() {
    printf '\n%s\n\n' "${_BANNER:-}"
}

show_headers() {
    show_banner || return 1
    show_about || return 1
}

summary() {
    local install_dir="$_BINARY"
    log success "Build e instala√ß√£o conclu√≠dos!"
    log success "Bin√°rio: $_BINARY"
    log success "Instalado em: ${install_dir}"
    check_path "$install_dir"
}

export -f show_about
export -f show_banner
export -f show_headers
export -f summary


/// support/install.sh ///
#!/usr/bin/env bash
# shellcheck disable=SC2065,SC2015

# Script Metadata
__secure_logic_version="1.0.0"
__secure_logic_date="$( date +%Y-%m-%d )"
__secure_logic_author="Rafael Mori"
__secure_logic_use_type="exec"
__secure_logic_init_timestamp="$(date +%s)"
__secure_logic_elapsed_time=0

# Check if verbose mode is enabled
if [[ "${MYNAME_VERBOSE:-false}" == "true" ]]; then
  set -x  # Enable debugging
fi

IFS=$'\n\t'

__secure_logic_sourced_name() {
  local _self="${BASH_SOURCE-}"
  _self="${_self//${_kbx_root:-$()}/}"
  _self="${_self//\.sh/}"
  _self="${_self//\-/_}"
  _self="${_self//\//_}"
  echo "_was_sourced_${_self//__/_}"
  return 0
}

__first(){
  if [ "$EUID" -eq 0 ] || [ "$UID" -eq 0 ]; then
    echo "Please do not run as root." 1>&2 > /dev/tty
    exit 1
  elif [ -n "${SUDO_USER:-}" ]; then
    echo "Please do not run as root, but with sudo privileges." 1>&2 > /dev/tty
    exit 1
  else
    # shellcheck disable=SC2155
    local _ws_name="$(__secure_logic_sourced_name)"

    if test "${BASH_SOURCE-}" != "${0}"; then
      if test $__secure_logic_use_type != "lib"; then
        echo "This script is not intended to be sourced." 1>&2 > /dev/tty
        echo "Please run it directly." 1>&2 > /dev/tty
        exit 1
      fi
      # If the script is sourced, we set the variable to true
      # and export it to the environment without changing
      # the shell options.
      export "${_ws_name}"="true"
    else
      if test $__secure_logic_use_type != "exec"; then
        echo "This script is not intended to be executed directly." 1>&2 > /dev/tty
        echo "Please source it instead." 1>&2 > /dev/tty
        exit 1
      fi
      # If the script is executed directly, we set the variable to false
      # and export it to the environment. We also set the shell options
      # to ensure a safe execution.
      export "${_ws_name}"="false"
      set -o errexit # Exit immediately if a command exits with a non-zero status
      set -o nounset # Treat unset variables as an error when substituting
      set -o pipefail # Return the exit status of the last command in the pipeline that failed
      set -o errtrace # If a command fails, the shell will exit immediately
      set -o functrace # If a function fails, the shell will exit immediately
      shopt -s inherit_errexit # Inherit the errexit option in functions
    fi
  fi
}

_DEBUG=${DEBUG:-false}
_HIDE_ABOUT=${HIDE_ABOUT:-false}

__first "$@" >/dev/tty || exit 1

# Carrega os arquivos de biblioteca
_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
#shellcheck source=/dev/null
test -z "${_BANNER:-}" && source "${_SCRIPT_DIR}/config.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f log)" >/dev/null && source "${_SCRIPT_DIR}/utils.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f what_platform)" >/dev/null && source "${_SCRIPT_DIR}/platform.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f check_dependencies)" >/dev/null && source "${_SCRIPT_DIR}/validate.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f detect_shell_rc)" >/dev/null && source "${_SCRIPT_DIR}/install_funcs.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f build_binary)" >/dev/null && source "${_SCRIPT_DIR}/build.sh" || true
#shellcheck source=/dev/null
test -z "$(declare -f show_banner)" >/dev/null && source "${_SCRIPT_DIR}/info.sh" || true

# Inicializa os traps
set_trap "$@"

clear_screen

__main() {
  if ! what_platform; then
    log error "Plataforma n√£o suportada: ${_PLATFORM}"
    exit 1
  fi

  if [[ "${_DEBUG}" != true ]]; then
    show_headers
    if [[ -z "${_HIDE_ABOUT}" ]]; then
      show_about
    fi
  else
    log info "Modo debug ativado; banner ser√° ignorado..."
    if [[ -z "${_HIDE_ABOUT}" ]]; then
      show_about
    fi
  fi

  _ARGS=( "$@" )
  local default_label='Auto detect'
  local arrArgs=( "${_ARGS[@]:0:$#}" )
  local PLATFORM_ARG
  PLATFORM_ARG=$(_get_os_from_args "${arrArgs[1]:-${_PLATFORM}}")
  local ARCH_ARG
  ARCH_ARG=$(_get_arch_arr_from_args "${arrArgs[2]:-${_ARCH}}")

  log info "Comando: ${arrArgs[0]:-}" true
  log info "Plataforma: ${PLATFORM_ARG:-$default_label}" true
  log info "Arquitetura: ${ARCH_ARG:-$default_label}" true
  log info "Args: ${_ARGS[*]:-}" true

  case "${arrArgs[0]:-}" in
    build|BUILD|-b|-B)
      # validate_versions
      log info "Executando comando de build..."
      build_binary "${PLATFORM_ARG}" "${ARCH_ARG}" || exit 1
      ;;
    install|INSTALL|-i|-I)
      log info "Executando comando de instala√ß√£o..."
      read -r -p "Deseja baixar o bin√°rio pr√©-compilado? [y/N] (Caso contr√°rio, far√° build local): " choice </dev/tty
      log info "Escolha do usu√°rio: ${choice}"
      if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
          log info "Baixando bin√°rio pr√©-compilado..."
          install_from_release
      else
          log info "Realizando build local..."
          validate_versions
          build_binary "${PLATFORM_ARG}" "${ARCH_ARG}" || exit 1
          install_binary
      fi
      summary
      ;;
    clear|clean|CLEAN|-c|-C)
      log info "Executando comando de limpeza..."
      clean_artifacts
      log success "Clean executado com sucesso."
      ;;
    *)
      log error "Comando inv√°lido: ${arrArgs[0]:-}"
      echo "Uso: $0 {build|install|clean}"
      ;;
  esac
}

# Fun√ß√£o para limpar artefatos de build
clean_artifacts() {
    log info "Limpando artefatos de build..."
    local platforms=("windows" "darwin" "linux")
    local archs=("amd64" "386" "arm64")
    for platform in "${platforms[@]}"; do
        for arch in "${archs[@]}"; do
            local output_name
            output_name=$(printf '%s_%s_%s' "${_BINARY}" "${platform}" "${arch}")
            if [[ "${platform}" != "windows" ]]; then
                local compress_name="${output_name}.tar.gz"
            else
                output_name="${output_name}.exe"
                local compress_name="${_BINARY}_${platform}_${arch}.zip"
            fi
            rm -f "${output_name}" || true
            rm -f "${compress_name}" || true
        done
    done
    log success "Artefatos de build removidos."
}

__secure_logic_main() {
  local _ws_name
  _ws_name="$(__secure_logic_sourced_name)"
  local _ws_name_val
  _ws_name_val=$(eval "echo \${$_ws_name}")
  if test "${_ws_name_val}" != "true"; then
    __main "$@"
    return $?
  else
    # If the script is sourced, we export the functions
    log error "This script is not intended to be sourced."
    log error "Please run it directly."
    return 1
  fi
}

# echo "MAKE ARGS: ${ARGS[*]:-}"
log info "Starting installation script..."
__secure_logic_main "$@"

__secure_logic_elapsed_time="$(($(date +%s) - __secure_logic_init_timestamp))"

if [[ "${MYNAME_VERBOSE:-false}" == "true" || "${_DEBUG:-false}" == "true" ]]; then
  log info "Script executed in ${__secure_logic_elapsed_time} seconds."
fi

# End of script logic

/// support/install_funcs.sh ///
#!/usr/bin/env bash
# lib/install_funcs.sh ‚Äì Fun√ß√µes para instala√ß√£o e manipula√ß√£o de PATH

install_upx() {
    if ! command -v upx &> /dev/null; then
        if ! sudo -v &> /dev/null; then
            log error "Voc√™ n√£o tem permiss√µes de superusu√°rio para instalar o empacotador de bin√°rios."
            log warn "Se deseja o empacotamento de bin√°rios, instale o UPX manualmente."
            log warn "Veja: https://upx.github.io/"
            return 1
        fi
        if [[ "$(uname)" == "Darwin" ]]; then
            brew install upx >/dev/null
        elif command -v apt-get &> /dev/null; then
            sudo apt-get install -y upx >/dev/null
        elif command -v yum &> /dev/null; then
            sudo yum install -y upx >/dev/null
        elif command -v dnf &> /dev/null; then
            sudo dnf install -y upx >/dev/null
        elif command -v pacman &> /dev/null; then
            sudo pacman -S --noconfirm upx >/dev/null
        elif command -v zypper &> /dev/null; then
            sudo zypper install -y upx >/dev/null
        elif command -v apk &> /dev/null; then
            sudo apk add upx >/dev/null
        elif command -v port &> /dev/null; then
            sudo port install upx >/dev/null
        elif command -v snap &> /dev/null; then
            sudo snap install upx >/dev/null
        elif command -v flatpak &> /dev/null; then
            sudo flatpak install flathub org.uptane.upx -y >/dev/null
        else
            log warn "Se deseja o empacotamento de bin√°rios, instale o UPX manualmente."
            log warn "Veja: https://upx.github.io/"
            return 1
        fi
    fi

    return 0
}

detect_shell_rc() {
    local shell_rc_file
    local user_shell
    user_shell=$(basename "$SHELL")

    case "$user_shell" in
        bash) shell_rc_file="${HOME:-~}/.bashrc" ;;
        zsh) shell_rc_file="${HOME:-~}/.zshrc" ;;
        sh) shell_rc_file="${HOME:-~}/.profile" ;;
        fish) shell_rc_file="${HOME:-~}/.config/fish/config.fish" ;;
        *)
            log warn "Shell n√£o suportado; ajuste o PATH manualmente."
            return 1
            ;;
    esac

    if [ ! -f "$shell_rc_file" ]; then
        log error "Arquivo de configura√ß√£o n√£o encontrado: ${shell_rc_file}"
        return 1
    fi

    echo "$shell_rc_file"

    return 0
}

add_to_path() {
    local target_path="${1:-}"

    local shell_rc_file=""

    local path_expression=""

    path_expression="export PATH=\"${target_path}:\$PATH\""

    shell_rc_file="$(detect_shell_rc)"


    if [ -z "$shell_rc_file" ]; then
        log error "N√£o foi poss√≠vel identificar o arquivo de configura√ß√£o do shell."
        return 1
    fi
    if grep -q "${path_expression}" "$shell_rc_file" 2>/dev/null; then
        log success "$target_path j√° est√° no PATH do $shell_rc_file."
        return 0
    fi

    if [[ -z "${target_path}" ]]; then
        log error "Caminho de destino n√£o fornecido."
        return 1
    fi

    if [[ ! -d "${target_path}" ]]; then
        log error "Caminho de destino n√£o √© um diret√≥rio v√°lido: $target_path"
        return 1
    fi

    if [[ ! -f "${shell_rc_file}" ]]; then
        log error "Arquivo de configura√ß√£o n√£o encontrado: ${shell_rc_file}"
        return 1
    fi

    # echo "export PATH=${target_path}:\$PATH" >> "$shell_rc_file"
    printf '%s\n' "${path_expression}" | tee -a "$shell_rc_file" >/dev/null || {
        log error "Falha ao adicionar $target_path ao PATH em $shell_rc_file."
        return 1
    }

    log success "Adicionado $target_path ao PATH em $shell_rc_file."

    "$SHELL" -c "source ${shell_rc_file}" || {
        log warn "Falha ao recarregar o shell. Por favor, execute 'source ${shell_rc_file}' manualmente."
    }

    return 0
}

install_binary() {
    local SUFFIX="${_PLATFORM_WITH_ARCH}"
    local BINARY_TO_INSTALL="${_BINARY}${SUFFIX:+_${SUFFIX}}"
    log info "Instalando o bin√°rio: '${BINARY_TO_INSTALL}' como '$_APP_NAME'"

    if [ "$(id -u)" -ne 0 ]; then
        log info "Usu√°rio n√£o-root detectado. Instalando em ${_LOCAL_BIN}..."
        mkdir -p "$_LOCAL_BIN"
        cp "$BINARY_TO_INSTALL" "$_LOCAL_BIN/$_APP_NAME" || exit 1
        add_to_path "$_LOCAL_BIN"
    else
        log info "Usu√°rio root detectado. Instalando em ${_GLOBAL_BIN}..."
        cp "$BINARY_TO_INSTALL" "$_GLOBAL_BIN/$_APP_NAME" || exit 1
        add_to_path "$_GLOBAL_BIN"
    fi
}

download_binary() {
    if ! what_platform; then
        log error "Falha ao detectar a plataforma."
        return 1
    fi
    if [[ -z "${_PLATFORM}" ]]; then
        log error "Plataforma n√£o suportada: ${_PLATFORM}"
        return 1
    fi
    local version
    version=$(curl -s "https://api.github.com/repos/${_OWNER}/${_PROJECT_NAME}/releases/latest" | grep "tag_name" | cut -d '"' -f 4 || echo "latest")
    if [ -z "$version" ]; then
        log error "Falha ao determinar a √∫ltima vers√£o."
        return 1
    fi

    local release_url
    release_url=$(get_release_url)
    log info "Baixando o bin√°rio ${_APP_NAME} para OS=${_PLATFORM}, ARCH=${_ARCH}, Vers√£o=${version}..."
    log info "URL de Release: ${release_url}"

    local archive_path="${_TEMP_DIR}/${_APP_NAME}.tar.gz"
    if ! curl -L -o "${archive_path}" "${release_url}"; then
        log error "Falha ao baixar o bin√°rio de: ${release_url}"
        return 1
    fi
    log success "Bin√°rio baixado com sucesso."

    log info "Extraindo o bin√°rio para: $(dirname "${_BINARY}")"
    if ! tar -xzf "${archive_path}" -C "$(dirname "${_BINARY}")"; then
        log error "Falha ao extrair o bin√°rio de: ${archive_path}"
        rm -rf "${_TEMP_DIR}"
        exit 1
    fi

    rm -rf "${_TEMP_DIR}"
    log success "Bin√°rio extra√≠do com sucesso."

    if [ ! -f "$_BINARY" ]; then
        log error "Bin√°rio n√£o encontrado ap√≥s extra√ß√£o: ${_BINARY}"
        exit 1
    fi
    log success "Download e extra√ß√£o de ${_APP_NAME} conclu√≠dos!"
}

install_from_release() {
    download_binary
    install_binary
}

check_path() {
    log info "Verificando se o diret√≥rio de instala√ß√£o est√° no PATH..."
    if ! echo "$PATH" | grep -q "$1"; then
        log warn "$1 n√£o est√° no PATH."
        log warn "Adicione: export PATH=$1:\$PATH"
    else
        log success "$1 j√° est√° no PATH."
    fi
}

export -f install_upx
export -f detect_shell_rc
export -f add_to_path
export -f install_binary
export -f download_binary
export -f install_from_release
export -f check_path

/// support/platform.sh ///
#!/usr/bin/env bash

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

get_release_url() {
    local os="${_PLATFORM%%-*}"
    local format
    if [[ "$os" == "windows" ]]; then
      format="zip"
    else
      format="tar.gz"
    fi
    echo "'https://github.com/${_OWNER}/${_PROJECT_NAME}/releases/download/${_VERSION}/${_PROJECT_NAME}_.${format}'"
}

what_platform() {
  local _os
  _os="$(uname -s)"
  local _arch
  _arch="$(uname -m)"
  local platform=""

  case "${_os}" in
  *Linux*|*Nix*)
    _os="linux"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "armv6") _arch="armv6l" ;;
      "armv8"|"aarch64") _arch="arm64" ;;
      *386*) _arch="386" ;;
    esac
    platform="linux-${_arch}"
    ;;
  *Darwin*)
    _os="darwin"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "arm64") _arch="arm64" ;;
    esac
    platform="darwin-${_arch}"
    ;;
  MINGW*|MSYS*|CYGWIN*|Win*)
    _os="windows"
    case "${_arch}" in
      "x86_64") _arch="amd64" ;;
      "arm64") _arch="arm64" ;;
    esac
    platform="windows-${_arch}"
    ;;
  *)
    log error "Plataforma n√£o suportada: ${_os} ${_arch}"
    log error "Informe este problema aos mantenedores do projeto."
    return 1
    ;;
  esac

  export _PLATFORM_WITH_ARCH="${platform//-/_}"
  export _PLATFORM="${_os}"
  export _ARCH="${_arch}"

  return 0
}

_get_os_arr_from_args() {
  local _PLATFORM_ARG=$1
  if [[ "${_PLATFORM_ARG}" == "all" ]]; then
    echo "windows darwin linux"
  else
    echo "${_PLATFORM_ARG}"
  fi
}

_get_arch_arr_from_args() {
  local _ARCH_ARG=$1
  if [[ "${_ARCH_ARG}" == "all" ]]; then
    echo "amd64 386 arm64"
  else
    echo "${_ARCH_ARG}"
  fi
}

_get_os_from_args() {
  local arg=$1
  case "$arg" in
    all|ALL|a|A|-a|-A) echo "all" ;;
    win|WIN|windows|WINDOWS|w|W|-w|-W) echo "windows" ;;
    linux|LINUX|l|L|-l|-L) echo "linux" ;;
    darwin|DARWIN|macOS|MACOS|m|M|-m|-M) echo "darwin" ;;
    *)
      log error "Plataforma inv√°lida: '${arg}'. Op√ß√µes v√°lidas: windows, linux, darwin, all."
      exit 1
      ;;
  esac
}

_get_arch_from_args() {
  local arg=$1
  case "$arg" in
    all|ALL|a|A|-a|-A) echo "all" ;;
    amd64|AMD64|x86_64|X86_64|x64|X64) echo "amd64" ;;
    arm64|ARM64|aarch64|AARCH64) echo "arm64" ;;
    386|i386|I386) echo "386" ;;
    *)
      log error "Arquitetura inv√°lida: '${arg}'. Op√ß√µes v√°lidas: amd64, arm64, 386."
      exit 1
      ;;
  esac
}

export -f _get_os_arr_from_args
export -f _get_arch_arr_from_args
export -f _get_os_from_args
export -f _get_arch_from_args
export -f get_release_url
export -f what_platform

what_platform "${@}"

/// support/utils.sh ///
#!/usr/bin/env bash
# lib/utils.sh ‚Äì Fun√ß√µes utilit√°rias

set -euo pipefail
set -o errtrace
set -o functrace
set -o posix
IFS=$'\n\t'

# C√≥digos de cor para logs
_SUCCESS="\033[0;32m"
_WARN="\033[0;33m"
_ERROR="\033[0;31m"
_INFO="\033[0;36m"
_NC="\033[0m"

log() {
  local type=${1:-info}
  local message=${2:-}
  local debug=${3:-${DEBUG:-false}}

  case $type in
    info|_INFO|-i|-I)
      if [[ "$debug" == true ]]; then
        printf '%b[_INFO]%b ‚ÑπÔ∏è  %s\n' "$_INFO" "$_NC" "$message"
      fi
      ;;
    warn|_WARN|-w|-W)
      if [[ "$debug" == true ]]; then
        printf '%b[_WARN]%b ‚ö†Ô∏è  %s\n' "$_WARN" "$_NC" "$message"
      fi
      ;;
    error|_ERROR|-e|-E)
      printf '%b[_ERROR]%b ‚ùå  %s\n' "$_ERROR" "$_NC" "$message"
      ;;
    success|_SUCCESS|-s|-S)
      printf '%b[_SUCCESS]%b ‚úÖ  %s\n' "$_SUCCESS" "$_NC" "$message"
      ;;
    *)
      if [[ "$debug" == true ]]; then
        log "info" "$message" "$debug"
      fi
      ;;
  esac
}

clear_screen() {
  printf "\033[H\033[2J"
}

get_current_shell() {
  local shell_proc
  shell_proc=$(cat /proc/$$/comm)
  case "${0##*/}" in
    ${shell_proc}*)
      local shebang
      shebang=$(head -1 "$0")
      printf '%s\n' "${shebang##*/}"
      ;;
    *)
      printf '%s\n' "$shell_proc"
      ;;
  esac
}

# Cria um diret√≥rio tempor√°rio para cache
_TEMP_DIR="${_TEMP_DIR:-$(mktemp -d)}"
if [[ -d "${_TEMP_DIR}" ]]; then
    log info "Diret√≥rio tempor√°rio criado: ${_TEMP_DIR}"
else
    log error "Falha ao criar o diret√≥rio tempor√°rio."
fi

clear_script_cache() {
  trap - EXIT HUP INT QUIT ABRT ALRM TERM
  if [[ ! -d "${_TEMP_DIR}" ]]; then
    exit 0
  fi
  rm -rf "${_TEMP_DIR}" || true
  if [[ -d "${_TEMP_DIR}" ]] && sudo -v 2>/dev/null; then
    sudo rm -rf "${_TEMP_DIR}"
    if [[ -d "${_TEMP_DIR}" ]]; then
      printf '%b[_ERROR]%b ‚ùå  %s\n' "$_ERROR" "$_NC" "Falha ao remover o diret√≥rio tempor√°rio: ${_TEMP_DIR}"
    else
      printf '%b[_SUCCESS]%b ‚úÖ  %s\n' "$_SUCCESS" "$_NC" "Diret√≥rio tempor√°rio removido: ${_TEMP_DIR}"
    fi
  fi
  exit 0
}

set_trap() {
  local current_shell=""
  current_shell=$(get_current_shell)
  case "${current_shell}" in
    *ksh|*zsh|*bash)
      declare -a FULL_SCRIPT_ARGS=("$@")
      if [[ "${FULL_SCRIPT_ARGS[*]}" =~ -d ]]; then
          set -x
      fi
      if [[ "${current_shell}" == "bash" ]]; then
        set -o errexit
        set -o pipefail
        set -o errtrace
        set -o functrace
        shopt -s inherit_errexit
      fi
      trap 'clear_script_cache' EXIT HUP INT QUIT ABRT ALRM TERM
      ;;
  esac
}

/// support/validate.sh ///
#!/usr/bin/env bash
# lib/validate.sh ‚Äì Valida√ß√£o da vers√£o do Go e depend√™ncias

validate_versions() {
    local REQUIRED_GO_VERSION="${_VERSION_GO:-1.20.0}"
    local GO_VERSION
    GO_VERSION=$(go version | awk '{print $3}' | sed 's/go//')
    if [[ "$(printf '%s\n' "$REQUIRED_GO_VERSION" "$GO_VERSION" | sort -V | head -n1)" != "$REQUIRED_GO_VERSION" ]]; then
        log error "A vers√£o do Go deve ser >= $REQUIRED_GO_VERSION. Detectado: $GO_VERSION"
        exit 1
    fi
    log success "Vers√£o do Go v√°lida: $GO_VERSION"
    go mod tidy || return 1
}

check_dependencies() {
    for dep in "$@"; do
        if ! command -v "$dep" > /dev/null; then
            log error "$dep n√£o est√° instalado."
            exit 1
        else
            log success "$dep est√° instalado."
        fi
    done
}

export -f validate_versions
export -f check_dependencies

/// templates/api-rest/README.md ///
# {{.ProjectName}}

{{.ProjectName}} is a REST API built with Go, generated using GoCrafter.

## Features

- ‚úÖ REST API with Gin framework
- ‚úÖ Structured logging with Logrus
- ‚úÖ Environment-based configuration
- ‚úÖ Graceful shutdown
- ‚úÖ Health check endpoints
{{- if .DatabaseType}}
- ‚úÖ {{.DatabaseType | title}} database integration
{{- end}}
{{- if .CacheType}}
- ‚úÖ {{.CacheType | title}} caching
{{- end}}
{{- if hasFeature "Authentication"}}
- ‚úÖ JWT authentication
{{- end}}
{{- if hasFeature "API Documentation"}}
- ‚úÖ Swagger API documentation
{{- end}}
{{- if .HasDocker}}
- ‚úÖ Docker support
{{- end}}
{{- if .HasKubernetes}}
- ‚úÖ Kubernetes manifests
{{- end}}

## Getting Started

### Prerequisites

- Go 1.21 or higher
{{- if .DatabaseType}}
- {{.DatabaseType | title}} database
{{- end}}
{{- if .CacheType}}
- {{.CacheType | title}} server
{{- end}}

### Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd {{.ProjectName}}
```

2. Install dependencies:
```bash
go mod download
```

3. Copy environment variables:
```bash
cp .env.example .env
```

4. Update the `.env` file with your configuration.

5. Run the application:
```bash
make run
```

The server will start on `http://localhost:8080`

## API Endpoints

### Health Check
- `GET /health` - Health check endpoint

### Users (Example)
- `GET /api/v1/users` - Get all users
- `POST /api/v1/users` - Create a new user
- `GET /api/v1/users/:id` - Get user by ID
- `PUT /api/v1/users/:id` - Update user
- `DELETE /api/v1/users/:id` - Delete user

{{- if hasFeature "API Documentation"}}
### API Documentation
- `GET /swagger/index.html` - Swagger UI
{{- end}}

## Configuration

The application uses environment variables for configuration:

| Variable | Description | Default |
|----------|-------------|---------|
| `ENVIRONMENT` | Application environment | `development` |
| `PORT` | Server port | `8080` |
| `LOG_LEVEL` | Log level | `info` |
{{- if .DatabaseType}}
| `DB_HOST` | Database host | `localhost` |
| `DB_PORT` | Database port | `{{- if eq .DatabaseType "postgres"}}5432{{- else if eq .DatabaseType "mysql"}}3306{{- else}}3306{{- end}}` |
| `DB_USER` | Database user | `{{- if eq .DatabaseType "postgres"}}postgres{{- else}}root{{- end}}` |
| `DB_PASSWORD` | Database password | `` |
| `DB_NAME` | Database name | `{{.PackageName}}` |
{{- end}}

## Development

### Running Tests
```bash
make test
```

### Building the Application
```bash
make build
```

### Linting
```bash
make lint
```

### Running with Docker
```bash
make docker-run
```

## Project Structure

```
{{.ProjectName}}/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ main.go          # Application entry point
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/          # Configuration management
‚îÇ   ‚îú‚îÄ‚îÄ handler/         # HTTP handlers
‚îÇ   ‚îú‚îÄ‚îÄ middleware/      # HTTP middleware
‚îÇ   ‚îú‚îÄ‚îÄ model/           # Data models
‚îÇ   ‚îú‚îÄ‚îÄ repository/      # Data access layer
‚îÇ   ‚îî‚îÄ‚îÄ service/         # Business logic
‚îú‚îÄ‚îÄ pkg/                 # Public packages
‚îú‚îÄ‚îÄ docs/                # Documentation
‚îú‚îÄ‚îÄ scripts/             # Build and deployment scripts
‚îú‚îÄ‚îÄ .env.example         # Environment variables template
‚îú‚îÄ‚îÄ Dockerfile           # Docker configuration
‚îú‚îÄ‚îÄ Makefile            # Build automation
‚îî‚îÄ‚îÄ README.md           # This file
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for your changes
5. Run tests and ensure they pass
6. Submit a pull request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

/// templates/api-rest/cmd/main.go ///
package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"{{.ModuleName}}/internal/config"
	"{{.ModuleName}}/internal/handler"
	"{{.ModuleName}}/internal/middleware"
	{{- if .DatabaseType}}
	"{{.ModuleName}}/internal/database"
	{{- end}}
	{{- if .CacheType}}
	"{{.ModuleName}}/internal/cache"
	{{- end}}

	"github.com/gin-gonic/gin"
	gl "github.com/kubex-ecosystem/gocrafter/logger"

	{{- if hasFeature "API Documentation"}}
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	_ "{{.ModuleName}}/api/swagger"
	{{- end}}
)

// @title {{.ProjectName}} API
// @version 1.0
// @description This is the {{.ProjectName}} API server.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1
func main() {
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// Setup logger
	setupLogger(cfg)

	// Setup Gin mode
	if cfg.Environment == "production" {
		gin.SetMode(gin.ReleaseMode)
	}

	{{- if .DatabaseType}}
	// Initialize database
	db, err := database.Initialize(cfg)
	if err != nil {
		gl.Log("fatal", "Failed to initialize database: %v", err)
	}
	defer database.Close(db)
	{{- end}}

	{{- if .CacheType}}
	// Initialize cache
	cacheClient, err := cache.Initialize(cfg)
	if err != nil {
		gl.Log("fatal", "Failed to initialize cache: %v", err)
	}
	defer cache.Close(cacheClient)
	{{- end}}

	// Create dependencies
	deps := &handler.Dependencies{
		Config: cfg,
		{{- if .DatabaseType}}
		DB:     db,
		{{- end}}
		{{- if .CacheType}}
		Cache:  cacheClient,
		{{- end}}
	}

	// Setup router
	router := setupRouter(deps)

	// Create server
	srv := &http.Server{
		Addr:         ":" + cfg.Port,
		Handler:      router,
		ReadTimeout:  time.Duration(cfg.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(cfg.WriteTimeout) * time.Second,
		IdleTimeout:  time.Duration(cfg.IdleTimeout) * time.Second,
	}

	// Start server in a goroutine
	go func() {
		gl.Log("info", "Starting server on port %s", cfg.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			gl.Log("fatal", "Failed to start server: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	gl.Log("info", "Shutting down server...")

	// Give the server 30 seconds to finish handling requests
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		gl.Log("fatal", "Server forced to shutdown: %v", err)
	}

	gl.Log("info", "Server stopped")
}

func setupRouter(deps *handler.Dependencies) *gin.Engine {
	router := gin.New()

	// Middleware
	router.Use(middleware.Logger())
	router.Use(middleware.Recovery())
	{{- if hasFeature "CORS"}}
	router.Use(middleware.CORS())
	{{- end}}
	{{- if hasFeature "Rate Limiting"}}
	router.Use(middleware.RateLimit())
	{{- end}}

	// Health check endpoint
	router.GET("/health", handler.HealthCheck(deps))

	{{- if hasFeature "API Documentation"}}
	// Swagger documentation
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	{{- end}}

	// API routes
	v1 := router.Group("/api/v1")
	{
		// Initialize handlers
		h := handler.NewHandlers(deps)

		// Example routes
		v1.GET("/users", h.GetUsers)
		v1.POST("/users", h.CreateUser)
		v1.GET("/users/:id", h.GetUser)
		v1.PUT("/users/:id", h.UpdateUser)
		v1.DELETE("/users/:id", h.DeleteUser)
	}

	return router
}

func setupLogger(cfg *config.Config) {
	if cfg.Environment == "development" {
		gl.SetDebug(true)
	}
}

/// templates/api-rest/internal/config/config.go ///
package config

import (
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

// Config holds the application configuration
type Config struct {
	Environment  string
	Port         string
	LogLevel     string
	ReadTimeout  int
	WriteTimeout int
	IdleTimeout  int

	{{- if .DatabaseType}}
	// Database configuration
	DatabaseURL      string
	DatabaseHost     string
	DatabasePort     string
	DatabaseUser     string
	DatabasePassword string
	DatabaseName     string
	DatabaseSSLMode  string
	{{- end}}

	{{- if .CacheType}}
	// Cache configuration
	{{- if eq .CacheType "redis"}}
	RedisURL      string
	RedisPassword string
	RedisDB       int
	{{- end}}
	{{- end}}

	{{- if hasFeature "Authentication"}}
	// JWT configuration
	JWTSecret     string
	JWTExpiration int
	{{- end}}
}

// Load loads the configuration from environment variables
func Load() (*Config, error) {
	// Load .env file if it exists
	_ = godotenv.Load()

	config := &Config{
		Environment:  getEnv("ENVIRONMENT", "development"),
		Port:         getEnv("PORT", "8080"),
		LogLevel:     getEnv("LOG_LEVEL", "info"),
		ReadTimeout:  getEnvAsInt("READ_TIMEOUT", 10),
		WriteTimeout: getEnvAsInt("WRITE_TIMEOUT", 10),
		IdleTimeout:  getEnvAsInt("IDLE_TIMEOUT", 60),

		{{- if .DatabaseType}}
		// Database
		DatabaseURL:      getEnv("DATABASE_URL", ""),
		DatabaseHost:     getEnv("DB_HOST", "localhost"),
		DatabasePort:     getEnv("DB_PORT", "{{- if eq .DatabaseType "postgres"}}5432{{- else if eq .DatabaseType "mysql"}}3306{{- else if eq .DatabaseType "mongodb"}}27017{{- else}}3306{{- end}}"),
		DatabaseUser:     getEnv("DB_USER", "{{- if eq .DatabaseType "postgres"}}postgres{{- else}}root{{- end}}"),
		DatabasePassword: getEnv("DB_PASSWORD", ""),
		DatabaseName:     getEnv("DB_NAME", "{{.PackageName}}"),
		DatabaseSSLMode:  getEnv("DB_SSL_MODE", "disable"),
		{{- end}}

		{{- if .CacheType}}
		{{- if eq .CacheType "redis"}}
		// Redis
		RedisURL:      getEnv("REDIS_URL", "redis://localhost:6379"),
		RedisPassword: getEnv("REDIS_PASSWORD", ""),
		RedisDB:       getEnvAsInt("REDIS_DB", 0),
		{{- end}}
		{{- end}}

		{{- if hasFeature "Authentication"}}
		// JWT
		JWTSecret:     getEnv("JWT_SECRET", "your-secret-key-change-this-in-production"),
		JWTExpiration: getEnvAsInt("JWT_EXPIRATION", 3600), // 1 hour
		{{- end}}
	}

	return config, nil
}

// getEnv gets an environment variable with a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// getEnvAsInt gets an environment variable as integer with a default value
func getEnvAsInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

/// templates/api-rest/template.json ///
{
  "name": "api-rest",
  "description": "REST API server with HTTP endpoints and modern Go practices",
  "version": "1.0.0",
  "author": "GoCrafter Team",
  "tags": ["api", "rest", "http", "server", "web"],
  "features": [
    "HTTP server with Gin framework",
    "Structured logging",
    "Environment configuration",
    "Database integration ready",
    "Middleware support",
    "Health check endpoints",
    "Graceful shutdown",
    "Docker support",
    "Makefile for common tasks",
    "CI/CD workflows"
  ]
}

/// test-api/README.md ///
# test-api

test-api is a REST API built with Go, generated using GoCrafter.

## Features

- ‚úÖ REST API with Gin framework
- ‚úÖ Structured logging with Logrus
- ‚úÖ Environment-based configuration
- ‚úÖ Graceful shutdown
- ‚úÖ Health check endpoints
- ‚úÖ Docker support

## Getting Started

### Prerequisites

- Go 1.21 or higher

### Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd test-api
```

2. Install dependencies:
```bash
go mod download
```

3. Copy environment variables:
```bash
cp .env.example .env
```

4. Update the `.env` file with your configuration.

5. Run the application:
```bash
make run
```

The server will start on `http://localhost:8080`

## API Endpoints

### Health Check
- `GET /health` - Health check endpoint

### Users (Example)
- `GET /api/v1/users` - Get all users
- `POST /api/v1/users` - Create a new user
- `GET /api/v1/users/:id` - Get user by ID
- `PUT /api/v1/users/:id` - Update user
- `DELETE /api/v1/users/:id` - Delete user

## Configuration

The application uses environment variables for configuration:

| Variable | Description | Default |
|----------|-------------|---------|
| `ENVIRONMENT` | Application environment | `development` |
| `PORT` | Server port | `8080` |
| `LOG_LEVEL` | Log level | `info` |

## Development

### Running Tests
```bash
make test
```

### Building the Application
```bash
make build
```

### Linting
```bash
make lint
```

### Running with Docker
```bash
make docker-run
```

## Project Structure

```
test-api/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ main.go          # Application entry point
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/          # Configuration management
‚îÇ   ‚îú‚îÄ‚îÄ handler/         # HTTP handlers
‚îÇ   ‚îú‚îÄ‚îÄ middleware/      # HTTP middleware
‚îÇ   ‚îú‚îÄ‚îÄ model/           # Data models
‚îÇ   ‚îú‚îÄ‚îÄ repository/      # Data access layer
‚îÇ   ‚îî‚îÄ‚îÄ service/         # Business logic
‚îú‚îÄ‚îÄ pkg/                 # Public packages
‚îú‚îÄ‚îÄ docs/                # Documentation
‚îú‚îÄ‚îÄ scripts/             # Build and deployment scripts
‚îú‚îÄ‚îÄ .env.example         # Environment variables template
‚îú‚îÄ‚îÄ Dockerfile           # Docker configuration
‚îú‚îÄ‚îÄ Makefile            # Build automation
‚îî‚îÄ‚îÄ README.md           # This file
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for your changes
5. Run tests and ensure they pass
6. Submit a pull request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

/// test-api/cmd/main.go ///
package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/user/test-api/internal/config"
	"github.com/user/test-api/internal/handler"
	"github.com/user/test-api/internal/middleware"

	"github.com/gin-gonic/gin"
	gl "github.com/kubex-ecosystem/gocrafter/logger"
)

// @title test-api API
// @version 1.0
// @description This is the test-api API server.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1
func main() {
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// Setup logger
	setupLogger(cfg)

	// Setup Gin mode
	if cfg.Environment == "production" {
		gin.SetMode(gin.ReleaseMode)
	}

	// Create dependencies
	deps := &handler.Dependencies{
		Config: cfg,
	}

	// Setup router
	router := setupRouter(deps)

	// Create server
	srv := &http.Server{
		Addr:         ":" + cfg.Port,
		Handler:      router,
		ReadTimeout:  time.Duration(cfg.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(cfg.WriteTimeout) * time.Second,
		IdleTimeout:  time.Duration(cfg.IdleTimeout) * time.Second,
	}

	// Start server in a goroutine
	go func() {
		gl.Log("info", "Starting server on port %s", cfg.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			gl.Log("fatal", "Failed to start server: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	gl.Log("info", "Shutting down server...")

	// Give the server 30 seconds to finish handling requests
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		gl.Log("fatal", "Server forced to shutdown: %v", err)
	}

	gl.Log("info", "Server stopped")
}

func setupRouter(deps *handler.Dependencies) *gin.Engine {
	router := gin.New()

	// Middleware
	router.Use(middleware.Logger())
	router.Use(middleware.Recovery())

	// Health check endpoint
	router.GET("/health", handler.HealthCheck(deps))

	// API routes
	v1 := router.Group("/api/v1")
	{
		// Initialize handlers
		h := handler.NewHandlers(deps)

		// Example routes
		v1.GET("/users", h.GetUsers)
		v1.POST("/users", h.CreateUser)
		v1.GET("/users/:id", h.GetUser)
		v1.PUT("/users/:id", h.UpdateUser)
		v1.DELETE("/users/:id", h.DeleteUser)
	}

	return router
}

func setupLogger(cfg *config.Config) {
	if cfg.Environment == "development" {
		gl.SetDebug(true)
	}
}

/// test-api/internal/config/config.go ///
package config

import (
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

// Config holds the application configuration
type Config struct {
	Environment  string
	Port         string
	LogLevel     string
	ReadTimeout  int
	WriteTimeout int
	IdleTimeout  int
}

// Load loads the configuration from environment variables
func Load() (*Config, error) {
	// Load .env file if it exists
	_ = godotenv.Load()

	config := &Config{
		Environment:  getEnv("ENVIRONMENT", "development"),
		Port:         getEnv("PORT", "8080"),
		LogLevel:     getEnv("LOG_LEVEL", "info"),
		ReadTimeout:  getEnvAsInt("READ_TIMEOUT", 10),
		WriteTimeout: getEnvAsInt("WRITE_TIMEOUT", 10),
		IdleTimeout:  getEnvAsInt("IDLE_TIMEOUT", 60),
	}

	return config, nil
}

// getEnv gets an environment variable with a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// getEnvAsInt gets an environment variable as integer with a default value
func getEnvAsInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

/// test-api/template.json ///
{
  "name": "api-rest",
  "description": "REST API server with HTTP endpoints and modern Go practices",
  "version": "1.0.0",
  "author": "GoCrafter Team",
  "tags": ["api", "rest", "http", "server", "web"],
  "features": [
    "HTTP server with Gin framework",
    "Structured logging",
    "Environment configuration",
    "Database integration ready",
    "Middleware support",
    "Health check endpoints",
    "Graceful shutdown",
    "Docker support",
    "Makefile for common tasks",
    "CI/CD workflows"
  ]
}

/// version/semantic.go ///
package version

import (
	"os"
	"path/filepath"

	gl "github.com/kubex-ecosystem/gocrafter/logger"
	l "github.com/kubex-ecosystem/logz"

	"github.com/spf13/cobra"

	_ "embed"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"
)

func init() {
	if owner := os.Getenv("GITHUB_OWNER"); owner != "" {
		projectOwner = owner
	}
	moduleName = os.Getenv("GITHUB_REPOSITORY")
	if moduleName == "" {
		moduleName, err := os.Executable()
		if err == nil {
			moduleName = filepath.Base(moduleName)
		}
	}
	if moduleAliasEnv := os.Getenv("MODULE_ALIAS"); moduleAliasEnv != "" {
		moduleAlias = moduleAliasEnv
	}
}

var moduleAlias = "GoCrafter" // Default module alias, can be overridden by environment variable
var moduleName = "gocrafter"  // Default module name, can be overridden by environment variable

const currentVersionFallback = "v1.0.1"

//go:embed CLI_VERSION
var cliVersion string
var projectOwner = "rafa-mori" // Default project owner, can be overridden by environment variable
var gitModelUrl = "https://github.com/" + projectOwner + "/" + moduleName + ".git"

type Service interface {
	GetLatestVersion() (string, error)
	GetCurrentVersion() string
	IsLatestVersion() (bool, error)
}
type ServiceImpl struct {
	gitModelUrl    string
	latestVersion  string
	currentVersion string
}
type Tag struct {
	Name string `json:"name"`
}

func init() {
	l.GetLogger(moduleAlias)
}

func getLatestTag(repoURL string) (string, error) {
	apiURL := fmt.Sprintf("%s/tags", repoURL)
	resp, err := http.Get(apiURL)
	if err != nil {
		return "", err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to fetch tags: %s", resp.Status)
	}

	var tags []Tag
	if err := json.NewDecoder(resp.Body).Decode(&tags); err != nil {
		return "", err
	}

	if len(tags) == 0 {
		return "", fmt.Errorf("no tags found")
	}

	return tags[0].Name, nil
}

func (v *ServiceImpl) updateLatestVersion() error {
	repoURL := strings.TrimSuffix(v.gitModelUrl, ".git")
	tag, err := getLatestTag(repoURL)
	if err != nil {
		return err
	}
	v.latestVersion = tag
	return nil
}
func (v *ServiceImpl) vrsCompare(v1, v2 []int) (int, error) {
	if len(v1) != len(v2) {
		return 0, fmt.Errorf("version length mismatch")
	}

	for idx, v2S := range v2 {
		v1S := v1[idx]
		if v1S > v2S {
			return 1, nil
		}

		if v1S < v2S {
			return -1, nil
		}
	}
	return 0, nil
}
func (v *ServiceImpl) versionAtMost(versionAtMostArg, max []int) (bool, error) {
	if comp, err := v.vrsCompare(versionAtMostArg, max); err != nil {
		return false, err
	} else if comp == 1 {
		return false, nil
	}
	return true, nil
}
func (v *ServiceImpl) parseVersion(versionToParse string) []int {
	version := make([]int, 3)
	for idx, vStr := range strings.Split(versionToParse, ".") {
		vS, err := strconv.Atoi(vStr)
		if err != nil {
			return nil
		}
		version[idx] = vS
	}
	return version
}

func (v *ServiceImpl) IsLatestVersion() (bool, error) {
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return false, err
		}
	}

	curr := v.parseVersion(v.currentVersion)
	latest := v.parseVersion(v.latestVersion)

	if curr == nil || latest == nil {
		return false, fmt.Errorf("error parsing versions")
	}

	if isLatest, err := v.versionAtMost(curr, latest); err != nil {
		return false, err
	} else if isLatest {
		return true, nil
	}
	return false, nil
}
func (v *ServiceImpl) GetLatestVersion() (string, error) {
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return "", err
		}
	}

	return v.latestVersion, nil
}
func (v *ServiceImpl) GetCurrentVersion() string { return v.currentVersion }

func NewVersionService() Service {
	return &ServiceImpl{
		gitModelUrl:    gitModelUrl,
		currentVersion: currentVersion,
		latestVersion:  "",
	}
}

var (
	versionCmd = &cobra.Command{
		Use:   "version",
		Short: "Print the version number of " + moduleAlias,
		Long:  "Print the version number of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetVersionInfo()
		},
	}
	subLatestCmd = &cobra.Command{
		Use:   "latest",
		Short: "Print the latest version number of " + moduleAlias,
		Long:  "Print the latest version number of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetLatestVersionInfo()
		},
	}
	subCmdCheck = &cobra.Command{
		Use:   "check",
		Short: "Check if the current version is the latest version of " + moduleAlias,
		Long:  "Check if the current version is the latest version of " + moduleAlias,
		Run: func(cmd *cobra.Command, args []string) {
			GetVersionInfoWithLatestAndCheck()
		},
	}
)

//go:embed CLI_VERSION
var currentVersion string

func GetVersion() string {
	if currentVersion == "" {
		return currentVersionFallback
	}
	return currentVersion
}

func GetGitModelUrl() string {
	return gitModelUrl
}

func GetVersionInfo() string {
	gl.Log("info", "Version: "+GetVersion())
	gl.Log("info", "Git repository: "+GetGitModelUrl())
	return fmt.Sprintf("Version: %s\nGit repository: %s", GetVersion(), GetGitModelUrl())
}

func GetLatestVersionFromGit() string {
	netClient := &http.Client{
		Timeout: time.Second * 10,
	}

	gitUrlWithoutGit := strings.TrimSuffix(gitModelUrl, ".git")

	response, err := netClient.Get(gitUrlWithoutGit + "/releases/latest")
	if err != nil {
		gl.Log("error", "Error fetching latest version: "+err.Error())
		gl.Log("error", gitUrlWithoutGit+"/releases/latest")
		return err.Error()
	}

	if response.StatusCode != 200 {
		gl.Log("error", "Error fetching latest version: "+response.Status)
		gl.Log("error", "Url: "+gitUrlWithoutGit+"/releases/latest")
		body, _ := io.ReadAll(response.Body)
		return fmt.Sprintf("Error: %s\nResponse: %s", response.Status, string(body))
	}

	tag := strings.Split(response.Request.URL.Path, "/")

	return tag[len(tag)-1]
}

func GetLatestVersionInfo() string {
	gl.Log("info", "Latest version: "+GetLatestVersionFromGit())
	return "Latest version: " + GetLatestVersionFromGit()
}

func GetVersionInfoWithLatestAndCheck() string {
	if GetVersion() == GetLatestVersionFromGit() {
		gl.Log("info", "You are using the latest version.")
		return fmt.Sprintf("You are using the latest version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	} else {
		gl.Log("warn", "You are using an outdated version.")
		return fmt.Sprintf("You are using an outdated version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	}
}

func CliCommand() *cobra.Command {
	versionCmd.AddCommand(subLatestCmd)
	versionCmd.AddCommand(subCmdCheck)
	return versionCmd
}
